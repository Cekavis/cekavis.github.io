{"posts":[{"title":"不吃不喝的一天","text":"很久没有病这么重。 大前天晚上睡下之后，又陷入一个人的崩溃，没人会听我，我也放任歪曲了的情绪蔓延。向来都是这样，只是这次醒得格外早。被吵醒再继续睡，最后熬到九点多起床，把头晕就归在昨夜的失眠之上。上午就有腹泻，晕到书也读不下去，中午把早餐都吐了，想起来上一次吐可能是在初中跑完长跑。呕吐前最后的挣扎是很奇妙的，我总是不愿屈服于这非条件反射，却又不得不准备着即将到来的风暴，找好一个容易处理的地点。放松，深呼吸，两次，三次，最后往往不得善终。 吐完一次，我喝了很多水，等待着身体好些去买午饭。没想到又把水也吐了，于是不敢喝太多，但是三点又吐了。 看上去一点都不好，我想也许见不到明天的太阳了，但是要不要告诉她呢？她也许会说我的死也只是我自己的事，也许会说大惊小怪干什么；我也不相信能得到好的结果。且不论说与不说，我到底会不会希望她来到我的墓前呢？我不知道。 跟着我妈去了医院，医院变成了工地，要从原先急诊的地方进楼，科室位置也都变了。到了普通内科，医生说这些症状现在要去急诊内科；化验交费的时候医保局的线断了，等了半个小时才恢复；付药钱的时候急诊说去门诊付，走到门诊已经关门了，又回去付，付完又到门诊来取药。可算是祸不单行。 有一种中药，虽然一袋只有三克，却是我不喜欢的味道。循环放着《A Step You Can’t Take Back》，终于咽下了最后一口。一天不吃不喝已经让我消瘦了许多，吃了点清淡的晚餐，虽然肠胃好了点，但似乎开始发烧。晚上又吐了晚餐，重新吃了点面条去睡了。我的身体发烫，腿却没有再酸。梦里我成了一个由肉棒交织起来的三维大网，高效地向外散热，而这都不是真的，醒来通常会有一身汗，掀开被子散一会儿热后便继续睡。迷迷糊糊到了早晨，我开始庆幸我活了下来。 昨天的病平淡了许多，我仍记着呕吐的滋味，于是用一集集《猫和老鼠》将大脑转移到别处。终于又可以自由呼吸了。 2021年2月3日","link":"/2021-2-3/"},{"title":"2020 集训队作业 题解","text":"题目链接： Codeforces 587 D. Duff in Mafia Codeforces 674 F. Bears and Juice ARC 091 F - Strange Nim 欢迎任何建议 PDF 链接","link":"/2020-team-problems-solution/"},{"title":"「51nod 1847」奇怪的数学题","text":"51nod 1847 题意给出 $n,k$ 求 $$\\sum_{i=1}^n\\sum_{j=1}^n sgcd(i,j)^k$$ 其中 $sgcd(i,j)$ 表示 $i,j$ 的次大公约数，特殊地，$sgcd(1,1)=0$ 对 $2^{32}$ 取模 $n\\le 10^9, k\\le 50$ 做法令 $f(x)$ 表示 $x$ 的次大因数，特殊地，$f(1)=0$ 于是 $$\\begin{align}&amp; \\sum_{i=1}^n\\sum_{j=1}^n sgcd(i,j)^k \\= &amp; \\sum_{i=1}^n\\sum_{j=1}^n f(\\gcd(i,j))^k \\= &amp; \\sum_{g=1}^n f(g)^k \\sum_{i=1}^{\\lfloor \\frac{n}{g} \\rfloor}\\sum_{j=1}^{\\lfloor \\frac{n}{g} \\rfloor} [\\gcd(i,j)=1] \\= &amp; \\sum_{g=1}^n f(g)^k \\left(2 \\left( \\sum_{i=1}^{\\lfloor \\frac{n}{g} \\rfloor} \\varphi(i) \\right) - 1 \\right)\\end{align}$$ 显然右边的部分可以Min_25筛/杜教筛处理 Min_25筛参考这里 我们需要对于每个 $\\lfloor \\frac{n}{x} \\rfloor$ 求出 $\\sum_{g=1}^{\\lfloor \\frac{n}{x} \\rfloor} f(g)^k$ 显然对于 $g\\ne 1$，$f(g)=\\frac{g}{g\\text{ 的最小质因子}}$，并且对于合数 $g$，$g\\text{ 的最小质因子}\\le \\sqrt{g}$ 每个质数的贡献是 $1$，这可以在Min_25筛的第一部分预处理质数时计算 事实上这里不需要第二部分，考虑对于一个 $\\lfloor \\frac{n}{x} \\rfloor$，$\\lfloor \\frac{n}{x} \\rfloor$ 以内的所有合数都恰好被筛到一次，直接在第一部分内统计答案就好了 还有一点是这里模数不是质数，在Min_25筛预处理时需要求 $\\sum_{i=1}^n i^k$,不能用插值之类的做 因为 $$\\begin{align}x^k &amp; = \\sum_{i=0}^k \\begin{Bmatrix} k \\ i \\end{Bmatrix} x^{\\underline{i}} \\&amp; =\\sum_{i=0}^k \\begin{Bmatrix} k \\ i \\end{Bmatrix} \\binom{x}{i}i!\\end{align}$$ 其中 $\\begin{Bmatrix} n \\ k \\end{Bmatrix}$ 表示第二类斯特林数，上式可以用组合意义理解（膜yx） 所以 $$\\begin{align}\\sum_{x=1}^n x^k &amp; = \\sum_{x=1}^n \\sum_{i=0}^k \\begin{Bmatrix} k \\ i \\end{Bmatrix} \\binom{x}{i}i! \\&amp; = \\sum_{i=0}^k i! \\begin{Bmatrix} k \\ i \\end{Bmatrix} \\sum_{x=1}^n \\binom{x}{i} \\&amp; = \\sum_{i=0}^k i! \\begin{Bmatrix} k \\ i \\end{Bmatrix} \\binom{n+1}{i+1} \\&amp; = \\sum_{i=0}^k \\begin{Bmatrix} k \\ i \\end{Bmatrix} \\frac{(n+1)^{\\underline{i+1}}}{i+1}\\end{align}$$ 显然最后的下降幂中必有一项被 $i+1$ 整除，所以可以 $\\mathcal O(k^2)$ 地计算一个 $k$ 次幂前缀和 总复杂度 $\\mathcal O(\\frac{n^{\\frac{3}{4}}}{\\log n} + \\sqrt{n}k^2)$ 或 $\\mathcal O(\\frac{n^{\\frac{3}{4}}}{\\log n} + \\sqrt{n}k^2 + n^{\\frac{2}{3}})$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longconst int N = 31627, K = 52;int n, k, id, cnt, sn, prime[N], pk[N], a[N&lt;&lt;1];unsigned Ans, s[K][K], g[N&lt;&lt;1], f[N&lt;&lt;1], h[N&lt;&lt;1], F[N&lt;&lt;1], ans[N&lt;&lt;1];inline int Id(int x){ return x&lt;=sn?x:id-n/x+1;}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k), sn=sqrt(n); s[1][1]=1; for(int i=2; i&lt;=k; ++i) for(int j=1; j&lt;=i; ++j) s[i][j]=s[i-1][j-1]+j*s[i-1][j]; for(int i=1; i&lt;=n; i=a[id]+1){ a[++id]=n/(n/i); for(int j=0; j&lt;=k; ++j){ unsigned x=s[k][j]; for(int t=0; t&lt;=j; ++t) if((a[id]+1-t)%(j+1)) x*=a[id]+1-t; else x*=(a[id]+1-t)/(j+1); g[id]+=x; } --g[id], f[id]=(ll)a[id]*(a[id]+1)/2-1, h[id]=a[id]-1; } for(int i=2; i&lt;=sn; ++i) if(h[i]!=h[i-1]){ prime[++cnt]=i; for(int j=pk[cnt]=1; j&lt;=k; ++j) pk[cnt]*=i; for(int j=id; i*i&lt;=a[j]; --j){ int p=Id(a[j]/i); g[j]-=pk[cnt]*(g[p]-g[i-1]); ans[j]+=g[p]-g[i-1]; f[j]-=i*(f[p]-f[i-1]); h[j]-=h[p]-(cnt-1); } } for(int i=1; i&lt;=id; ++i) F[i]=(f[i]-=h[i]); for(int i=cnt; i; --i) for(int j=id; prime[i]*prime[i]&lt;=a[j]; --j) for(unsigned x=prime[i], y=x-1; (ll)x*prime[i]&lt;=a[j]; x*=prime[i], y*=prime[i]) F[j]+=y*(F[Id(a[j]/x)]-f[prime[i]]+prime[i]); for(int i=2; i&lt;=id; ++i) Ans+=(ans[i]-ans[i-1]+h[i]-h[i-1])*(2*F[id-i+1]+1); return printf(&quot;%u\\n&quot;, Ans), 0;}","link":"/51nod-1847/"},{"title":"「51nod 1965」奇怪的式子","text":"为什么模数是偶数我都敢先取模后除以2了。不知道是不是傻了。 51nod 1965 题意求 $$\\prod_{i=1}^n \\sigma_0(i)^{\\mu(i)+i} \\mod(10^{12}+39)$$ 其中 $\\sigma_0(i)$ 表示 $i$ 的正约数个数，$10^{12}+39$ 是质数 $n\\le 10^{11}$ 做法$$\\prod_{i=1}^n \\sigma_0(i)^{\\mu(i)+i}\\prod_{i=1}^n \\sigma_0(i)^i\\prod_{i=1}^n \\sigma_0(i)^{\\mu(i)}$$ 两部分可以分开来做 一考虑每个质数的贡献 $$\\prod_{i=1}^n \\sigma_0(i)^i\\prod_{p\\text{是质数}}\\prod_{p^i\\le n}(i+1)^{f(\\lfloor \\frac{n}{p^i} \\rfloor) * p^i - f(\\lfloor \\frac{n}{p^{i+1}} \\rfloor) * p^{i+1}}$$ 其中 $f(x)=\\sum\\limits_{i=1}^x i=\\frac{x(x+1)}{2}$ 对于 $p\\le \\sqrt{n}$ 枚举 $p$ 计算贡献 对于 $p&gt;\\sqrt{n}$，指数只能为 $1$ 于是贡献为 $$\\prod_{p&gt;\\sqrt{n},p\\text{是质数}} 2^{f(\\lfloor \\frac{n}{p} \\rfloor) * p}$$ 用Min_25筛出对于每一个 $\\lfloor \\frac{n}{x} \\rfloor$ 的 $\\sum\\limits_{i=1}^{\\lfloor \\frac{n}{x} \\rfloor} [i\\text{是质数}] * i$ 分块计算即可 二要求 $\\prod\\limits_{i=1}^n \\sigma_0(i)^{\\mu(i)}$ 可以发现对于有平方因子的 $i$ ，$\\mu(i)=0$，所以没有贡献 令 $g(i)$ 表示 $i$ 的质因子数 $$\\begin{align}&amp; \\prod_{i=1}^n \\sigma_0(i)^{\\mu(i)} \\= &amp; \\prod_{i=1}^n 2^{\\mu(i)g(i)} \\= &amp; 2^{\\left(\\sum_{i=1}^n \\mu(i)g(i)\\right)}\\end{align}$$ 考虑怎么求 $\\sum\\limits_{i=1}^n \\mu(i)g(i)$ 令 $$\\begin{align}F(a,b)&amp;=\\sum_{i=2}^a [i\\text{是质数 或 } pmin_i\\ge prime_b] * \\mu(i) \\S(a,b)&amp;=\\sum_{i=2}^a [i\\text{是质数 或 } pmin_i\\ge prime_b] * \\mu(i)g(i)\\end{align}$$ 其中 $pmin_i$ 表示 $i$ 的最小质因子，$prime_i$ 表示第 $i$ 个质数 于是可以用Min_25筛转移 $$\\begin{align}F(a,b)&amp;=F(a,b+1)-\\left(F(\\lfloor \\frac{a}{prime_b} \\rfloor,b+1)+b\\right) \\S(a,b)&amp;=S(a,b+1)-\\left(S(\\lfloor \\frac{a}{prime_b} \\rfloor,b+1)+F(\\lfloor \\frac{a}{prime_b},b+1)+2b\\right)\\end{align}$$ 注意这里的模数有点大，需要用快速乘 总复杂度 $\\mathcal O(\\frac{n^{\\frac{3}{4}}}{\\log n})$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longconst int N = 316230;const ll P = 1000000000039;int T, sn, cnt, id, prime[N];ll n, f[45], a[N&lt;&lt;1], g[N&lt;&lt;1], h[N&lt;&lt;1], S[N&lt;&lt;1];inline ll Mul(ll x, ll y, ll mod){ ll ans=(x*y-(ll)((long double)x*y/mod)*mod)%mod; return ans&lt;0?ans+mod:ans;}inline ll calc(ll x){ return (x&amp;1)?Mul(x, (x+1)/2, P-1):Mul(x/2, x+1, P-1);}inline int Id(ll x){ return x&lt;=sn?x:id-n/x+1;}inline ll Pow(ll x, ll y){ ll ans=1; for(; y; y&gt;&gt;=1, x=Mul(x, x, P)) if(y&amp;1) ans=Mul(ans, x, P); return ans;}int main() { scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%lld&quot;, &amp;n), sn=sqrt(n); cnt=id=0; for(ll i=1; i&lt;=n; i=a[id]+1) a[++id]=n/(n/i), g[id]=calc(a[id])-1, h[id]=a[id]-1; for(int i=2; i&lt;=sn; ++i) if(h[i]!=h[i-1]){ prime[++cnt]=i; for(int j=id, tmp; (ll)i*i&lt;=a[j]; --j) (g[j]-=Mul(i, g[tmp=Id(a[j]/i)]-g[i-1], P-1)-P+1)%=P-1, h[j]-=h[tmp]-(cnt-1); } memset(f, 0, sizeof f); for(int i=1; i&lt;=cnt; ++i) for(ll x=prime[i], j=2; x&lt;=n; x*=prime[i], ++j) f[j]+=Mul(calc(n/x), x, P-1)-Mul(calc(n/(x*prime[i])), x*prime[i], P-1); ll ans=1; for(int i=2; i&lt;=40; ++i) ans=Mul(ans, Pow(i, (f[i]%(P-1)+(P-1))%(P-1)), P); for(int i=1; i&lt;=sn; ++i) ans=Mul(ans, Pow(2, Mul(calc(a[i]), g[id-i+1]-g[max(sn, id-i)]+P-1, P-1)), P); for(int i=1; i&lt;=id; ++i) S[i]=h[i]=-h[i]; for(int i=cnt; i; --i) for(int j=id; (ll)prime[i]*prime[i]&lt;=a[j]; --j){ int t=Id(a[j]/prime[i]); h[j]-=h[t]+i; S[j]-=S[t]+h[t]+2*i; } printf(&quot;%lld\\n&quot;, Mul(ans, Pow(2, (S[id]%(P-1)+P-1)%(P-1)), P)); } return 0;}","link":"/51nod-1965/"},{"title":"「AGC005E」Sugigma: The Showdown","text":"AGC005E - Sugigma: The Showdown 题意有 $n$ 个点，$n-1$ 条红边和 $n-1$ 条蓝边分别把这些点连成一棵树 一开始第一个人在 $x$，第二个人在 $y$，第一个人先手，轮流操作 第一个人走红边，第二个人走蓝边，每次操作可以不动或走一条边。 当两个人相遇的时候游戏结束，第一个人希望最大化总步数，第二个人希望最小化，两个人绝顶聪明 问游戏能否结束，如果可以结束输出最后的步数 做法考虑如果有一条红边两个端点在蓝树上的距离 $&gt;2$，那么第一个人只要走过了一次这条边，第二个人就不可能结束游戏 考虑以 $y$ 为根构建蓝树，第一个人的移动视作在这棵树上跳，如果走的红边两个端点在蓝树上的距离 $\\le 2$，那么不可能跳出以第二个人所在点为根的子树 我们只要以 $x$ 为起点开始搜索，如果一个点被第一个人走到的时间小于第二个人走到的时间，这个点才可以继续，否则第一个人会在这里死掉 判掉游戏不会结束的情况，第一个人只能在可以到达的点中找一个离 $y$ 最远的等死 判距离是否 $&gt;2$ 可以深度和父子关系搞搞，也可以直接求距离，复杂度 $\\mathcal O(n)$ 或 $\\mathcal O(n\\log n)$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int N = 200005;int n, x, y, ans, top[N], dep[N], fa[N], siz[N], d[N];bool vis[N];vector&lt;int&gt; a[N], b[N];void dfs1(int u){ siz[u]=1; for(int v:b[u]) if(v!=fa[u]) dep[v]=dep[u]+1, fa[v]=u, dfs1(v), siz[u]+=siz[v];}void dfs2(int u){ int son=0; for(int v:b[u]) if(v!=fa[u] &amp;&amp; siz[v]&gt;siz[son]) son=v; if(son) top[son]=top[u], dfs2(son); for(int v:b[u]) if(v!=fa[u] &amp;&amp; v!=son) top[v]=v, dfs2(v);}void dfs3(int u, int fa=0){ if(vis[u] &amp;&amp; d[u]&lt;dep[u]){ puts(&quot;-1&quot;); exit(0); } if(d[u]&gt;=dep[u]) return; ans=max(ans, dep[u]); for(int v:a[u]) if(v!=fa) d[v]=d[u]+1, dfs3(v, u);}inline int dis(int x, int y){ int ans=dep[x]+dep[y]; while(top[x]!=top[y]) if(dep[top[x]]&lt;dep[top[y]]) y=fa[top[y]]; else x=fa[top[x]]; return ans-min(dep[x], dep[y])*2;}int main() { read(n), read(x), read(y); for(int i=1, u, v; i&lt;n; ++i) read(u), read(v), a[u].push_back(v), a[v].push_back(u); for(int i=1, u, v; i&lt;n; ++i) read(u), read(v), b[u].push_back(v), b[v].push_back(u); dfs1(y), top[y]=y, dfs2(y); for(int i=1; i&lt;=n; ++i) for(int j:a[i]) if(i&lt;j) if(dis(i, j)&gt;2) vis[i]=vis[j]=1; dfs3(x); return printf(&quot;%d&quot;, ans&lt;&lt;1), 0;}","link":"/agc-005e/"},{"title":"01分数规划","text":"问题有 $n$ 个物品，每个物品有两个属性 $a_i$ 和 $b_i$，需要选出 $k$ 个，设选出的编号集合是 $S$。 最大化 $$\\frac{\\sum_{i\\in S} a_i}{\\sum_{i\\in S} b_i}$$ 保留一定精度。 二分这个问题是可以二分的，考虑二分一个答案 $ans$，条件是 $$\\frac{\\sum_{i\\in S} a_i}{\\sum_{i\\in S} b_i} \\ge ans$$ 可以转化为 $$\\sum_{i\\in S} a_i-ans \\sum_{i\\in S} b_i \\ge 0$$ 这样只需要按照 $a_i-ans*b_i$ 排序取最大的 $k$ 个判断即可。 直接使用 sort()，令 $w$ 表示 $\\frac{\\text{值域}}{\\text{精度}}$，复杂度 $O(n\\log n\\log w)$。 用 nth_element()，复杂度 $O(n\\log w)$。 问题有其他变种，大概挺simple，二分基本上就好了。 迭代不知道这复杂度对不对，好像正确性也不知道，反正跑得快。 先令 $ans=0$，每次用相同的方法，可以求出一个 $\\frac{\\sum_{i\\in S} a_i}{\\sum_{i\\in S} b_i}$，显然这也是一个合法的答案，并且肯定更优。 一直迭代直到增加量很小时结束。 例题LOJ #149. 01分数规划 模板 迭代目前跑得最快。 二分的代码的写法大概是因为寻址不连续，没有写 struct 一起 nth_element() 快。 代码二分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int N = 100005;int n, k, a[N], b[N], g[N];double f[N];inline bool cmp(int x, int y){ return f[x]&gt;f[y];}inline double check(double x){ for(int i=1; i&lt;=n; ++i) f[i]=a[i]-b[i]*x, g[i]=i; nth_element(g+1, g+k+1, g+n+1, cmp); ll sa=0, sb=0; for(int i=1; i&lt;=k; ++i) sa+=a[g[i]], sb+=b[g[i]]; return (double)sa/sb;}int main() { read(n), read(k); for(int i=1; i&lt;=n; ++i) read(a[i]); for(int i=1; i&lt;=n; ++i) read(b[i]); double l=0, r=1e6, ans=0; while(r-l&gt;1e-7){ double mid=(l+r)/2; if(check(mid)&gt;=mid) ans=mid, l=mid; else r=mid; } return printf(&quot;%.4f&quot;, ans), 0;} 迭代1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int N = 100005;int n, k;struct item{ int a, b; double f; inline bool operator &lt;(const item &amp;rhs)const{ return f&gt;rhs.f;}} a[N];inline double check(double x){ for(int i=1; i&lt;=n; ++i) a[i].f=a[i].a-a[i].b*x; nth_element(a+1, a+k+1, a+n+1); ll sa=0, sb=0; for(int i=1; i&lt;=k; ++i) sa+=a[i].a, sb+=a[i].b; return (double)sa/sb;}int main() { read(n), read(k); for(int i=1; i&lt;=n; ++i) read(a[i].a); for(int i=1; i&lt;=n; ++i) read(a[i].b); ll sa=0, sb=0; for(int i=1; i&lt;=k; ++i) sa+=a[i].a, sb+=a[i].b; double ans=(double)sa/sb, last; do ans=check(last=ans); while(ans-last&gt;1e-6); return printf(&quot;%.4f&quot;, ans), 0;}","link":"/01-fractional-programming/"},{"title":"2021 集训队作业 题解","text":"题目链接： Problem E, 2018 ACM-ICPC World Finals Problem J, 2017 ACM-ICPC World Finals Problem H, 2015-2016 ACM-ICPC Northeastern European Regional Contest (NEERC 15) 欢迎任何建议 PDF 链接","link":"/2021-team-problems-solution/"},{"title":"「AGC021E」Ball Eat Chameleons","text":"AGC021E - Ball Eat Chameleons 找不到对于第二种做法的详细描述，看到的都只有一个式子. 于是来写一下. 题意有 $n$ 只变色龙，你会扔 $k$ 次球，球会被随机的一只变色龙吃掉. 球是蓝色或者红色的，初始时所有变色龙都是蓝色的，当一只变色龙吃下的红球和蓝球数量不同时它会变成较多的那种颜色. 你可以决定每次扔下球的颜色，求有多少种方案有可能使所有变色龙都变红. 两种方案不同当且仅当某一次扔下的球的颜色不同. $1\\le n,k \\le 5\\times 10^5$ 做法 1突然懒了，可以看官方题解. 做法 2做法 1 通过奇偶讨论和组合数裂项也可以化简成这样. 这里提供一种（也许）更直观的理解. 下面令 $R$ 表示红色的、红球、红球的数量等，$B$ 同理. 考虑对于一个确定的序列和 $n$ 判断是否可行. 由于我们希望最终所有变色龙都变成 $R$，对于 $B$ 的情况，如果存在一只变色龙吃的 $R&gt;B$，则可以把 $B$ 给它，否则可以把 $B$ 给一只钦定的变色龙（使大于一只变色龙吃的 $B&gt;R$ 不优的，因为使它们要变成 $R$ 需要额外的 $R$）. 对于 $R$，只会给 $B$ 变色龙. 因此对于一个序列，可以使 $n$ 只变色龙变成 $R$ 当且仅当： 其包含至少 $n-1$ 个 $R$. 任意选出 $n-1$ 个 $R$ 与右侧尽量接近的 $B$ 匹配，每个 $B$ 只能被匹配一次，如果不存在则不匹配，匹配是唯一的. 存在一种方案使得，原序列删除这些 $R$ 和 $B$ 之后的序列中 $R&gt;B$ 或 $R=B$ 且最后一个元素是 $B$. 下面设 $n$ 是最大的 $n$ 使得序列能使 $n$ 只变色龙变成 $R$. 设序列长度是 $k$. 假设一种上述的选择 $n-1$ 个 $R$ 的方案中某个 $R$ 到它对应的 $B$ 之间存在 $R$ 没有被选中，用后者替换前者，方案仍是合法的，因此下面我们只考虑每个 $R$ 都是极靠后的方案. 在序列的前 $k-1$ 个位置中选择 $n-1$ 个 $R$，由于满足了上述条件，可以推出其匹配的 $B$ 的位置集合，现在证明，在这些位置确定后，恰好存在一种方案使得序列至多能使 $n$ 只变色龙变成 $R$. 若余下的位置有奇数个，方案形如 $BB\\dots RR\\dots$，且 $R=B+1$ 因为 $R+B$ 是奇数，所以 $B$ 和 $R$ 奇偶性不同. 若 $R \\ge B+3$，则选中最后一个 $R$ 也是合法的，$n$ 不是最大的，矛盾. 若 $R&lt;B$，则不合法. 因此 $R=B+1$. 若存在形如 $RB$ 的两项，则选中这个 $R$ 也是合法的，$n$ 不是最大的，矛盾. 因此方案形如 $BB\\dots RR\\dots$ 若余下的位置有偶数个，方案形如 $BB\\dots RR \\dots B$，且 $R=B$. 因为 $R+B$ 是偶数，所以 $B$ 和 $R$ 奇偶性相同. 若 $R \\ge B+2$，则选择最后一个 $R$ 也是合法的，$n$ 不是最大的，矛盾. 若 $R&lt;B$，则不合法. 因此 $R=B$. 若最后一位不是 $B$ 则不合法. 若在前面存在形如 $RB$ 的两项，则选中这个 $R$ 也是合法的，$n$ 不是最大的，矛盾. 因此方案形如 $BB\\dots RR \\dots B$ 不同的选择位置集合显然对应不同的答案序列，因此至多能使 $n$ 只变色龙变成 $R$ 的序列数量是 $\\binom{k-1}{n-1}$，题目的答案即为 $\\sum_{i=n}^k \\binom{k-1}{i-1}$. 代码12345678910111213141516171819202122#include&lt;cstdio&gt;using namespace std;#define ll long longconst int N = 500005, P = 998244353;int n, k, ans, fac[N], ifac[N];int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k); fac[0]=1; for(int i=1; i&lt;=k; ++i) fac[i]=(ll)fac[i-1]*i%P; ifac[k]=Pow(fac[k]); for(int i=k; i; --i) ifac[i-1]=(ll)ifac[i]*i%P; for(int i=n; i&lt;=k; ++i) ans=(ans+(ll)fac[k-1]*ifac[i-1]%P*ifac[k-i])%P; printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/agc-021e/"},{"title":"2021","text":"拖延症越来越厉害，赶在除夕之前把挂念了很久的 2021 流水账写完吧。 拍照以前一直是用手机拍照的，家里有台古早的数码相机，比较简陋，似乎也不是我家的，上次摸到是我还很小的时候了。不得不说手机的“五倍光学变焦”镜头（等效约 125mm）对我的影响是很大的，长焦真是好用。这也促使我在三月买了第一台相机，算是生日礼物。各种旅游我就带着，后来开学后也加入了学生会打工。 一方面我很想让我自己拍的照片得到别人的认可，另一方面我又觉得拍照可以是很私人的事，不足为外人道也，自己喜欢就好。可能这后一部分仅仅是前一部分目标无法达成的自我保护吧。不管怎样，这现在是我为数不多可以称为爱好的活动之一。 中乐中乐大概是我会在大学拿起笛子的唯一原因，所以我时常庆幸那次尴尬的面试能让我被学社接受。刚开学选课的时候了解到了西音这门课，迷迷糊糊就选了，结果和地概一起选上了，运气有够好的。谁第一学期没选英语没选物理跑来选了两门通选课？后来逐渐了解到西音和中乐许许多多的联系（刚发现这两个名字似乎也对仗），原来世界那么小。 被师兄师姐写的小作文震撼到了，所以容许我以后再回忆这半年的故事吧（怎么可能是因为在除夕前快写不完这篇「2021」了）。另外因为个人习惯和对体力劳动的抗拒，一个学期我都是在寝室里自习，没有加入中乐的集体自习，下学期一定！下学期也要好好贡献自己的力量。 旅游疫情对我最大的打击或许就是让旅游变得十分困难。暑假里先和一位同学去上海玩了三天，上海去了许多次了，世博会、坐飞机、省队选拔、ICPC，这次去倒不能说全是因为一个破碎的约定，毕竟连锦江乐园也没去，只是自己想要旅游吧。第二次和几位同学去内蒙古玩，在郑州转机失败耽误了一天两夜，还顺便去到河南省博物馆参观，返程时我选择慢许多的高铁，而有些不长记性的同学在前一天得知了郑州暴雨的消息，不得不改变计划，想来是比我惨许多的。第三次和两位同学从贵州游到重庆，本来应该有六七人的，只是各有各的安排太难调和，等明年暑假学弟（因为复读而变成学弟）考完高考再补一次吧。这第一次和第三次都是两三人自己组织，只恨时间走得太匆忙。 在北京也游了颐和园和北海公园，香山公园因为思修课要求也和全班同学去了一次，只是不能算游过。期末考完和高中同学去了天安门和王府井一带。天安门在五岁、初一和高一时去过三次，还颇有印象。明年也要继续游北京。 所以说，快来约我！ 大学的学习和生活差点忘了读书人最重要的事——读书。 进入大学以前已经很久没有正经学点什么了，要调整学习状态，预想起来是会有点困难的。不过高中时候就已经习惯住校，自己也喜欢在外面跑，所以开学时是一个人坐高铁去的北京，虽然同车都是同学和家长。国庆节也没有回家，一来学校里还有事要做，二来并不怎么想家，方方面面基本都已经适应。课业上，数分和高代都选到了很好的老师，也没选经常要做 pre 写论文的英语课，一个学期过下来还算轻松。但绝不是说学的有多好，这从绩点便能看出来，也许是花在学习上的时间实在太少了吧，明年仍需努力。 学车由于不用准备高考的缘故，上半年病愈之后就有空学车了，在暑假前就拿到了驾照，比起众多寒假仍在学车的同学们是十分幸运了。 到现在虽已拿家里的车开过不少里程，也没有出过事故，但都是家长坐在旁边，还没有尝试独自出行。而且经常会有一些家长眼中的危险行为，也许是我习惯了赛车游戏里横冲直撞的感觉。电子毒品侵害青少年心智的案例又又又增加了。 病痛不知是因为时间上接近还是病痛的确比往年来得更重，去年的病在我的印象里是最深的。 二月的急性肠胃炎让我思考她会不会来我的墓前来看我；三月的生日是得了自发性气胸切掉了点肺刚拔掉上身插了几天的管子后在病房度过的；十月一度腿疼到不能正常姿势走路；十一月和导师吃饭被鱼刺卡了一天，打羽毛球脚趾甲掉了；十二月被干冷的北平折磨到咳嗽不止回家后一段时间才好。且不提各种小伤。 新年，请保佑我平安。 分手虽然有过从头写起的想法，但抱着用文字记下我记忆中即将流走的一切这个不切实际的目的，写出来的东西自己都看不下去。而且，哪有人在分手之后整理回忆写成编年史的。 已经不是第一次分手了，不同的是先前的每次分手都能在或长或短的时间里复合。从 2021 年初到现在也是将近一年的时间，本想描画一年里所谓的种种悲痛和怀念之情，但从高考结束后的暑假我没有去找她就知道那不是真的，怀念的不是她，不过是一个臆想出来的虚影罢了。可是假的又那么真，不然也不会伤心一年。从开始到结束一直是异地（而且那么远）的关系恐怕并不多见，压抑贯穿了整个高中时光。 我的家长有次翻到她寄来的信件，知道了我们的关系，还得出了她与周围同学相处不和、人格存在问题、成绩不好等结论（说得好像你儿子就有多好），从此便试图拆散我们。即便到后来态度有所改善，但不得不说产生了十分严重的影响。她确有她的问题，有问题未必是不正常，有问题而不自知的人才是。她带给我的许多是我不敢想象能在其他人那里得到的。 写在最后谢谢你读到这里。 2021 认识了一些新朋友，这比其他一切加起来更珍贵。如果只有一个人怎么过得完这 2021？ 分手之后执着于再找到一个对象，大概上天发现我其实没有准备好，便不让我闹出笑话。 2022 变得更好。 除夕快乐！ 2022年1月31日 除夕","link":"/2021/"},{"title":"「AtCoder ExaWizards 2019」简要题解","text":"AtCoder ExaWizards 2019 A - Regular Triangle题意判断三个数能否成为一个等边三角形的三条边的长度。 做法= = 代码1234567#include&lt;cstdio&gt;int a, b, c;int main() { scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); puts(a==b &amp;&amp; b==c ? &quot;Yes&quot; : &quot;No&quot;); return 0;} B - Red or Blue题意有一个仅包含 R 和 B 的字符串，判断 R 的数量是否严格比 B 多。 做法= = 代码12345678#include&lt;cstdio&gt;int n, ans;char s[105];int main() { scanf(&quot;%d%s&quot;, &amp;n, s); for(int i=0; i&lt;n; ++i) ans+=s[i]=='R'?1:-1; return puts(ans&gt;0?&quot;Yes&quot;:&quot;No&quot;), 0;} C - Snuke the Wizard题意有一排 $n$ 个格子，第 $i$ 个格子标有一个大写字母 $s_i$。 初始时每个格子上有一个傀儡，Snuke 会依次进行 $q$ 次操作。 第 $i$ 次操作给出 $t_i,d_i$， 若 $d_i$ 为 L 则把所有标了 $t_i$ 的格子上的傀儡左移一格。 若 $d_i$ 为 R 则把所有标了 $t_i$ 的格子上的傀儡右移一格。 若一个傀儡移出 $[1,n]$ 则立刻消失。 求最终留下的傀儡个数。 $n,q\\le 2\\times 10^5$ 做法还想了好久 显然任意两个傀儡之间的相对顺序不会改变。 于是消失的傀儡是一个前缀和一个后缀。 直接二分判断。 复杂度 $O(n\\log n)$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 200005;int n, q;char s[N], t[N], d[N];inline int solve(int x){ for(int i=1; i&lt;=q; ++i) if(t[i]==s[x]) x+=(d[i]=='L'?-1:1); return x;}int main() { read(n), read(q); while(isspace(s[1]=read())); for(int i=2; i&lt;=n; ++i) s[i]=read(); for(int i=1; i&lt;=q; ++i){ while(isspace(t[i]=read())); while(isspace(d[i]=read())); } int l=1, r=n, ans1=0, ans2=n+1; while(l&lt;=r){ int mid=(l+r)&gt;&gt;1; if(!solve(mid)) ans1=mid, l=mid+1; else r=mid-1; } l=1, r=n; while(l&lt;=r){ int mid=(l+r)&gt;&gt;1; if(solve(mid)==n+1) ans2=mid, r=mid-1; else l=mid+1; } return printf(&quot;%d&quot;, ans2-ans1-1), 0;} D - Modulo Operations题意有 $n$ 个互不相同的数 $s_1,s_2,\\dotsc,s_n$。 给出一个 $x$，求共 $n!$ 种排列 $p_1,p_2,\\dotsc,p_n$，初值 $x$ 依次模 $s_{p_1},s_{p_2},\\dotsc,s_{p_n}$ 最后得到的数的和。 $n\\le 200,s_i,x\\le 10^5$。 做法$x\\bmod y\\ne x$ 当且仅当 $y\\le x$。 令 $f_i$ 表示当前的数为 $i$，忽略所有 $s_k &gt; i$ 后的答案。 于是枚举一个 $s_k\\le i$，表示下一次选的数，得到的新的数为 $i\\bmod s_k$。 于是除了 $s_k$ 以外在 $(i\\bmod s_k,i]$ 中的数可以在任何时候选，可以先乘上一个方案数。 复杂度 $O(nx)$。 代码实现和上面写的不同，是从 $x$ 出发计算成为每个值的方案数。 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ll long longconst int N = 100005, M = 205, P = 1000000007;int n, x, ans, a[M], f[N], s[N], is[N];inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;x); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, a+i); sort(a+1, a+n+1); for(int i=1; i&lt;=x; ++i){ s[i]=1; for(int j=1; j&lt;=n; ++j) if(a[j]&gt;i) s[i]=(ll)s[i]*j%P; is[i]=Pow(s[i]); } f[x]=s[x]; for(int i=x; i&gt;=a[1]; --i) if(f[i]){ int cnt=1; for(int j=n; j; --j) if(a[j]&lt;=i) f[i%a[j]]=(f[i%a[j]]+(ll)f[i]*s[i%a[j]]%P*is[a[j]-1]%P*cnt)%P, cnt=(ll)cnt*(j-1)%P; } for(int i=1; i&lt;a[1]; ++i) ans=(ans+(ll)i*f[i])%P; return printf(&quot;%d&quot;, ans), 0;} E - Black or White题意有 $b$ 个黑子和 $w$ 个白子。 每次以相等的概率选取一个还有剩余的颜色，扔掉该颜色的一个棋子。 对于每个 $i\\in[1,b+w]$ 输出第 $i$ 次扔黑子的概率。 $b,w\\le 10^5$。 做法 如果第 $i$ 次两种颜色都有剩余，那么概率为 $\\frac{1}{2}$。 如果仅有黑色，概率为 $1$。 如果仅有白色，概率为 $0$。 枚举 $i$，每种情况的概率可以轻易维护。 复杂度 $O(b+w)$。 代码1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define ll long longconst int N = 200005, P = 1000000007, inv2 = (P+1)/2;int b, w, fac[N], ifac[N], p[N];inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}inline int C(int x, int y){ return x&gt;=y?(ll)fac[x]*ifac[y]%P*ifac[x-y]%P:0;}int main() { scanf(&quot;%d%d&quot;, &amp;b, &amp;w); fac[0]=p[0]=1; for(int i=1; i&lt;N; ++i) fac[i]=(ll)fac[i-1]*i%P, p[i]=(ll)p[i-1]*inv2%P; ifac[N-1]=Pow(fac[N-1]); for(int i=N; --i;) ifac[i-1]=(ll)ifac[i]*i%P; for(int i=1; i&lt;min(b, w); ++i) printf(&quot;%d\\n&quot;, inv2); int x=0, y=0; for(int i=min(b, w); i&lt;=b+w; ++i){ printf(&quot;%lld\\n&quot;, ((ll)(P+P+1-x-y)*inv2+y)%P); x=(x+(ll)C(i-1, b-1)*p[i])%P; y=(y+(ll)C(i-1, w-1)*p[i])%P; } return 0;} F - More Realistic Manhattan Distance题意有一个 $n\\times m$ 的网格图。 每行和每列都确定了一个方向，该行/列相邻的两个点都有一条该方向的边权为 $1$ 的有向边。 $q$ 次询问两点间的最短路，如果无法到达输出 $-1$。 $n,m\\le 10^5,q\\le 2\\times 10^5$。 做法分析一下性质 一条最短路径至多转弯 $4$ 次 可以通过枚举证明，参考官方题解的末尾。 除了起点，每个点最多扩展 $3$ 个新的点 考虑一个有用的点必须是拐点，于是方向只有一种，讨论和终点的位置关系： 若终点在射线上，则直接走到最优。 若沿方向走一步会远离终点（反终点方向），那么显然只要考虑第一个可以左拐和第一个可以右拐的点即可。 若沿方向走一步会靠近终点，除了上述两种情况，还需要考虑经过射线上离终点最近的一个点之后第一个能转向终点方向的点，证明也类似。 于是暴力扩展只有 $O(1)$ 个有用的点。 复杂度 $O(q)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 100005, M = 5;pair&lt;int,int&gt; A, B, f[M][N];int n, m, q, ans, cnt[M], tl[N][2], tr[N][2], sl[N][2], sr[N][2], dis[M][N];bool g[M][N];char s[N], t[N];inline void extend(int id, pair&lt;int,int&gt; a, int d, bool e){ int x=a.first, y=a.second, z; if(e){ if(t[y]=='S'){ if(sr[x][0]) f[id][cnt[id]]=make_pair(sr[x][0], y), g[id][cnt[id]]=e, dis[id][cnt[id]++]=d+sr[x][0]-x; if(sr[x][1]) f[id][cnt[id]]=make_pair(sr[x][1], y), g[id][cnt[id]]=e, dis[id][cnt[id]++]=d+sr[x][1]-x; if(B.first&gt;x){ if(B.second==y) ans=min(ans, d+B.first-x); if(z=sr[B.first-1][B.second&gt;y]) f[id][cnt[id]]=make_pair(z, y), g[id][cnt[id]]=e, dis[id][cnt[id]++]=d+z-x; } } else{ if(sl[x][0]) f[id][cnt[id]]=make_pair(sl[x][0], y), g[id][cnt[id]]=e, dis[id][cnt[id]++]=d+x-sl[x][0]; if(sl[x][1]) f[id][cnt[id]]=make_pair(sl[x][1], y), g[id][cnt[id]]=e, dis[id][cnt[id]++]=d+x-sl[x][1]; if(B.first&lt;x){ if(B.second==y) ans=min(ans, d+x-B.first); if(z=sl[B.first+1][B.second&gt;y]) f[id][cnt[id]]=make_pair(z, y), g[id][cnt[id]]=e, dis[id][cnt[id]++]=d+x-z; } } } else{ if(s[x]=='E'){ if(tr[y][0]) f[id][cnt[id]]=make_pair(x, tr[y][0]), g[id][cnt[id]]=e, dis[id][cnt[id]++]=d+tr[y][0]-y; if(tr[y][1]) f[id][cnt[id]]=make_pair(x, tr[y][1]), g[id][cnt[id]]=e, dis[id][cnt[id]++]=d+tr[y][1]-y; if(B.second&gt;y){ if(B.first==x) ans=min(ans, d+B.second-y); if(z=tr[B.second-1][B.first&gt;x]) f[id][cnt[id]]=make_pair(x, z), g[id][cnt[id]]=e, dis[id][cnt[id]++]=d+z-y; } } else{ if(tl[y][0]) f[id][cnt[id]]=make_pair(x, tl[y][0]), g[id][cnt[id]]=e, dis[id][cnt[id]++]=d+y-tl[y][0]; if(tl[y][1]) f[id][cnt[id]]=make_pair(x, tl[y][1]), g[id][cnt[id]]=e, dis[id][cnt[id]++]=d+y-tl[y][1]; if(B.second&lt;y){ if(B.first==x) ans=min(ans, d+y-B.second); if(z=tl[B.second+1][B.first&gt;x]) f[id][cnt[id]]=make_pair(x, z), g[id][cnt[id]]=e, dis[id][cnt[id]++]=d+y-z; } } }}int main() { read(n), read(m), read(q); while(isspace(s[1]=read())); for(int i=2; i&lt;=n; ++i) s[i]=read(); while(isspace(t[1]=read())); for(int i=2; i&lt;=m; ++i) t[i]=read(); for(int i=2; i&lt;=n; ++i) sl[i][0]=sl[i-1][0], sl[i][1]=sl[i-1][1], sl[i][s[i-1]=='E']=i-1; for(int i=n; --i;) sr[i][0]=sr[i+1][0], sr[i][1]=sr[i+1][1], sr[i][s[i+1]=='E']=i+1; for(int i=2; i&lt;=m; ++i) tl[i][0]=tl[i-1][0], tl[i][1]=tl[i-1][1], tl[i][t[i-1]=='S']=i-1; for(int i=m; --i;) tr[i][0]=tr[i+1][0], tr[i][1]=tr[i+1][1], tr[i][t[i+1]=='S']=i+1; while(q--){ read(A.first), read(A.second), read(B.first), read(B.second); memset(cnt, 0, sizeof cnt), ans=1e9, extend(0, A, 0, 0), extend(0, A, 0, 1); for(int i=0; i&lt;4; ++i){ for(int j=0; j&lt;cnt[i]; ++j) extend(i+1, f[i][j], dis[i][j], g[i][j]^1); } print(ans==1e9?-1:ans), print('\\n'); } return flush(), 0;}","link":"/atcoder-exawizards2019/"},{"title":"多项式一些基础的操作","text":"多项式乘法 多项式求逆 多项式除法/取模 多项式牛顿迭代法 多项式开根 多项式 $\\ln$ 多项式 $\\exp$ 多项式 $k$ 次幂 多项式多点求值和快速插值 封装的代码可以看挑战多项式 写的时候要注意各种清空问题. 多项式乘法略 时间复杂度$\\mathcal O(n\\log n)$ 1234567891011121314151617181920212223242526const int P = 998244353;inline int Pow(ll x, int y=P-2){ ll ass=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ass=ass*x%P; return ass;}inline int Mod(int x){ return x&lt;P?x:x-P;}inline void NTT(int *f, int g){ for(int i=0, j=0; i&lt;p; ++i){ if(i&gt;j) swap(f[i], f[j]); for(int k=p&gt;&gt;1; (j^=k)&lt;k; k&gt;&gt;=1); } for(int i=1; i&lt;p; i&lt;&lt;=1){ int w0=(g==1?Pow(3, (P-1)/i/2):Pow(Pow(3, (P-1)/i/2))); for(int j=0; j&lt;p; j+=i&lt;&lt;1){ int w=1; for(int k=j; k&lt;j+i; ++k){ int t=(ll)w*f[k+i]%P; f[k+i]=Mod(P+f[k]-t); f[k]=Mod(f[k]+t); w=(ll)w*w0%P; } } } if(g==-1) for(int i=0, I=Pow(p); i&lt;p; ++i) f[i]=(ll)f[i]*I%P;} 多项式求逆给定多项式$A(x)$，求$A^{-1}(x)$满足$$A(x)A^{-1}(x)\\equiv 1\\pmod{x^n}$$ 其中$\\pmod{x^n}$即为舍去次数$\\ge n$的项，只保留$0$到$n-1$次项 考虑倍增，或者直接套下面的牛顿迭代 $n=1$时只有常数项，答案可以直接快速幂求出 假设当前已经求出$\\pmod{x^{\\lceil \\frac{n}{2} \\rceil}}$意义下的$A(x)$的逆元$B_0(x)$，满足$$A(x)B_0(x)\\equiv 1\\pmod{x^{\\lceil \\frac{n}{2} \\rceil}}$$ 需要求$B(x)$满足$$A(x)B(x)\\equiv 1\\pmod{x^n}$$ 两式相减得$$A(x)(B(x)-B_0(x))\\equiv 0\\pmod{x^{\\lceil \\frac{n}{2} \\rceil}}$$ 即$$B(x)-B_0(x)\\equiv0\\pmod{x^{\\lceil \\frac{n}{2} \\rceil}}$$ 平方得$$B^2(x)-2B(x)B_0(x)+B_0^2(x)\\equiv0\\pmod{x^n}$$ 由于一个多项式平方之后，次数$&lt;n$的项至少是由原先一个次数$&lt;\\lceil \\frac{n}{2} \\rceil$的项乘上其他项得到的，所以这个结果的$0$到$n-1$次系数仍然是$0$，可以变成$\\pmod{x^n}$ 同乘$A(x)$得$$B(x)-2B_0(x)+A(x)B_0^2(x)\\equiv0\\pmod{x^n}$$ 即$$B(x)\\equiv B_0(x)(2-A(x)B_0(x))\\pmod{x^n}$$ 时间复杂度$$T(n)=T(\\frac{n}{2})+\\mathcal O(n\\log n)=\\mathcal O(n\\log n)$$ 1234567891011inline void polyinv(int n, int *a, int *b){ if(n==1) return (void)(b[0]=Pow(a[0])); polyinv((n+1)/2, a, b); static int tmp[N]; for(p=1; p&lt;n*2-1; p&lt;&lt;=1); memcpy(tmp, a, n&lt;&lt;2), memset(tmp+n, 0, p-n&lt;&lt;2); NTT(tmp, 1), NTT(b, 1); for(int i=0; i&lt;p; ++i) b[i]=(2-(ll)b[i]*tmp[i]%P+P)*b[i]%P; NTT(b, -1); memset(b+n, 0, p-n&lt;&lt;2);} 多项式除法/取模给定$n-1$次多项式$A(x)$和$m-1$次多项式$B(x)$，求$D(x)\\ R(x)$满足$$A(x)=D(x)B(x)+R(x)$$ 其中$D(x)$最高$n-m$次，$R(x)$次数$&lt;m-1$ 或$$A(x)\\equiv R(x)\\pmod{B(x)}$$ 由于这里有余数$R(x)$难以处理，可以考虑去掉其影响 定义反转操作(将各项系数反转)$$A^R(x)=x^{n-1}A(\\frac{1}{x})=\\sum_{i=0}^{n-1}a_{n-i-1}x^i$$ 把$\\frac{1}{x}$代入原式，再同乘$x^{n-1}$，得到$$x^{n-1}A(\\frac{1}{x})=x^{n-m}D(\\frac{1}{x})x^{m-1}B(\\frac{1}{x})+x^{n-m+1}*x^{m-2}R(\\frac{1}{x})$$ 即$$A^R(x)=D^R(x)B^R(x)+x^{n-m+1}R^R(x)$$ 由于$D^R(x)$也是$n-m$次的，在$\\pmod{x^{n-m+1}}$意义下，得到$$A^R(x)\\equiv D^R(x)B^R(x)\\pmod{x^{n-m+1}}$$ 可以通过多项式求逆得到$D^R(x)$，反转即为$D(x)$，再代入计算$R(x)$ 需要一次求逆和两次乘法 时间复杂度$\\mathcal O(n\\log n)$ 123456789101112131415161718192021inline void polydiv(int n, int m, int *d, int *a, int *b, int *r){ static int A[N], B[N], B1[N]; memset(A, 0, sizeof A), memset(B, 0, sizeof B), memset(B1, 0, sizeof B1); for(int i=0; i&lt;n; ++i) A[i]=a[n-i-1]; for(int i=0; i&lt;m; ++i) B[i]=b[m-i-1]; polyinv(n-m+1, B, B1); for(p=1; p&lt;n*2-m; p&lt;&lt;=1); NTT(A, 1), NTT(B1, 1); for(int i=0; i&lt;p; ++i) d[i]=(ll)A[i]*B1[i]%P; NTT(d, -1), memset(d+n-m+1, 0, p-(n-m+1)&lt;&lt;2); for(int i=0, j=n-m; i&lt;j; ++i, --j) swap(d[i], d[j]); for(p=1; p&lt;n; p&lt;&lt;=1); for(int i=0; i&lt;m; ++i) B[i]=b[i]; for(int i=0; i&lt;n-m+1; ++i) B1[i]=d[i]; memset(B1+n-m+1, 0, p-(n-m+1)&lt;&lt;2); NTT(B, 1), NTT(B1, 1); for(int i=0; i&lt;p; ++i) r[i]=(ll)B[i]*B1[i]%P; NTT(r, -1); for(int i=0; i&lt;n; ++i) r[i]=(P+a[i]-r[i])%P;} 多项式牛顿迭代法这个好像可以用来推很多东西.. 有一个关于多项式$f(x)$的方程$g(f(x))=0$ 假设已经求出了$f(x)$的前$n$项$f_0(x)$ $$f(x)\\equiv f_0(x)\\pmod{x^n}$$ $$g(f_0(x))\\equiv 0\\pmod{x^n}$$ 对$g(f(x))$在$f_0(x)$上泰勒展开 $$g(f(x))=g(f_0(x))+\\frac{g’(f_0(x))}{1!}(f(x)-f_0(x))^1+\\frac{g’’(f_0(x))}{2!}(f(x)-f_0(x))^2+·······$$ 注意到$f(x)-f_0(x)$的前$n$项系数为$0$，于是 $$g(f(x))\\equiv g(f_0(x))+g’(f_0(x))(f(x)-f_0(x))\\equiv 0\\pmod{x^{2n}}$$ 即$$f(x)\\equiv f_0(x)-\\frac{g(f_0(x))}{g’(f_0(x))}\\pmod{x^{2n}}$$ 用这种方法也可以推多项式求逆 多项式开根给定多项式$A(x)$,求$B(x)$满足$$B^2(x)-A(x)\\equiv0\\pmod{x^n}$$ 设$B(x)\\equiv B_0(x)\\pmod{x^n}$，直接代入牛顿迭代 $$\\begin{aligned} B(x)&amp;\\equiv B_0-\\frac{B_0^2(x)-A(x)}{2B_0(x)} \\ &amp;\\equiv\\frac{1}{2}\\left( B_0(x)+\\frac{A(x)}{B_0(x)}\\right)\\pmod{x^{2n}}\\end{aligned}$$ 复杂度$$T(n)=T(\\frac{n}{2})+\\mathcal O(n\\log n)=\\mathcal O(n\\log n)$$ 若常数项不是很优秀，当$n=1$时，还需要计算二次剩余（我不会） 代码中常数项恰好为$1$ 123456789101112inline void polysqrt(int n, int *a, int *b){ if(n==1) return (void)(b[0]=1); polysqrt(n+1&gt;&gt;1, a, b); static int tmp[N], b1[N]; polyinv(n, b, b1); for(p=1; p&lt;n*2-1; p&lt;&lt;=1); memcpy(tmp, a, n&lt;&lt;2), memset(tmp+n, 0, p-n&lt;&lt;2); NTT(tmp, 1), NTT(b, 1), NTT(b1, 1); for(int i=0; i&lt;p; ++i) b[i]=((ll)tmp[i]*b1[i]+b[i])%P*inv2%P; NTT(b, -1); memset(b+n, 0, p-n&lt;&lt;2), memset(b1, 0, p&lt;&lt;2);} 多项式$\\ln$对于一个多项式$A(x)$，求$$\\ln(A(x))\\pmod{x^n}$$ 直接计算 $$\\begin{aligned} &amp;\\ln(A(x)) \\ =&amp;\\int (\\ln(A(x)))’ \\ =&amp;\\int\\frac{A’(x)}{A(x)}\\end{aligned}$$ 其中的求导和积分都是可以$\\mathcal O(n)$完成的 **需要保证$A(x)$常数项为$1$**，否则由于求导后常数项丢失，会出现一些问题 时间复杂度$\\mathcal O(n\\log n)$ 1234567891011inline void polyln(int n, int *a, int *b){ static int tmp[N]; polyinv(n, a, b); for(int i=1; i&lt;n; ++i) tmp[i-1]=(ll)a[i]*i%P; for(p=1; p&lt;n*2-1; p&lt;&lt;=1); NTT(tmp, 1), NTT(b, 1); for(int i=0; i&lt;p; ++i) b[i]=(ll)tmp[i]*b[i]%P; NTT(b, -1); for(int i=n-1; i; --i) b[i]=(ll)b[i-1]*Pow(i)%P; b[0]=0, memset(b+n, 0, p-n&lt;&lt;2);} 多项式$\\exp$对于一个多项式$A(x)$，求$$e^{A(x)}\\pmod{x^n}$$ 设 $$B(x)\\equiv e^{A(x)}\\pmod{x^n}$$ 两边取对数 $$\\begin{aligned}\\Longrightarrow &amp; &amp;\\ln(B(x))&amp;\\equiv A(x)&amp;\\pmod{x^n} \\\\Longrightarrow &amp; &amp;\\ln(B(x))-A(x)&amp;\\equiv 0&amp;\\pmod{x^n}\\end{aligned}$$ 设$B(x)\\equiv B_0(x)\\pmod{x^n}$，得到递推式 $$\\begin{aligned}B(x)&amp;\\equiv B_0(x)-\\frac{\\ln(B(x))-A(x)}{\\frac{1}{B(x)}}&amp;\\pmod{x^{2n}} \\\\Longrightarrow B(x)&amp;\\equiv B_0(x)(1-\\ln(B_0(x))+A(x))&amp;\\pmod{x^{2n}}\\end{aligned}$$ $A(x)$的常数项必须为$0$，$B(x)$常数项必定为$1$ 我不知道为什么 复杂度$$T(n)=T(\\frac{n}{2})+\\mathcal O(n\\log n)=\\mathcal O(n\\log n)$$ 123456789101112void polyexp(int n, int *a, int *b){ if(n==1) return (void)(b[0]=1); polyexp(n+1&gt;&gt;1, a, b); static int tmp[N]; polyln(n, b, tmp); for(int i=0; i&lt;n; ++i) tmp[i]=Mod(!i+P+a[i]-tmp[i]); for(p=1; p&lt;n*2-1; p&lt;&lt;=1); NTT(tmp, 1), NTT(b, 1); for(int i=0; i&lt;p; ++i) b[i]=(ll)b[i]*tmp[i]%P; NTT(b, -1); memset(b+n, 0, p-n&lt;&lt;2), memset(tmp, 0, p&lt;&lt;2);} 多项式$k$次幂给定多项式$f(x)$和正整数$k$，求$f^k(x)$的前$n$项系数 直接快速幂，复杂度$\\mathcal O(n\\log n\\log k)$ 当$f(x)$的常数项为$1$时，有$$f^k(x)=\\exp(k\\ ln(f(x)))$$ 复杂度为$\\mathcal O(n\\log n)$ 若$f(x)$的常数项不为1，设$f(x)$最低次项为$ax^d$，则$$f^k(x)=a^kx^{kd}\\left(\\frac{f(x)}{ax^d}\\right)^k$$ 可以用上面的方法计算 多点求值和快速插值参考多项式多点求值和快速插值学习笔记","link":"/basic-polynomial-operations/"},{"title":"伯努利数","text":"Bernoulli number 一些性质Wikipedia 说， $$\\begin{aligned}B^-_0=1 \\\\sum {j=0}^{m}\\binom{m+1}{j}B^-{j}=0\\end{aligned}$$ 通过上式可以计算伯努利数，计算得到的是第一伯努利数，记做 $B^-_n$，与第二伯努利数 $B^+_n$ 仅有的区别是 $$\\begin{aligned}B^-_1=-\\frac{1}{2} \\B^+_1=+\\frac{1}{2}\\end{aligned}$$ 通过转化可以得到 $${\\frac {x}{e^{x}-1}}=\\sum {n=0}^{\\infty }B^-{n}{\\frac {x^{n}}{n!}}$$ 可以用多项式求逆在 $O(n\\log n)$ 的复杂度内求出伯努利数的前 $n$ 项。 第二伯努利数满足 $$\\begin{aligned}S_{m}(n)&amp;=\\sum _{k=1}^{n}k^{m}=1^{m}+2^{m}+\\cdots +{n}^{m} \\&amp;= \\frac {1}{m+1}\\sum {k=0}^{m}\\binom{m+1}{k} B{k}^{+}n^{m+1-k}\\end{aligned}$$ 可以用来求自然数幂和。 例题Luogu P3711 仓鼠的数学题 题意设关于 $x$ 的 $k+1$ 次多项式 $S_k(x)=\\sum\\limits_{i=0}^x i^k$。 给出 $n+1$ 个数 $a_0,a_1,\\dotsc,a_n$，求 $\\sum\\limits_{k=0}^n a_k S_k(x)$ 的各项系数。 做法把上面的式子代入有 $$\\begin{aligned}&amp; \\sum_{k=1}^n a_kS_{k}(x) \\= &amp; \\sum_{k=1}^n \\frac {a_k}{k+1}\\sum {i=0}^{k}\\binom{k+1}{i} B{i}^{+}x^{k+1-i} \\= &amp; \\sum_{k=1}^n \\frac {a_k}{k+1}\\sum {i=1}^{k+1}\\binom{k+1}{i} B{k+1-i}^{+}x^i \\= &amp; \\sum_{k=1}^n a_k k! \\sum {i=1}^{k+1} \\frac {B{k+1-i}^{+}x^{i}}{i!(k+1-i)!} \\= &amp; \\sum {i=1}^{n+1} \\frac{x^i}{i!} \\sum{k=i-1}^n a_k k! \\frac {B_{k+1-i}^{+}}{(k+1-i)!} \\\\end{aligned}$$ 右边的部分可以求出伯努利数后卷积，总复杂度 $O(n\\log n)$。 注意通过 $${\\frac {x}{e^{x}-1}}=\\sum {n=0}^{\\infty }B^-{n}{\\frac {x^{n}}{n!}}$$ 求出来的是 $B^-_n$，后面计算需要改动 $B_1$ 的值。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 250005, M = 1&lt;&lt;19, P = 998244353;int n, fac[N], ifac[N], w[M];unsigned ll F[M];inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}inline int Calc(int x){ int ans=1; while(ans&lt;=x) ans&lt;&lt;=1; return ans;}inline void DFT(vector&lt;int&gt; &amp;f, int n){ for(int i=0, j=0; i&lt;n; ++i){ F[i]=f[j]; for(int k=n&gt;&gt;1; (j^=k)&lt;k; k&gt;&gt;=1); } for(int i=1; i&lt;n; i&lt;&lt;=1) for(int j=0; j&lt;n; j+=i&lt;&lt;1) for(int k=j; k&lt;j+i; ++k){ int t=F[k+i]*w[i+k-j]%P; F[k+i]=F[k]+P-t, F[k]+=t; } for(int i=0; i&lt;n; ++i) f[i]=F[i]%P;}inline void IDFT(vector&lt;int&gt; &amp;f, int n){ reverse(f.begin()+1, f.end()), DFT(f, n); for(int i=0, I=Pow(n); i&lt;n; ++i) f[i]=(ll)f[i]*I%P;}inline vector&lt;int&gt; operator *(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b){ int n=Calc(a.size()+b.size()-2); vector&lt;int&gt; A=a, B=b; A.resize(n), B.resize(n), DFT(A, n), DFT(B, n); for(int i=0; i&lt;n; ++i) A[i]=(ll)A[i]*B[i]%P; IDFT(A, n); return A.resize(a.size()+b.size()-1), A;}vector&lt;int&gt; PolyInv(const vector&lt;int&gt; &amp;a, int n=-1){ if(n==-1) n=a.size(); if(n==1) return {Pow(a[0])}; vector&lt;int&gt; ans=PolyInv(a, (n+1)&gt;&gt;1), A(a.begin(), a.begin()+n); int m=Calc(n*2-1); ans.resize(m), A.resize(m), DFT(ans, m), DFT(A, m); for(int i=0; i&lt;m; ++i) ans[i]=(2+(ll)(P-A[i])*ans[i])%P*ans[i]%P; IDFT(ans, m); return ans.resize(n), ans;}int main() { for(int i=1; i&lt;M; i&lt;&lt;=1){ w[i]=1, w[i+1]=Pow(3, (P-1)/i/2); for(int j=2; j&lt;i; ++j) w[i+j]=(ll)w[i+j-1]*w[i+1]%P; } read(n); vector&lt;int&gt; a(n+1), b(n+1); fac[0]=1; for(int i=1; i&lt;=n+1; ++i) fac[i]=(ll)fac[i-1]*i%P; ifac[n+1]=Pow(fac[n+1]); for(int i=n+1; i; --i) ifac[i-1]=(ll)ifac[i]*i%P; for(int i=0; i&lt;=n; ++i) read(a[i]), a[i]=(ll)a[i]*fac[i]%P; print(a[0]); for(int i=0; i&lt;=n; ++i) b[i]=ifac[i+1]; b=PolyInv(b), b[1]=P-b[1]; reverse(b.begin(), b.end()); a=a*b; for(int i=1; i&lt;=n+1; ++i) print(' '), print((int)((ll)a[i+n-1]*ifac[i]%P)); return flush(), 0;}","link":"/bernoulli-number/"},{"title":"「BZOJ 1921」「Ctsc2010」珠宝商","text":"BZOJ 1921 题意给一棵 $n$ 个点的树和长度为 $m$ 的特征串，树的每个节点有一个字符。 求随机两个点形成有向路径上构成的串在特征串里出现次数的期望 仅含小写字母，$n,m\\le 5*10^4$ 分析首先可以发现两种算法 暴力处理 对”特征串”建 SAM 枚举路径的一个端点， dfs 另一个端点，同时维护在 SAM 上的位置. 每到一个位置会有 SAM 上对应节点的 right 集合大小的贡献 复杂度 $\\mathcal O({\\rm size}^2)$ 处理经过一个点的所有路径 设这个点是 $u$ ，字符为 $a[u]$ 需要建出正反特征串的后缀树 考虑从点 $u$ 出发的所有路径（$a[u]$ 为字符串的开头），统计出以特征串的每一位为起始的这些串的数量 同理将这些串翻转（$a[u]$为串的最后一位），统计出在特征串每一位结束的串的数量 对应位上两组串数量的乘积的和即为贡献，因为某正串在一位起始，某反串在这位结束，即可拼出一个路径 由于 dfs 时正串是每次在末尾加字符维护在特征串中起始位置，反串是每次开头加字符维护结束位置，将特征串和路径串翻转后即为同一个问题，我们只考虑 push_front 维护结束位置 后缀自动机的转移只能支持末尾插入，于是需要利用后缀树 后缀树上一条边会对应原串中的一段区间 转移时需要注意从上往下走了不满一条边的情况，此时大概需要走到儿子处，注意判无转移时无解 每次在节点上打标记，最后全部下放到叶子处 统计每个位置的出现次数 复杂度$\\mathcal O({\\rm size}+m)$ 实现然后使用点分治，若分治的大小$size&gt;\\sqrt{m}$使用方法2， 否则暴力做方法1 这里需要注意同一子树的去重 在去重的时候应使用对应的方法保证复杂度 易知复杂度为$\\mathcal O((n+m)\\sqrt{m})$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long long#define rep(i,x,y) for(int i=(x);i&lt;=(y);++i)#define travel(i,x) for(int i=h[x];i;i=pre[i])inline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) { if (c == '-') iosig = true; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x + (x &lt;&lt; 2)) &lt;&lt; 1) + (c ^ '0'); if (iosig) x = -x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh = obuf;inline void print(char c) { if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf; *ooh++ = c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x == 0) print('0'); else { if (x &lt; 0) print('-'), x = -x; for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48; while (cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 50005;int n, m, num, tot1[N], tot2[N], h[N], pre[N&lt;&lt;1], e[N&lt;&lt;1];bool vis[N];char a[N], s[N];inline void add(int x, int y){ e[++num]=y, pre[num]=h[x], h[x]=num;}struct sam{ int last, cnt, b[N], str[N], t[N&lt;&lt;1], lazy[N&lt;&lt;1], q[N&lt;&lt;1], siz[N&lt;&lt;1], len[N&lt;&lt;1], fa[N&lt;&lt;1], ch[N&lt;&lt;1][26], son[N&lt;&lt;1][26]; bool isl[N&lt;&lt;1]; inline sam(){ last=cnt=1;} inline void ins(int c){ int p=last, np=++cnt; last=np, str[len[np]=len[p]+1]=c, t[np]=len[np]; while(p &amp;&amp; !ch[p][c]) ch[p][c]=np, p=fa[p]; if(!p) fa[np]=1; else{ int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else{ int nq=++cnt; len[nq]=len[p]+1, memcpy(ch[nq], ch[q], sizeof ch[0]); t[nq]=t[q], fa[nq]=fa[q], fa[q]=fa[np]=nq; while(ch[p][c]==q) ch[p][c]=nq, p=fa[p]; } } siz[np]=isl[np]=1; } inline void init(){ rep(i, 1, cnt) ++b[len[i]]; rep(i, 1, m) b[i]+=b[i-1]; rep(i, 1, cnt) q[b[len[i]]--]=i; for(int i=cnt; i&gt;1; --i) son[fa[q[i]]][str[t[q[i]]-len[fa[q[i]]]]]=q[i], siz[fa[q[i]]]+=siz[q[i]]; } inline void trans(int &amp;p, int c){ p=ch[p][c];} void dfs5(int u, int fa, int p, int l){ if(!p) return; if(l==len[p]) p=son[p][a[u]]; else if(str[t[p]-l]!=a[u]) p=0; if(!p) return; ++lazy[p]; travel(i, u) if(e[i]!=fa &amp;&amp; !vis[e[i]]) dfs5(e[i], u, p, l+1); } inline void work(int *tot){ rep(i, 2, cnt) lazy[q[i]]+=lazy[fa[q[i]]]; rep(i, 1, cnt) if(isl[i]) tot[len[i]]=lazy[i]; memset(lazy, 0, sizeof lazy); }}sam1, sam2;ll ans;int root, ctr, Siz, mn, top, lim, siz[N], stk[N];void dfs1(int u, int fa=0){ siz[u]=1; int mx=0; travel(i, u) if(!vis[e[i]] &amp;&amp; e[i]!=fa) dfs1(e[i], u), siz[u]+=siz[e[i]], mx=max(mx, siz[e[i]]); mx=max(mx, Siz-siz[u]); if(mx&lt;mn) mn=mx, ctr=u;}inline int getctr(int u, int size){ return Siz=mn=size, dfs1(u), ctr;}void dfs3(int u, int p, int W, int fa=0){ sam1.trans(p, a[u]); if(p){ ans+=W*sam1.siz[p]; travel(i, u) if(!vis[e[i]] &amp;&amp; e[i]!=fa) dfs3(e[i], p, W, u); }}void dfs2(int u, int fa=0){ stk[++top]=a[u]; int p=1; for(int i=top; i; --i) sam1.trans(p, stk[i]); dfs3(root, p, -1); travel(i, u) if(e[i]!=fa &amp;&amp; !vis[e[i]]) dfs2(e[i], u); --top;}void dfs4(int u, int fa=0){ dfs3(u, 1, 1); travel(i, u) if(!vis[e[i]] &amp;&amp; e[i]!=fa) dfs4(e[i], u);}void solve(int u, int fa=0, int v=0){ int size=Siz; if(size&lt;=lim){ if(fa){ stk[top=1]=a[fa]; root=v, dfs2(v); } dfs4(u); } else{ if(fa){ sam1.dfs5(v, fa, sam1.son[1][a[fa]], 1), sam2.dfs5(v, fa, sam2.son[1][a[fa]], 1); sam1.work(tot1), sam2.work(tot2); rep(i, 1, m) ans-=tot1[i]*tot2[m-i+1]; } sam1.dfs5(u, 0, 1, 0), sam2.dfs5(u, 0, 1, 0); sam1.work(tot1), sam2.work(tot2); rep(i, 1, m) ans+=tot1[i]*tot2[m-i+1]; vis[u]=1; travel(i, u) if(!vis[e[i]]) solve(getctr(e[i], siz[e[i]]&lt;siz[u]?siz[e[i]]:size-siz[u]), u, e[i]); }}int main() { read(n), read(m); lim=sqrt(m); rep(i, 2, n){ static int x, y; read(x), read(y); add(x, y), add(y, x); } while(isspace(a[1]=read())); rep(i, 2, n) a[i]=read(); rep(i, 1, n) a[i]-='a'; while(isspace(s[1]=read())); rep(i, 2, m) s[i]=read(); rep(i, 1, m) sam1.ins(s[i]-='a'); for(int i=m; i; --i) sam2.ins(s[i]); sam1.init(), sam2.init(); solve(getctr(1, n)); return printf(&quot;%lld&quot;, ans), 0;}","link":"/bzoj-1921/"},{"title":"「AtCoder」Card Collector","text":"好久没更了，水平下降严重 = = AtCoder Japanese Student Championship 2019 Qualification E 题意有 $n$ 个写着数字的卡片放在 $h\\times w$ 的网格上，第一次你可以在每一行选择至多一张卡片取走，第二次在每一列选择至多一张卡片取走，要求最大化取走卡片上的数字总和。 同一个位置可能有多个卡片。 $n,h,w\\le 10^5$ 做法个人做法可能不是很简洁 假设选择了若干卡片，判断能否分配每张卡片是在第几次取走。 我们可以构出一张二分图，左边是选择的卡片，右边是行和列，卡片向对应的行和列连边，因此左侧每个点的度都为 $2$，卡片集合是可行的当且仅当最大匹配大小是卡片数。 右侧有一些度数为 $1$ 的点，我们可以不断把这些点干掉，直到右边所有点的度数至少为 $2$。 可以发现一个条件是右侧点数不少于左侧点数，而在干掉无用的点之后右侧点数不多于左侧点数，点数相等当且仅当所有点度数为 $2$。 因此整个图是若干个环，加上之前忽略的点之后是环套树森林，即卡片集合合法当且仅当按照上述方法构出的图是环套树森林。 类似 Kruskal 地用并查集维护每个联通块即可。 事实上最后不需要左侧代表卡片的点，每个点可以变成一条边。 复杂度 $\\mathcal O(n \\log n)$ 代码12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 100005, M = 200005;ll ans;int n, h, w, f[M];bool g[M];struct wish{ int r, c, a; bool operator&lt;(const wish &amp;r)const{ return a&gt;r.a;}} a[N];int find(int x){ return f[x]==x?x:f[x]=find(f[x]);}bool combine(int x, int y){ x=find(x), y=find(y); if(x==y) if(g[x]) return 0; else return g[x]=1, 1; else if(g[x]+g[y]&gt;1) return 0; else return f[x]=y, g[y]|=g[x], 1;}int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;h, &amp;w); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d%d%d&quot;, &amp;a[i].r, &amp;a[i].c, &amp;a[i].a); sort(a+1, a+n+1); for(int i=1; i&lt;=h+w; ++i) f[i]=i; for(int i=1; i&lt;=n; ++i) if(combine(a[i].r, h+a[i].c)) ans+=a[i].a; printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/atcoder-jsc2019qual-e/"},{"title":"「BZOJ 1023」「SHOI2008」cactus仙人掌图","text":"BZOJ 1023 题意你有一棵$n$个点的仙人掌，边权为$1$ 定义两点的距离是最短路的长度 定义仙人掌的直径是距离最远的两点的距离 求直径 $n\\le5*10^4$ 分析建圆方树，在LCA处处理最长的路径 令$f_i$表示$i$子树中的点到$i$的最大距离 在圆点处直接按照树的方式处理，找出儿子中$f$的最大和次大值 为了不改变圆点的处理方式，对于方点$u$，$f_u$定义为子树中到父亲节点的最大距离$-1$，这直接考虑环上的两种路径即可 主要是LCA是方点的情况，把环复制两遍，用单调队列维护一下$\\le\\frac{1}{2}$环长的最优转移。 复杂度$\\mathcal O(n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 50005, M = 100005;int p, top, cnt, n, m, ans, num=1, h[N], dfn[N], low[N], stk[N], f[N&lt;&lt;1], q[N&lt;&lt;1], g[N&lt;&lt;1], e[M&lt;&lt;1], pre[M&lt;&lt;1];vector&lt;int&gt; E[N&lt;&lt;1];inline void add(int x, int y){ e[++num]=y, pre[num]=h[x], h[x]=num;}void tarjan(int u, int fa=0){ dfn[u]=low[u]=++cnt; stk[++top]=u; for(int i=h[u]; i; i=pre[i]) if(i!=fa) if(!dfn[e[i]]){ tarjan(e[i], i^1), low[u]=min(low[u], low[e[i]]); if(low[e[i]]==dfn[e[i]]) E[u].push_back(e[i]); } else if(dfn[e[i]]&lt;dfn[u]){ low[u]=min(low[u], dfn[e[i]]); E[e[i]].push_back(++p); for(int j=top; stk[j]!=e[i]; --j) E[p].push_back(stk[j]); } --top;}void dfs(int u){ for(int v:E[u]) dfs(v); if(u&lt;=n){ int x=0; for(int v:E[u]) if(f[v]+1&gt;f[u]) x=f[u], f[u]=f[v]+1; else if(f[v]+1&gt;x) x=f[v]+1; ans=max(ans, f[u]+x); } else{ int siz=E[u].size()+1, x=0, h=1, t=0; for(int v:E[u]){ ++x, f[u]=max(f[u], f[v]+min(x, siz-x)); g[x]=f[v]; while(h&lt;=t &amp;&amp; x-q[h]&gt;siz/2) ++h; if(h&lt;=t) ans=max(ans, x-q[h]+g[x]+g[q[h]]); while(h&lt;=t &amp;&amp; g[x]-x&gt;=g[q[t]]-q[t]) --t; q[++t]=x; } ++x; for(int i=1; i&lt;siz; ++i){ ++x; g[x]=g[i]; while(h&lt;=t &amp;&amp; x-q[h]&gt;siz/2) ++h; if(h&lt;=t) ans=max(ans, x-q[h]+g[x]+g[q[h]]); while(h&lt;=t &amp;&amp; g[x]-x&gt;=g[q[t]]-q[t]) --t; q[++t]=x; } --f[u]; }}int main() { read(n), read(m), p=n; while(m--){ static int k, x, y; read(k), read(x); for(int i=1; i&lt;k; ++i) read(y), add(x, y), add(y, x), x=y; } tarjan(1), dfs(1); return printf(&quot;%d\\n&quot;, ans), 0;}","link":"/bzoj-1023/"},{"title":"「BZOJ 2125」最短路","text":"BZOJ 2125 题意给定 $n$个 点仙人掌（每条边只在不超过1个简单环中的无向连通图），$q$ 次询问两点间最短路 边带权 $n,q\\le 10000$ 分析建圆方树 两个圆点之间连原长的边 父亲为圆点，儿子为方点的边权为 $0$ 父亲为方点，儿子为圆点的边权为，圆点到这个简单环的根（深度最小）的最短路（两种方向） 对于询问的两点的 lca 进行讨论 lca 是圆点，树上的距离即为原图最短路 lca 是方点，把两点向上跳到 lca 的儿子处，求出环上这两个儿子的最短路（两种方向），再加上到跳过的距离，就是答案 这里用倍增实现 时间复杂度 $\\mathcal O((n+q)\\log n)$ 代码需要 -std=c++11 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;vector&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) { if (c == '-') iosig = true; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x + (x &lt;&lt; 2)) &lt;&lt; 1) + (c ^ '0'); if (iosig) x = -x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh = obuf;inline void print(char c) { if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf; *ooh++ = c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x == 0) print('0'); else { if (x &lt; 0) print('-'), x = -x; for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48; while (cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 10005;int n, m, num=1, cnt, top, p, q, dep[N], stk[N], h[N], dfn[N], low[N], d[N&lt;&lt;1], siz[N&lt;&lt;1], dis[N&lt;&lt;1], e[N&lt;&lt;2], w[N&lt;&lt;2], pre[N&lt;&lt;2], f[15][N&lt;&lt;1];vector&lt;pair&lt;int,int&gt;&gt; E[N&lt;&lt;1];inline void add(int x, int y, int z){ e[++num]=y, w[num]=z, pre[num]=h[x], h[x]=num;}void tarjan(int u, int fa=0){ dfn[u]=low[u]=++cnt; stk[++top]=u; for(int i=h[u]; i; i=pre[i]) if(i!=fa) if(!dfn[e[i]]){ dep[e[i]]=dep[u]+w[i], tarjan(e[i], i^1); low[u]=min(low[u], low[e[i]]); if(dfn[e[i]]==low[e[i]]) f[0][e[i]]=u, E[u].push_back(make_pair(e[i], w[i])); } else if(dfn[e[i]]&lt;dfn[u]){ low[u]=min(low[u], dfn[e[i]]); siz[++n]=dep[u]-dep[e[i]]+w[i]; f[0][n]=e[i], E[e[i]].push_back(make_pair(n, 0)); for(int j=top, v; (v=stk[j])!=e[i]; --j) f[0][v]=n, E[n].push_back(make_pair(v, dep[v]-dep[e[i]])); } --top;}void dfs(int u){ if(f[0][u]&gt;p) dis[u]=min(dis[u], siz[f[0][u]]+dis[f[0][u]]*2-dis[u]); for(auto i:E[u]) dis[i.first]=dis[u]+i.second, d[i.first]=d[u]+1, dfs(i.first);}inline int LCA(int x, int y, int &amp;a, int &amp;b){ if(d[x]&lt;d[y]) swap(x, y); int t=d[x]-d[y]; for(int i=14; ~i; --i) if(t&gt;&gt;i&amp;1) x=f[i][x]; if(x==y) return x; for(int i=14; ~i; --i) if(f[i][x]!=f[i][y]) x=f[i][x], y=f[i][y]; return a=x, b=y, f[0][x];}int main() { read(n), read(m), read(q), p=n; for(int i=1; i&lt;=m; ++i){ static int x, y, z; read(x), read(y), read(z); add(x, y, z), add(y, x, z); } tarjan(1), dfs(1); for(int i=1; i&lt;=14; ++i) for(int j=1; j&lt;=n; ++j) f[i][j]=f[i-1][f[i-1][j]]; while(q--){ static int x, y, lca, a, b; read(x), read(y), lca=LCA(x, y, a, b); if(lca&lt;=p) print(dis[x]+dis[y]-dis[lca]*2); else{ int tmp=abs(dep[a]-dep[b]); print(dis[x]+dis[y]-dis[a]-dis[b]+min(tmp, siz[lca]-tmp)); } print('\\n'); } return flush(), 0;}","link":"/bzoj-2125/"},{"title":"乱做题记录","text":"写题解好慢啊 就记一下做的题吧 2018Dec.6 Codeforces 453E. Little Pony and Lord Tirek 小清新简单数据结构 Codeforces 979E. Kuro and Topological Parity 普及组dp比小清新简单数据结构难写多了 7 Luogu P4482 [BJWC2018]Border 的四种求法 小清新字符串和数据结构，调了好久. Luogu P3793 由乃救爷爷 卡常题，不评价 9 Luogu P3791 普通数学题 简单数学题，没看懂其他人的做法 Luogu P3790 文艺数学题 文艺 12 Luogu P3601 签到题 签到 LOJ #2541. 「PKUWC2018」猎人杀 想到第一步就简单了 Luogu P3604 美好的每一天 简单莫队，时间复杂度直接算比标算小，事实上慢很多 Luogu P3602 Koishi Loves Segments 傻逼贪心 Luogu P3598 Koishi Loves Number Theory 简单的结论，但是在题目给的范围内好像能叉掉标算？ LOJ #6220. sum 脑子是个好东西，可惜我没有 Luogu P4980 【模板】Polya定理 Pólya enumeration theorem 14 LOJ #2878. 「JOISC 2014 Day2」邮戳拉力赛 短dp Codeforces 1076G. Array Game 清真数据结构和博弈 17 Codeforces Gym 100959E 被考试虐死了，来休闲一下 Codeforces Gym 100959H 简单容斥 21 Luogu P3599 Koishi Loves Construction 不会构造 打表找个规律就好了 23 Luogu P3600 随机数生成器 小清新期望题 27 Luogu P3768 简单的数学题 怎么就我一个 Min_25 筛，题解全是杜教筛，反正跑得比大多数人快就是了 LOJ #2836. 「JOISC 2018 Day 2」最差记者 3 傻逼题 28 LOJ #6253. 「CodePlus 2017 11 月赛」Yazid 的新生舞会 $\\log$ 越多越快，式子推错好多次要死了 LOJ #6487. 基础 FFT 练习题 FFT 好题！ 2019Jan.2 Codeforces 1051G. Distinctification 简单数据结构 10 LOJ #6142. 「2017 山东三轮集训 Day6」A 不会推的数学题，OEIS A119358 Luogu P4721 【模板】分治 FFT 推个求逆拉个板就 rank 1 了 Luogu P4389 付公主的背包 LOJ #556. 「Antileaf’s Round」咱们去烧菜吧 的简化版，推推就好了 Codeforces 1054E. Chips Puzzle 构造，可以很好写也可以很难写 18 UOJ #182. 【UR #12】a^-1 + b problem 不会推 20 UOJ #310. 【UNR #2】黎明前的巧克力 一开始想错 FWT 在干什么了. 测了若干次 fread 比 mmap 快，大概姿势不对 21 LOJ #2554. 「CTSC2018」青蕈领主 “也许，我的生命也已经如同风中残烛了吧。” Feb.12 Luogu P3784 [SDOI2017]遗忘的集合 在 Luogu 上过了但是 LOJ 上 90 分，在 AC Union 上 50 分（逃 本机和 UOJ 自测能过 21 LOJ #2538. 「PKUWC2018」Slay the Spire 写了这么久，没救了 23 LOJ #2537. 「PKUWC2018」Minimax 合并之后没维护总和 = = 24 LOJ #2540. 「PKUWC2018」随机算法 脑子是个好东西 Codeforces 1117G. Recursive Queries 不知道怎么就跑得最快了 = = 25 Codeforces 1117F. Crisp String 脑子是个好东西 Codeforces 1107F. Vasya and Endless Credits 难度 2700 的普及组 dp，场上 10 人过，$\\mathcal O(n^2)$ 放了 500 LOJ #2865. 「IOI2018」狼人 好多测试点，卡评测好爽 28 Codeforces 700D. Huffman Coding on Segment 暴力 Mar.1 Codeforces 1110F. Nearest Leaf 题解这个东西以前bb过= = 现在都不会了 Codeforces 1129E. Legendary Tree 脑子是个好东西 Codeforces 914F. Substrings in a String 两种暴力五五开 6 Codeforces 1086E. Beautiful Matrix 细节题 Codeforces 1090J. Two Prefixes 字符串好题 7 UOJ #184. 【ZJOI2016】旅行者 一遍过 8 LOJ #6433. 「PKUSC2018」最大前缀和 状压大难了 LOJ #6436. 「PKUSC2018」神仙的游戏 naive 了 11 LOJ #152. 乘法逆元 2 听说是板子就直接看题解了 12 UOJ #185. 【ZJOI2016】小星星 不会做，丧心病狂卡了半天代码长度卡到 rk1 了= = 13 UOJ #218. 【UNR #1】火车管理 不会分析空间常数= = 数组尽量开大就过了 14 UOJ #195. 【ZJOI2016】大♂森林 别人几年前就秒了，我现在还不会 18 Codeforces 815E. Karen and Neighborhood 九条可怜 20 UOJ #328. 【UTR #3】量子破碎 官方题解看不懂 = = 头发都要掉光了 25 BZOJ 4657: tower 省选前练练手，一般的 sap 还是会敲的 26 LOJ #102. 最小费用流 一遍过了，希望明天运气好一点. 27 LOJ #2250. 「ZJOI2017」仙人掌 退役前再鏼点题，可能，可能也不是很难 28 LOJ #6087. 毒瘤题 LOJ #6232. 毒瘤题加强版 LOJ #6537. 毒瘤题加强版再加强版 一次三道毒瘤题 UOJ #75. 【UR #6】智商锁 没有智商了 Codeforces 1110G. Tree-Tac-Toe 随便讨论一下就好了 29 Codeforces 280C. Game on Tree 没有脑子 Codeforces 280D. k-Maximum Subsequence Sum 小清新数据结构，线段树少记点东西就跑到最快了= = Codeforces 815C. Karen and Supermarket 压一压代码就最短了= = Codeforces 815D. Karen and Cards 模拟赛考过= = 样例都没改，贺来就 A 了 Codeforces 914H. Ember and Storm’s Tree Game 分析一堆性质= = 31 Codeforces 914E. Palindromes in a Tree 脑抽写了边分，写出来一坨 * 还是错的 还是点分好 = = Apr.1 Codeforces 1090F. How to Learn You Score 拆成小段分开做= = 这种解方程的题小段比大段好做 另外，今天是愚人节诶 Codeforces 1137F. Matches Are Not a Child’s Play LCT 清新题 3 Codeforces 1054F. Electric Scheme 输出方案真恶心 11 LOJ #559. 「LibreOJ Round #9」ZQC 的迷宫 迷宫 = = 13 BZOJ 4228: Tibbar的后花园 听说多项式 exp 不能跑 $10^6$ 18 BZOJ 3601: 一个人的数论 脑子和数学 19 Codeforces 1060F. Shrinking Tree 脑子和 dp 29 Codeforces 1155F. Delivery Oligopoly 简单状压 现在懒得做题也懒得更了 = = 这里就不更了吧 ..","link":"/aimless-problem-solving-record/"},{"title":"「BZOJ 2639」 矩形计算","text":"BZOJ 2639 题意给出一个$n$行$m$列的矩阵，有$q$次询问，每次指定一个子矩阵，询问每种数字在这个子矩阵中出现次数的平方和 $n,m\\le200,q\\le10^5$ 分析把矩阵的$n$个行分成$\\lfloor\\sqrt{n}\\rfloor$大小的块，$m$个列分成$\\lfloor\\sqrt{m}\\rfloor$大小的块。 $n,m$同阶，共有$\\mathcal O(n)$个块。 顺序遍历每个块，按照次序定义优先级(代码中是蛇形顺序) 把询问按照左上端点所在块的优先级为第一关键字，右下端点所在块的优先级为第二关键字排序。 开桶维护每个数字出现次数。 每次暴力转移即可 复杂度的一个上界是$\\mathcal O(n^3\\sqrt{n}+qn\\sqrt{n})$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) { if (c == '-') iosig = true; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x + (x &lt;&lt; 2)) &lt;&lt; 1) + (c ^ '0'); if (iosig) x = -x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh = obuf;inline void print(char c) { if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf; *ooh++ = c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x == 0) print('0'); else { if (x &lt; 0) print('-'), x = -x; for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48; while (cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 202, M = 40005, Q = 100005, K = 16;int n, m, q, cnt, id, sn, sm, x, y, xx, yy, ans, b[K][K], a[N][N], rk[N][N], d[M], Ans[Q];pair&lt;int,int*&gt; p[M];struct query{ int x, y, xx, yy, id; inline void input(){ read(x), read(y), read(xx), read(yy); if(x&gt;xx) swap(x, xx); if(y&gt;yy) swap(y, yy); } inline bool operator &lt;(const query &amp;rhs)const{ return rk[x][y]!=rk[rhs.x][rhs.y]?rk[x][y]&lt;rk[rhs.x][rhs.y]:rk[xx][yy]&lt;rk[rhs.xx][rhs.yy];}} s[Q];void insl(int x){ for(int i=y; i&lt;=yy; ++i) ans+=2*d[a[x][i]]+++1;}void dell(int x){ for(int i=y; i&lt;=yy; ++i) ans-=2*d[a[x][i]]---1;}void insc(int y){ for(int i=x; i&lt;=xx; ++i) ans+=2*d[a[i][y]]+++1;}void delc(int y){ for(int i=x; i&lt;=xx; ++i) ans-=2*d[a[i][y]]---1;}int main() { read(n), read(m); for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=m; ++j) read(a[i][j]), p[++cnt]=make_pair(a[i][j], &amp;a[i][j]); sort(p+1, p+cnt+1); for(int i=1; i&lt;=cnt; ++i) *(p[i].second)=(p[i].first==p[i-1].first?id:++id); sn=sqrt(n), sm=sqrt(m), id=0; for(int i=1; i&lt;=(n-1)/sn+1; ++i){ if(i&amp;1) for(int j=1; j&lt;=(m-1)/sm+1; ++j) b[i][j]=++id; else for(int j=(m-1)/sm+1; j; --j) b[i][j]=++id; } for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=m; ++j) rk[i][j]=b[(i-1)/sn+1][(j-1)/sm+1]; read(q); for(int i=1; i&lt;=q; ++i) s[i].input(), s[i].id=i; sort(s+1, s+q+1); x=1, y=1, xx=0, yy=0; for(int i=1; i&lt;=q; ++i){ while(x&gt;s[i].x) insl(--x); while(xx&lt;s[i].xx) insl(++xx); while(y&gt;s[i].y) insc(--y); while(yy&lt;s[i].yy) insc(++yy); while(x&lt;s[i].x) dell(x++); while(xx&gt;s[i].xx) dell(xx--); while(y&lt;s[i].y) delc(y++); while(yy&gt;s[i].yy) delc(yy--); Ans[s[i].id]=ans; } for(int i=1; i&lt;=q; ++i) print(Ans[i]), print('\\n'); return flush(), 0;}","link":"/bzoj-2639/"},{"title":"「BZOJ 4316」小C的独立集","text":"BZOJ 4316 题意你有一棵边仙人掌，求最大点独立集 $n\\le510^4,m\\le610^4$ 分析考虑树上的情形，令$f[i][0/1]$表示第i个点不选/选时，以i为根的子树的最大点独立集 $$\\begin{align}f[i][0]&amp;=\\sum_{v\\in son_i}max(f[v][0],f[v][1])\\f[i][1]&amp;=1+\\sum_{v\\in son_i}f[v][0]\\end{align}$$ 对仙人掌建圆方树，在圆点处如上转移。 在处理方点$u$时，为了使圆点转移不变，重新定义$f[u][0/1]$表示$u$的父亲（环里深度最小的点）选/不选时，以$u$为根的子树的最大点独立集。 暴力讨论$u$的父亲选/不选，环上dp即可 复杂度$\\mathcal O(n)$ 代码需要-std=c++11 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) { if (c == '-') iosig = true; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x + (x &lt;&lt; 2)) &lt;&lt; 1) + (c ^ '0'); if (iosig) x = -x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh = obuf;inline void print(char c) { if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf; *ooh++ = c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x == 0) print('0'); else { if (x &lt; 0) print('-'), x = -x; for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48; while (cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 50005, M = 60005;int n, m, num=1, cnt, top, p, dfn[N], low[N], stk[N], h[N], f[N][2], e[M&lt;&lt;1], pre[M&lt;&lt;1];vector&lt;int&gt; E[N&lt;&lt;1];inline void add(int x, int y){ e[++num]=y, pre[num]=h[x], h[x]=num;}void tarjan(int u, int fa=0){ dfn[u]=low[u]=++cnt; stk[++top]=u; for(int i=h[u]; i; i=pre[i]) if(i!=fa) if(!dfn[e[i]]){ tarjan(e[i], i^1), low[u]=min(low[u], low[e[i]]); if(dfn[e[i]]==low[e[i]]) E[u].push_back(e[i]); } else if(dfn[e[i]]&lt;dfn[u]){ low[u]=min(low[u], dfn[e[i]]); E[e[i]].push_back(++p); for(int j=top; stk[j]!=e[i]; --j) E[p].push_back(stk[j]); } --top;}void dfs(int u){ for(int v:E[u]) dfs(v); if(u&lt;=n){ f[u][1]=1; for(int v:E[u]) f[u][0]+=max(f[v][0], f[v][1]), f[u][1]+=f[v][0]; } else{ static int g[2], gg[2]; g[0]=-1e9, g[1]=0; for(int v:E[u]) gg[0]=max(g[0], g[1])+f[v][0], gg[1]=g[0]+f[v][1], swap(g, gg); f[u][0]=g[0]; g[0]=0, g[1]=-1e9; for(int v:E[u]) gg[0]=max(g[0], g[1])+f[v][0], gg[1]=g[0]+f[v][1], swap(g, gg); f[u][1]=max(g[0], g[1]); }}int main() { read(n), read(m), p=n; for(int i=1; i&lt;=m; ++i){ static int x, y; read(x), read(y); add(x, y), add(y, x); } tarjan(1), dfs(1); return printf(&quot;%d&quot;, max(f[1][0], f[1][1])), 0;}","link":"/bzoj-4316/"},{"title":"「BZOJ 3684」大朋友和多叉树","text":"BZOJ 3684: 大朋友和多叉树 题意求包含 $s$ 个叶子，非叶子节点的孩子数目在集合 $D$ 中的有根树数量。 孩子之间有顺序，保证 $1\\notin D$。 模质数 $950009857=453\\times 2^{21}+1$ $s,|D|\\le 10^5$ 做法好像就是板题 令 $D(x)=\\sum\\limits_{i=2}^\\infty [i\\in D]x^i$ 可以发现答案的生成函数 $f(x)=D(f(x))+x$，$f(x)$ 为 $x-D(x)$ 的复合逆 所求即为 $[x^s]f(x)$ 根据拉格朗日反演公式 $$[x^s]f(x)\\frac{1}{s} [x^{s-1}]\\left(\\frac{x-D(x)}{x}\\right)^{-s}$$ 可以在 $\\mathcal O(n\\log n)$ 的复杂度内完成 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ull unsigned long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const unsigned N = 1&lt;&lt;18, P = 950009857;struct Z{ unsigned x; Z(const unsigned _x=0):x(_x){} inline Z operator +(const Z &amp;rhs)const{ return x+rhs.x&lt;P?x+rhs.x:x+rhs.x-P;} inline Z operator -(const Z &amp;rhs)const{ return x&lt;rhs.x?x-rhs.x+P:x-rhs.x;} inline Z operator -()const{ return x?P-x:0;} inline Z operator *(const Z &amp;rhs)const{ return static_cast&lt;ull&gt;(x)*rhs.x%P;} inline Z operator +=(const Z &amp;rhs){ return x=x+rhs.x&lt;P?x+rhs.x:x+rhs.x-P, *this;} inline Z operator -=(const Z &amp;rhs){ return x=x&lt;rhs.x?x-rhs.x+P:x-rhs.x, *this;} inline Z operator *=(const Z &amp;rhs){ return x=static_cast&lt;ull&gt;(x)*rhs.x%P, *this;}};int s, m;vector&lt;Z&gt; d;namespace Poly{ Z w[N];// for DFT Z Inv[N];// for Integral inline Z Pow(Z x, int y=P-2){ Z ans=1; for(; y; y&gt;&gt;=1, x=x*x) if(y&amp;1) ans=ans*x; return ans; } inline void Init(){ for(unsigned i=1; i&lt;N; i&lt;&lt;=1){ w[i]=1; Z t=Pow(7, (P-1)/i/2); for(unsigned j=1; j&lt;i; ++j) w[i+j]=w[i+j-1]*t; } Inv[1]=1; for(unsigned i=2; i&lt;N; ++i) Inv[i]=Inv[P%i]*(P-P/i); } inline int Get(int x){ int n=1; while(n&lt;=x) n&lt;&lt;=1; return n;} inline void DFT(vector&lt;Z&gt; &amp;f, int n){ static ull F[N]; if((int)f.size()!=n) f.resize(n); for(int i=0, j=0; i&lt;n; ++i){ F[i]=f[j].x; for(int k=n&gt;&gt;1; (j^=k)&lt;k; k&gt;&gt;=1); } for(int i=1; i&lt;n; i&lt;&lt;=1) for(int j=0; j&lt;n; j+=i&lt;&lt;1){ Z *W=w+i; ull *F0=F+j, *F1=F+j+i; for(int k=j; k&lt;j+i; ++k, ++W, ++F0, ++F1){ ull t=(*F1)*(W-&gt;x)%P; (*F1)=*F0+P-t, (*F0)+=t; } } for(int i=0; i&lt;n; ++i) f[i]=F[i]%P; } inline void IDFT(vector&lt;Z&gt; &amp;f, int n){ f.resize(n), reverse(f.begin()+1, f.end()); DFT(f, n); Z I=Pow(n); for(int i=0; i&lt;n; ++i) f[i]=f[i]*I; } inline vector&lt;Z&gt; operator +(const vector&lt;Z&gt; &amp;f, const vector&lt;Z&gt; &amp;g){ vector&lt;Z&gt; ans=f; for(unsigned i=0; i&lt;f.size(); ++i) ans[i]+=g[i]; return ans; } inline vector&lt;Z&gt; operator *(const vector&lt;Z&gt; &amp;f, const vector&lt;Z&gt; &amp;g){ if((ull)f.size()*g.size()&lt;=1000){ vector&lt;Z&gt; ans; ans.resize(f.size()+g.size()-1); for(unsigned i=0; i&lt;f.size(); ++i) for(unsigned j=0; j&lt;g.size(); ++j) ans[i+j]+=f[i]*g[j]; return ans; } static vector&lt;Z&gt; F, G; F=f, G=g; int p=Get(f.size()+g.size()-2); DFT(F, p), DFT(G, p); for(int i=0; i&lt;p; ++i) F[i]*=G[i]; IDFT(F, p); return F.resize(f.size()+g.size()-1), F; } vector&lt;Z&gt; &amp;PolyInv(const vector&lt;Z&gt; &amp;f, int n=-1){ if(n==-1) n=f.size(); if(n==1){ static vector&lt;Z&gt; ans; return ans.clear(), ans.push_back(Pow(f[0])), ans; } vector&lt;Z&gt; &amp;ans=PolyInv(f, (n+1)/2); vector&lt;Z&gt; tmp(&amp;f[0], &amp;f[0]+n); int p=Get(n*2-2); DFT(tmp, p), DFT(ans, p); for(int i=0; i&lt;p; ++i) ans[i]=((Z)2-ans[i]*tmp[i])*ans[i]; IDFT(ans, p); return ans.resize(n), ans; } // a=d*b+r inline void PolyDiv(const vector&lt;Z&gt; &amp;a, const vector&lt;Z&gt; &amp;b, vector&lt;Z&gt; &amp;d, vector&lt;Z&gt; &amp;r){ if(b.size()&gt;a.size()) return d.clear(), (void)(r=a); vector&lt;Z&gt; A=a, B=b, iB; int n=a.size(), m=b.size(); reverse(A.begin(), A.end()), reverse(B.begin(), B.end()); B.resize(n-m+1), iB=PolyInv(B, n-m+1); d=A*iB; d.resize(n-m+1), reverse(d.begin(), d.end()); r=b*d, r.resize(m-1); for(int i=0; i&lt;m-1; ++i) r[i]=a[i]-r[i]; } inline vector&lt;Z&gt; Derivative(const vector&lt;Z&gt; &amp;a){ vector&lt;Z&gt; ans(a.size()-1); for(unsigned i=1; i&lt;a.size(); ++i) ans[i-1]=a[i]*i; return ans; } inline vector&lt;Z&gt; Integral(const vector&lt;Z&gt; &amp;a){ vector&lt;Z&gt; ans(a.size()+1); for(unsigned i=0; i&lt;a.size(); ++i) ans[i+1]=a[i]*Inv[i+1]; return ans; } inline vector&lt;Z&gt; PolyLn(const vector&lt;Z&gt; &amp;f){ vector&lt;Z&gt; ans=Derivative(f)*PolyInv(f); ans.resize(f.size()-1); return Integral(ans); } vector&lt;Z&gt; PolyExp(const vector&lt;Z&gt; &amp;f, int n=-1){ if(n==-1) n=f.size(); if(n==1) return {1}; vector&lt;Z&gt; ans=PolyExp(f, (n+1)/2), tmp; ans.resize(n), tmp=PolyLn(ans); for(Z &amp;i:tmp) i=-i; ++tmp[0].x; ans=ans*(tmp+f); return ans.resize(n), ans; } inline vector&lt;Z&gt; PolyPower(const vector&lt;Z&gt; &amp;f, int k){ vector&lt;Z&gt; ans=PolyLn(f); for(Z &amp;i:ans) i=i*k; return PolyExp(ans); }}int main() { Poly::Init(); read(s), read(m), d.resize(s); d[0]=1; for(int i=1, x; i&lt;=m; ++i) read(x), d[x-1]+=P-1; d=Poly::PolyPower(d, P-s); return printf(&quot;%d&quot;, (d[s-1]*Poly::Pow(s)).x), 0;}","link":"/bzoj-3684/"},{"title":"「BZOJ 4589」Hard Nim","text":"NOIP 之后就写了这么个 simple 题 BZOJ 4589 题意你有 $n$ 堆有序的石子，每堆的数量都是 $\\le m$ 的一个质数 你要玩 Nim游戏，问有多少种方案先手必败 $n\\le 10^9, m\\le 5*10^4$ 做法相当于有序选出 $n$ 个可以重复的质数使异或和为 $0$ 的方案数 定义卷积是异或卷积，直接 FWT 快速幂就好了 单次 $\\mathcal O(m\\log n)$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longconst int N = 50005, M = 1&lt;&lt;16, P = 1000000007;int cnt, n, m, l, prime[N], f[M], g[M];bool p[N];inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}inline void FWT(int *f, int g){ for(int i=1; i&lt;l; i&lt;&lt;=1) for(int j=0; j&lt;l; j+=i&lt;&lt;1) for(int k=j; k&lt;j+i; ++k){ int x=f[k], y=f[k+i]; f[k]=(x+y)%P, f[k+i]=(P+x-y)%P; } if(g==-1) for(int i=0, I=Pow(l); i&lt;l; ++i) f[i]=(ll)f[i]*I%P;}inline void mul(int *f, int *g){ for(int i=0; i&lt;l; ++i) f[i]=(ll)f[i]*g[i]%P;}int main() { for(int i=2; i&lt;=50000; ++i){ if(!p[i]) prime[++cnt]=i; for(int j=1; j&lt;=cnt &amp;&amp; i*prime[j]&lt;=50000; ++j){ p[i*prime[j]]=1; if(i%prime[j]==0) break; } } while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)){ memset(f, 0, sizeof f); for(int i=1; i&lt;=cnt &amp;&amp; prime[i]&lt;=m; ++i) f[prime[i]]=1; for(l=1; l&lt;=m; l&lt;&lt;=1); FWT(f, 1); memcpy(g, f, l&lt;&lt;2); for(--n; n; n&gt;&gt;=1, mul(f, f)) if(n&amp;1) mul(g, f); FWT(g, -1); printf(&quot;%d\\n&quot;, g[0]); } return 0;}","link":"/bzoj-4589/"},{"title":"最小树形图和朱刘算法","text":"好久没写博客了，不过修了好多以前文章的锅。 描述给出一张 $n$ 个点 $m$ 条带权边的有向图，钦定一个根 $r$，求以 $r$ 为根的最小有向生成树（Minimum Directed Spanning Tree，MDST，也即最小树形图）。 有向生成树（DST）即要求边是从父亲连向儿子。 下面给出的算法可以在 $O(n\\times m)$ 的复杂度内求解，另外存在更优的算法。 算法学习自 这里。 流程自环可以特判，重边没有影响。 1除了根节点，对每个点 $i$ 找到一条边权最小的入边，如果有多条相同，可以任意选择。 记 $a_i$ 表示这条入边的起点，$b_i$ 表示这条边的边权。 2 如果所选的边形成一棵树，结束。 否则会形成若干环套树外加包含根节点的一棵树。 如果此时有根节点以外的孤立的点，则无法形成合法的有向生成树，结束。 把每个环缩成一个点，不在环上的点保留，设点 $u$ 所属的环在新图中的编号为 $id_u$ 对于一条两端不在同一个环内的边 $(u,v,w)$，变成 $(id_u,id_v,w-b_{id_v})$。 形成的新图重复该步骤。 3最小权值和就是每轮第一步选出的最小入边的权值总和。 如果题目需要，可以复原出选择的边。 理解及证明除了根节点外的 $n-1$ 个点在 MDST 中恰好有一条入边，因此如果在第一步中选出的边合法，则必然是最小的，可以得到 MDST。 否则考虑一个环，环上至少有一个点的入边需要调整，可以证明存在一个 MDST 取到了这个环上的除一条边以外的全部边。 对于任意一个 MDST，如果有一个环多于一条边未取到，那么考虑环上的一条未被取到的边 $(u_0,v,w_0)$，假设对于 $v$ 在方案中选取的边是 $(u,v,w)$，由于环是最小的，那么有 $w_0\\le w$。 我们可以尝试把 $(u,v,w)$ 改成环边 $(u_0,v,w_0)$。 新图如果仍然是合法的 DST，那么权值和不会变大，因此必然也是一个 MDST。 出现不合法当且仅当在原来的 MDST 中 $u_0$ 在 $v$ 的子树中，即该边在原有向生成树中是返祖边。而如果一个环需要换边，其必有一条不是返祖边的非树边，因此上述操作可以不断执行直到满足“MDST 取到了这个环上的除一条边以外的全部边”。 复杂度排除了自环影响，除了最后一轮，每次重构的图都会至少减少一个点，单次复杂度 $O(m)$，因此总复杂度 $O(n\\times m)$。 代码参考下面的例题一。 例题好像都是板子 例题一 LOJ #140. 最小树形图LOJ #140. 最小树形图 模板 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 105, M = 10005;int n, m, r, p, ans, mm, id[N], a[N], b[N], x[M], y[M], z[M];bool instk[N], vis[N];void dfs(int u){ if(u==r) return; instk[u]=vis[u]=1; if(!vis[a[u]]) dfs(a[u]); else if(instk[a[u]]){ id[u]=++p; for(int j=a[u]; j!=u; j=a[j]) id[j]=p; } instk[u]=0; if(!id[u]) id[u]=++p;}int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;r); for(int i=1; i&lt;=m; ++i) scanf(&quot;%d%d%d&quot;, x+i, y+i, z+i); while(1){ for(int i=1; i&lt;=n; ++i) b[i]=1e9; for(int i=1; i&lt;=m; ++i) if(z[i]&lt;b[y[i]]) b[y[i]]=z[i], a[y[i]]=x[i]; memset(id+1, 0, n&lt;&lt;2), memset(vis+1, 0, n), id[r]=p=1; for(int i=1; i&lt;=n; ++i) if(i!=r){ if(b[i]==1e9) return puts(&quot;-1&quot;), 0; else ans+=b[i]; if(!vis[i]) dfs(i); } if(p==n) break; mm=0; for(int i=1; i&lt;=m; ++i) if(id[x[i]]!=id[y[i]]) z[++mm]=z[i]-b[y[i]], x[mm]=id[x[i]], y[mm]=id[y[i]]; m=mm, n=p, r=id[r]; } return printf(&quot;%d&quot;, ans), 0;} 例题二 LOJ #6510. 「雅礼集训 2018 Day8」ALOJ #6510. 「雅礼集训 2018 Day8」A 做法这题没有钦定一个根，我们可以新建一个根，连极大的边到每个点，保证了如果原图有解极大边只会取一次。 新图必然是有解的，原图无解即极大边选取了多次，判一下就好了。 时间复杂度还是 $O(n\\times m)$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;using namespace std;#define ll long longconst int N = 505, M = 126000;int n, m, p, mm, id[N], a[N], x[M], y[M];ll ans, b[N], z[M];bool vis[N], instk[N];void dfs(int u){ if(!u) return; instk[u]=vis[u]=1; if(!vis[a[u]]) dfs(a[u]); else if(instk[a[u]]){ id[u]=++p; for(int i=a[u]; i!=u; i=a[i]) id[i]=p; } instk[u]=0; if(!id[u]) id[u]=++p;}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=m; ++i) scanf(&quot;%d%d%lld&quot;, x+i, y+i, z+i); for(int i=1; i&lt;=n; ++i) y[++m]=i, z[m]=1ll&lt;&lt;40; while(1){ for(int i=1; i&lt;=n; ++i) b[i]=1ll&lt;&lt;50; for(int i=1; i&lt;=m; ++i) if(z[i]&lt;b[y[i]]) b[y[i]]=z[i], a[y[i]]=x[i]; memset(vis+1, 0, n), memset(id+1, 0, n&lt;&lt;2), mm=p=0; for(int i=1; i&lt;=n; ++i){ ans+=b[i]; if(!vis[i]) dfs(i); } if(n==p) break; for(int i=1; i&lt;=m; ++i) if(id[x[i]]!=id[y[i]]) z[++mm]=z[i]-b[y[i]], x[mm]=id[x[i]], y[mm]=id[y[i]]; m=mm, n=p; } return printf(&quot;%lld&quot;, ans&gt;(2ll&lt;&lt;40)?-1:ans-(1ll&lt;&lt;40)), 0;}","link":"/chu-liu-edmonds-algorithm/"},{"title":"二次剩余 Cipolla&#39;s algorithm","text":"定义当存在某个 $x$，式子 $x^2\\equiv a\\pmod p$ 成立时，称“$a$ 是模 $p$ 的二次剩余(Quadratic residue)” Cipolla’s algorithm只考虑 $p$ 是奇质数的情况 二次剩余的数量在 $[0,p)$ 中是 $\\frac{p+1}{2}$，包括 $0$ 证明考虑两个不同的数 $x,y$，若 $x^2\\equiv y^2\\pmod p$，那么 $p\\mid(x^2-y^2)$，即 $p\\mid(x-y)(x+y)$，显然 $p\\nmid(x-y)$，于是$p\\mid(x+y)$ 于是 $x+y\\equiv 0 \\pmod p$ 所以除了 $0$ 以外的数恰好两两匹配 Legendre symbol定义勒让德符号(Legendre symbol) $$\\left(\\frac{a}{p}\\right)=\\begin{cases}1,&amp; \\text{$a$ 是模 $p$ 的二次剩余} \\-1,&amp; \\text{$a$ 不是模 $p$ 的二次剩余} \\0,&amp; a\\equiv0 \\pmod p\\end{cases}$$ Euler’s criterion根据欧拉准则(Euler’s criterion) 若 $p$是奇质数且 $p$ 不能整除 $d$，则： $d$ 是模 $p$ 的二次剩余当且仅当： $$d^{\\frac {p-1}{2}}\\equiv 1{\\pmod {p}}$$ $d$ 是模 $p$ 的非二次剩余当且仅当： $$d^{\\frac {p-1}{2}}\\equiv -1{\\pmod {p}}$$ 以勒让德符号表示，即为： $$d^{\\frac {p-1}{2}}\\equiv \\left({\\frac {d}{p}}\\right){\\pmod {p}}$$ 证明参考这里 算法过程我们需要求满足 $x^2\\equiv a\\pmod p$ 的一个 $x$ 现在我们可以 $\\mathcal O(\\log p)$ 地判断一个数是否是模 $p$ 的二次剩余 1.随机一个$t$，满足 $t^2-a$ 是非二次剩余，根据前面二次剩余的分布，期望次数很小.. 2.令 $\\omega=\\sqrt{t^2-a}$ 需要求的$x=(t+\\omega)^{\\frac{p+1}{2}}$ 这里存两个系数 $a+b\\omega$ 就可以快速幂了 证明定理1 $$(a+b)^p\\equiv a^p+b^p \\pmod{p} \\tag{1}$$ 证明$$(a+b)^p=\\sum_{i=0}^p\\binom{p}{i}a^ib^{p-i}$$ 当 $i\\ne 0$ 且 $i\\ne p$，$\\binom{p}{i}\\equiv 0 \\pmod{p}$ 定理2 $$\\omega^p\\equiv-\\omega \\pmod{p} \\tag{2}$$ 证明因为$t^2-a$是非二次剩余，所以 $$\\omega^{p-1}=(\\omega^2)^{\\frac{p-1}{2}}=(t^2-a)^{\\frac{p-1}{2}}\\equiv-1 \\pmod{p}$$ 定理3 $$(a+\\omega)^p\\equiv a-\\omega \\pmod{p} \\tag{3}$$ 由(1),(2)显然 结论$$\\begin{align}x^2&amp;=(t+\\omega)^{p+1} \\&amp;=(t+\\omega)(t+\\omega)^p \\&amp;\\equiv (t+\\omega)(t-\\omega) \\pmod{p}\\&amp;=t^2-\\omega^2 \\&amp;=t^2-(t^2-a) \\&amp;=a\\end{align}$$ $\\omega$前的系数根据Lagrange’s theorem我们知道 $x^2-a=0$ 在任何域中都有两个根，并且我们前面得到了这两个根都在模 $p$ 的剩余系中，所以没有$\\omega$ 代码这里会返回一个较小的根 12345678910111213141516171819inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}inline pair&lt;int,int&gt; pMul(pair&lt;int,int&gt; x, pair&lt;int,int&gt; y, int f){ return make_pair( (int)(((ll)x.first*y.first+(ll)x.second*y.second%P*f)%P), (int)(((ll)x.second*y.first+(ll)x.first*y.second)%P) );}inline int Quadratic_residue(int a){ if(Pow(a, (P-1)/2)!=1) return -1; int x, f; do x=(((ll)rand()&lt;&lt;15)^rand())%(a-1)+1; while(Pow(f=((ll)x*x-a+P)%P, (P-1)/2)==1); pair&lt;int,int&gt; ans=make_pair(1, 0), t=make_pair(x, 1); for(int i=(P+1)/2; i; i&gt;&gt;=1, t=pMul(t, t, f)) if(i&amp;1) ans=pMul(ans, t, f); return min(ans.first, P-ans.first);} 启示没有","link":"/cipollas-algorithm/"},{"title":"特征多项式和常系数线性齐次递推","text":"特征多项式设 $A$ 为给定的 $n\\times n$ 矩阵，$I_n$ 为 $n\\times n$ 单位矩阵，$A$ 的特征多项式定义为 $$p(\\lambda )=\\det(\\lambda I_{n}-A)$$ 其中 $\\det$ 表示行列式。 Cayley–Hamilton theorem根据 凯莱–哈密顿定理，$A$ 满足方程 $$p(A)=0$$ 其中 $0$ 是零矩阵。 因此我们可以利用这个 $n$ 次的多项式 $p(A)$ 来降低 $A$ 的高次幂。 求特征多项式代入 $k+1$ 个值，求行列式，插值得到多项式系数。 高斯消元求行列式是 $O(n^3)$，总复杂度 $O(n^4)$。 有 $O(n^3)$ 的做法我就不学了。（点这里） 求矩阵的高次幂BZOJ 4162: shlw loves matrix II 求 $k\\times k$ 的矩阵 $M$ 的 $n$ 次幂。 $k\\le 50, n\\le 2^{10000}$。 暴力直接暴力不卡常本机 2s，复杂度$O(k^3\\log n)$。 正常做法先 $O(k^4)$ 求出矩阵的特征多项式 $p(x)$。 然后就要求出 $x^n \\bmod p(x)$，直接快速幂，其中乘法和取模都是 $O(k^2)$。 最后暴力乘出 $M^0, M^1, \\dotsc, M^{k-1}$，按系数计算答案，复杂度也是 $O(k^4)$。 总复杂度 $O(k^4+k^2\\log n)$。 代码在例题里贴。 常系数线性齐次递推给出系数 $c_1, c_2, \\dotsc, c_k$ 和数列 $f$ 的前 $k$ 项 $f_0, f_1, \\dotsc, f_{k-1}$。 对于 $n\\ge k$ 有 $f_n=\\sum\\limits_{i=1}^k f_{n-i}c_i$。 求 $f_n$。 暴力构造出转移矩阵 $$\\begin{bmatrix}c_1 &amp; c_2 &amp; \\cdots &amp; c_{k-1} &amp; c_k \\1 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0 \\0 &amp; 1 &amp; \\cdots &amp; 0 &amp; 0 \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\0 &amp; 0 &amp; \\cdots &amp; 1 &amp; 0\\end{bmatrix}\\begin{pmatrix}f_{k-1} \\f_{k-2} \\f_{k-3} \\\\vdots \\f_0\\end{pmatrix}\\begin{pmatrix}f_k \\f_{k-1} \\f_{k-2} \\\\vdots \\f_1\\end{pmatrix}$$ 可以做到 $O(k^3\\log n)$。 特征多项式优化上述转移矩阵设为 $A$，特征多项式是 $$\\begin{aligned}p(\\lambda) &amp; =\\det(\\lambda I-A) \\&amp; = \\det\\left( \\begin{bmatrix} \\lambda -c_1 &amp; -c_2 &amp; \\cdots &amp; -c_{k-1} &amp; -c_k \\ -1 &amp; \\lambda &amp; \\cdots &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; \\cdots &amp; \\lambda &amp; 0 \\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\ 0 &amp; 0 &amp; \\cdots &amp; -1 &amp; \\lambda \\end{bmatrix}\\right)\\end{aligned}$$ 对第一行展开 可以发现 $k$ 个代数余子式 $C_{1,1},C_{1,2},\\dotsc,C_{1,k}$ 分别是 $\\lambda^{k-1}, \\lambda^{k-2}, \\dotsc, \\lambda^0$。 于是 $p(\\lambda) = \\lambda^k - \\sum\\limits_{i=1}^k c_i\\lambda^{k-i}$。 我们令 $g(x)=x^n \\bmod p(x)$，于是 $A^n=\\sum\\limits_{i=0}^{k-1} g_i A^i$。 令 $\\vec{f}=\\begin{pmatrix}f_{k-1} \\f_{k-2} \\f_{k-3} \\\\vdots \\f_0\\end{pmatrix}$，$\\left[\\vec{a}\\right]_ k$ 表示列向量 $\\vec{a}$ 的第 $k$ 项。 则 $$\\begin{aligned}f(n) &amp; =\\left[A^n \\vec{f}\\right]_ k \\&amp; = \\left[\\sum_{i=0}^{k-1} g_i A^i \\vec{f}\\right]_ k \\&amp; = \\sum_{i=0}^{k-1} g_i \\left[A^i \\vec{f}\\right]_ k \\&amp; = \\sum_{i=0}^{k-1} g_i f_i\\end{aligned}$$ 因为 $A\\vec{f}$ 相当于转移了一次，转移 $i$ 次后向量的第 $k$ 项即 $f_i$。 实现其实只需要求 $g(x)=x^n \\bmod p(x)$ 就好了。 可以快速幂，暴力取模复杂度 $O(k^2\\log n)$，用 NTT 可以优化到 $O(k\\log k\\log n)$。 例题shlw loves matrix IIBZOJ 4162: shlw loves matrix II 上面讲过。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;using namespace std;#define ll long longconst int N = 55, M = 10005, P = 1000000007;int k, l, f[N], g[N], d[N], s[N&lt;&lt;1], a[N][N], b[N][N], ans[N][N];char n[M];inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}inline int det(int x){ memcpy(b, a, sizeof a); for(int i=0; i&lt;k; ++i) b[i][i]=(b[i][i]+P-x)%P; int ans=1; for(int i=0; i&lt;k; ++i){ if(!b[i][i]){ ans=P-ans; for(int j=i+1; j&lt;k; ++j) if(b[j][i]){ swap(b[i], b[j]); break;} if(!b[i][i]) return 0; } ans=(ll)ans*b[i][i]%P; int inv=Pow(b[i][i]); for(int j=i; j&lt;k; ++j) b[i][j]=(ll)b[i][j]*inv%P; for(int j=i+1; j&lt;k; ++j) for(int t=k-1; t&gt;=i; --t) b[j][t]=(b[j][t]+(ll)(P-b[j][i])*b[i][t])%P; } return ans;}inline void mul(int (*a)[N], int (*b)[N]){ static int tmp[N][N]; memset(tmp, 0, sizeof tmp); for(int i=0; i&lt;k; ++i) for(int t=0; t&lt;k; ++t) for(int j=0; j&lt;k; ++j) tmp[i][j]=(tmp[i][j]+(ll)a[i][t]*b[t][j])%P; memcpy(a, tmp, sizeof tmp);}int main() { scanf(&quot;%s%d&quot;, n, &amp;k); for(int i=0; i&lt;k; ++i) for(int j=0; j&lt;k; ++j) scanf(&quot;%d&quot;, a[i]+j); f[0]=1; for(int i=0; i&lt;=k; ++i) for(int j=i+1; ~j; --j) f[j]=((ll)(P-f[j])*i+(j?f[j-1]:0))%P; for(int i=0; i&lt;=k; ++i){ int x=1; memcpy(g, f, (k+2)&lt;&lt;2); for(int j=k+1; j; --j) g[j-1]=(g[j-1]+(ll)g[j]*i)%P; for(int j=0; j&lt;=k; ++j) if(i!=j) x=(ll)x*(i-j+P)%P; x=(ll)Pow(x)*det(i)%P; for(int j=0; j&lt;=k; ++j) d[j]=(d[j]+(ll)g[j+1]*x)%P; } for(int i=0, inv=Pow(d[k]); i&lt;=k; ++i) d[i]=(ll)d[i]*inv%P; s[0]=1; for(int x=0; n[x]; ++x){ static int tmp[N]; memcpy(tmp, s, k&lt;&lt;2), memset(s, 0, sizeof s); for(int i=0; i&lt;k; ++i) for(int j=0; j&lt;k; ++j) s[i+j]=(s[i+j]+(ll)tmp[i]*tmp[j])%P; if(n[x]&amp;1){ for(int i=k*2-1; i; --i) s[i]=s[i-1]; s[0]=0; } for(int i=k*2-1; i&gt;=k; --i) for(int j=k; ~j; --j) s[i-j]=(s[i-j]+(ll)(P-d[k-j])*s[i])%P; } memset(b, 0, sizeof b); for(int i=0; i&lt;k; ++i) b[i][i]=1; for(int x=0; x&lt;k; ++x){ for(int i=0; i&lt;k; ++i) for(int j=0; j&lt;k; ++j) ans[i][j]=(ans[i][j]+(ll)s[x]*b[i][j])%P; mul(b, a); } for(int i=0; i&lt;k; ++i) for(int j=0; j&lt;k; ++j) printf(&quot;%d%c&quot;, ans[i][j], &quot; \\n&quot;[j==k-1]); return 0;} 【模板】线性递推Luogu P4723 【模板】线性递推 模板，需要 NTT。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ull unsigned long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 1000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 1&lt;&lt;17, P = 998244353;struct Z{ unsigned x; Z(const unsigned _x=0):x(_x){} inline Z operator +(const Z &amp;rhs)const{ return x+rhs.x&lt;P?x+rhs.x:x+rhs.x-P;} inline Z operator -(const Z &amp;rhs)const{ return x&lt;rhs.x?x-rhs.x+P:x-rhs.x;} inline Z operator -()const{ return x?P-x:0;} inline Z operator *(const Z &amp;rhs)const{ return static_cast&lt;ull&gt;(x)*rhs.x%P;} inline Z operator +=(const Z &amp;rhs){ return x=x+rhs.x&lt;P?x+rhs.x:x+rhs.x-P, *this;} inline Z operator -=(const Z &amp;rhs){ return x=x&lt;rhs.x?x-rhs.x+P:x-rhs.x, *this;} inline Z operator *=(const Z &amp;rhs){ return x=static_cast&lt;ull&gt;(x)*rhs.x%P, *this;}};int n, k;Z ans;vector&lt;Z&gt; f;namespace Poly{ Z w[N];// for DFT inline Z Pow(Z x, int y=P-2){ Z ans=1; for(; y; y&gt;&gt;=1, x=x*x) if(y&amp;1) ans=ans*x; return ans; } inline void Init(){ for(int i=1; i&lt;N; i&lt;&lt;=1){ w[i]=1; Z t=Pow(3, (P-1)/i/2); for(int j=1; j&lt;i; ++j) w[i+j]=w[i+j-1]*t; } } inline int Get(int x){ int n=1; while(n&lt;=x) n&lt;&lt;=1; return n;} inline void DFT(vector&lt;Z&gt; &amp;f, int n){ static ull F[N]; if((int)f.size()!=n) f.resize(n); for(int i=0, j=0; i&lt;n; ++i){ F[i]=f[j].x; for(int k=n&gt;&gt;1; (j^=k)&lt;k; k&gt;&gt;=1); } for(int i=1; i&lt;n; i&lt;&lt;=1) for(int j=0; j&lt;n; j+=i&lt;&lt;1){ Z *W=w+i; ull *F0=F+j, *F1=F+j+i; for(int k=j; k&lt;j+i; ++k, ++W, ++F0, ++F1){ ull t=(*F1)*(W-&gt;x)%P; (*F1)=*F0+P-t, (*F0)+=t; } } for(int i=0; i&lt;n; ++i) f[i]=F[i]%P; } inline void IDFT(vector&lt;Z&gt; &amp;f, int n){ f.resize(n), reverse(f.begin()+1, f.end()); DFT(f, n); Z I=Pow(n); for(int i=0; i&lt;n; ++i) f[i]=f[i]*I; } inline vector&lt;Z&gt; operator *(const vector&lt;Z&gt; &amp;f, const vector&lt;Z&gt; &amp;g){ if((ull)f.size()*g.size()&lt;=1000){ vector&lt;Z&gt; ans; ans.resize(f.size()+g.size()-1); for(unsigned i=0; i&lt;f.size(); ++i) for(unsigned j=0; j&lt;g.size(); ++j) ans[i+j]+=f[i]*g[j]; return ans; } static vector&lt;Z&gt; F, G; F=f, G=g; int p=Get(f.size()+g.size()-2); DFT(F, p), DFT(G, p); for(int i=0; i&lt;p; ++i) F[i]*=G[i]; IDFT(F, p); return F.resize(f.size()+g.size()-1), F; } vector&lt;Z&gt; PolyInv(const vector&lt;Z&gt; &amp;f, int n=-1){ if(n==-1) n=f.size(); if(n==1) return {Pow(f[0])}; vector&lt;Z&gt; ans=PolyInv(f, (n+1)/2), tmp(&amp;f[0], &amp;f[0]+n); int p=Get(n*2-2); DFT(tmp, p), DFT(ans, p); for(int i=0; i&lt;p; ++i) ans[i]=((Z)2-ans[i]*tmp[i])*ans[i]; IDFT(ans, p); return ans.resize(n), ans; } // a=d*b+r inline void PolyDiv(const vector&lt;Z&gt; &amp;a, const vector&lt;Z&gt; &amp;b, vector&lt;Z&gt; &amp;d, vector&lt;Z&gt; &amp;r){ if(b.size()&gt;a.size()) return d.clear(), (void)(r=a); vector&lt;Z&gt; A=a, B=b, iB; int n=a.size(), m=b.size(); reverse(A.begin(), A.end()), reverse(B.begin(), B.end()); B.resize(n-m+1), iB=PolyInv(B, n-m+1); d=A*iB; d.resize(n-m+1), reverse(d.begin(), d.end()); r=b*d, r.resize(m-1); for(int i=0; i&lt;m-1; ++i) r[i]=a[i]-r[i]; } inline void Sqr(vector&lt;Z&gt; &amp;f){ int n=f.size(); if((ull)n*n&lt;=1000){ vector&lt;Z&gt; ans(n*2-1); for(int i=0; i&lt;n; ++i) for(int j=0; j&lt;n; ++j) ans[i+j]+=f[i]*f[j]; f=ans; return; } int p=Get(n*2-2); DFT(f, p); for(int i=0; i&lt;p; ++i) f[i]*=f[i]; IDFT(f, p); f.resize(n*2-1); } inline vector&lt;Z&gt; solve(int n, const vector&lt;Z&gt; &amp;a){ if(n==1) return {0, 1}; vector&lt;Z&gt; ans=solve(n&gt;&gt;1, a), t; Sqr(ans); if(n&amp;1) ans.insert(ans.begin(), 0); PolyDiv(ans, a, t, t); return t; }}int main() { Poly::Init(); read(n), read(k), f.resize(k+1), f[k]=1; for(int i=k, x; i--;) read(x), f[i].x=(P-x%P)%P; f=Poly::solve(n, f); for(int i=0, x; i&lt;k; ++i) read(x), ans+=f[i]*(x%P+P); return printf(&quot;%d&quot;, ans.x), 0;} Shlw loves matrixIBZOJ 4161: Shlw loves matrixI 可以暴力取模，由于模数原因也可以用 MTT。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ll long longconst double Pi = acos(-1);const int N = 1&lt;&lt;13, P = 1000000007;int n, k, ans;vector&lt;int&gt; a;struct cp{ double a, b; inline void operator +=(const cp &amp;rhs){ a+=rhs.a, b+=rhs.b;} inline cp operator +(const cp &amp;rhs)const{ return (cp){a+rhs.a, b+rhs.b};} inline cp operator -(const cp &amp;rhs)const{ return (cp){a-rhs.a, b-rhs.b};} inline cp operator *(const cp &amp;rhs)const{ return (cp){a*rhs.a-b*rhs.b, a*rhs.b+b*rhs.a};} inline cp operator *(const double rhs)const{ return (cp){a*rhs, b*rhs};} inline cp operator ~()const{ return (cp){a, -b};}} w[N];inline void Init(){ for(int i=1; i&lt;N; i&lt;&lt;=1){ w[i]=(cp){1, 0}; for(int j=1; j&lt;i; ++j) w[i+j]=((j&amp;31)==1?(cp){cos(Pi*j/i), sin(Pi*j/i)}:w[i+j-1]*w[i+1]); }}inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}inline int Get(int x){ int n=1; while(n&lt;=x) n&lt;&lt;=1; return n;}inline void DFT_(cp *f, int n){ for(register int i=0, j=0; i&lt;n; ++i){ if(i&gt;j) swap(f[i], f[j]); for(register int k=n&gt;&gt;1; (j^=k)&lt;k; k&gt;&gt;=1); } for(register int i=1; i&lt;n; i&lt;&lt;=1) for(register int j=0; j&lt;n; j+=i&lt;&lt;1) for(register int k=j; k&lt;j+i; ++k){ cp t=w[i+k-j]*f[k+i]; f[k+i]=f[k]-t, f[k]+=t; }}inline void DFT(cp *f, int n){ if(n==1) return; n&gt;&gt;=1; static cp a[N/2]; for(register int i=0; i&lt;n; ++i) a[i]=(cp){f[i&lt;&lt;1].a, f[i&lt;&lt;1|1].a}; DFT_(a, n); for(register int i=0; i&lt;n; ++i){ cp q=~a[(n-i)&amp;(n-1)], x=(a[i]+q)*.5, y=(a[i]-q)*(cp){0, -.5}, t=y*w[n+i]; f[i]=x+t, f[n+i]=x-t; }}inline void IDFT(cp *f, int n){ if(n==1) return; reverse(f+1, f+n), n&gt;&gt;=1; static cp a[N/2]; for(register int i=0; i&lt;n; ++i) a[i]=(f[i]+f[i+n])*.5 + (f[i]-f[i+n])*(cp){0, .5}*w[n+i]; DFT_(a, n); double k=1./n; for(register int i=0; i&lt;n; ++i) f[i&lt;&lt;1]=(cp){a[i].a*k, 0}, f[i&lt;&lt;1|1]=(cp){a[i].b*k, 0};}inline vector&lt;int&gt; operator *(const vector&lt;int&gt; &amp;f, const vector&lt;int&gt; &amp;g){ vector&lt;int&gt; ans(f.size()+g.size()-1); if((ll)f.size()*g.size()&lt;=1000){ for(unsigned i=0; i&lt;f.size(); ++i) for(unsigned j=0; j&lt;g.size(); ++j) ans[i+j]=(ans[i+j]+(ll)f[i]*g[j])%P; return ans; } int l=Get(f.size()+g.size()-2); static cp f0[N], f1[N], g0[N], g1[N], A[N], B[N], C[N]; memset(f0, 0, sizeof(cp)*l), memset(f1, 0, sizeof(cp)*l); memset(g0, 0, sizeof(cp)*l), memset(g1, 0, sizeof(cp)*l); for(unsigned i=0; i&lt;f.size(); ++i) f0[i].a=f[i]&amp;32767, f1[i].a=f[i]&gt;&gt;15; for(unsigned i=0; i&lt;g.size(); ++i) g0[i].a=g[i]&amp;32767, g1[i].a=g[i]&gt;&gt;15; DFT(f0, l), DFT(f1, l), DFT(g0, l), DFT(g1, l); for(int i=0; i&lt;l; ++i) A[i]=f1[i]*g1[i], B[i]=f1[i]*g0[i]+f0[i]*g1[i], C[i]=f0[i]*g0[i]; IDFT(A, l), IDFT(B, l), IDFT(C, l); for(unsigned i=0; i&lt;ans.size(); ++i) ans[i]=(((ll)(A[i].a+.5)%P&lt;&lt;30)+((ll)(B[i].a+.5)&lt;&lt;15)+(ll)(C[i].a+.5))%P; return ans;}vector&lt;int&gt; PolyInv(const vector&lt;int&gt; &amp;f, int n=-1){ if(n==-1) n=f.size(); if(n==1){ vector&lt;int&gt; ans; return ans.push_back(Pow(f[0])), ans; } vector&lt;int&gt; ans=PolyInv(f, (n+1)/2), tmp(&amp;f[0], &amp;f[0]+n); tmp=tmp*ans*ans, tmp.resize(n); for(unsigned i=0; i&lt;ans.size(); ++i) tmp[i]=(2*ans[i]-tmp[i])%P, tmp[i]=(tmp[i]&lt;0?tmp[i]+P:tmp[i]); for(int i=ans.size(); i&lt;n; ++i) tmp[i]=(tmp[i]?P-tmp[i]:0); return tmp;}inline void PolyDiv(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b, vector&lt;int&gt; &amp;r){ if(b.size()&gt;a.size()) return (void)(r=a); vector&lt;int&gt; A=a, B=b, iB; int n=a.size(), m=b.size(); reverse(A.begin(), A.end()), reverse(B.begin(), B.end()); B.resize(n-m+1), iB=PolyInv(B, n-m+1); r=A*iB; r.resize(n-m+1), reverse(r.begin(), r.end()); r=b*r, r.resize(m-1); for(int i=0; i&lt;m-1; ++i) r[i]=(a[i]-r[i]&lt;0?a[i]-r[i]+P:a[i]-r[i]);}inline vector&lt;int&gt; Solve(int n){ if(n==1) return {0, 1}; vector&lt;int&gt; ans=Solve(n&gt;&gt;1), t; ans=ans*ans; if(n&amp;1) ans.insert(ans.begin(), 0); return PolyDiv(ans, a, t), t;}int main() { Init(); scanf(&quot;%d%d&quot;, &amp;n, &amp;k), a.resize(k+1), a[k]=1; for(int i=k; i--;) scanf(&quot;%d&quot;, &amp;a[i]), a[i]=(P-a[i])%P; a=Solve(n); for(int i=0, x; i&lt;k; ++i) scanf(&quot;%d&quot;, &amp;x), ans=(ans+(ll)a[i]*(x+P))%P; return printf(&quot;%d&quot;, ans), 0;} 【NOI2017】泳池咕咕咕。","link":"/characteristic-polynomial/"},{"title":"「BZOJ 4373」算术天才⑨与等差数列","text":"BZOJ 4373 题意你有一个长度为$n$的数列$a$，需要支持如下操作： 单点修改 给出$l,r,k$，询问区间$[l..r]$中的数从小到大排序后是否为公差为$k$等差数列 强制在线 做法一考虑转化为若干个条件分别验证： $max{a_i|l\\le i\\le r}-min{a_i|l\\le i\\le r}=k(r-l)$ $gcd{a_i|l&lt;i\\le r}=k$ 区间中没有重复数字 证明略 第一项可以用线段树轻松维护 第二项差分后可以用线段树轻松维护 第三项可以对每个值开一个$set$维护出现位置$i$和值相同的前驱位置$pre_i$，每次操作会修改$\\mathcal O(1)$个前驱，区间中没有重复数字当且仅当$max{pre_i|l\\le i\\le r}&lt;l$ 时间复杂度$\\mathcal O(n\\log n\\log w)$，其中$w$是值域。(不满但是慢？) 做法二Hash，看到以下两种可以过 方差，模$10^9+7$ 平方和，自然溢出 复杂度$\\mathcal O(n\\log n)$ 代码只有做法一 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) { if (c == '-') iosig = true; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x + (x &lt;&lt; 2)) &lt;&lt; 1) + (c ^ '0'); if (iosig) x = -x;}const int N = 300005;int n, m, ans, a[N], mn[N&lt;&lt;2], mx[N&lt;&lt;2], g[N&lt;&lt;2], pre[N&lt;&lt;2];map&lt;int,set&lt;int&gt; &gt; f;inline int gcd(int x, int y){ return y?gcd(y, x%y):x;}void build(int l, int r, int t){ if(l==r) return (void)( mn[t]=mx[t]=a[l], g[t]=a[l]-a[l-1]); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; build(l, mid, k), build(mid+1, r, k|1); mn[t]=min(mn[k], mn[k|1]), mx[t]=max(mx[k], mx[k|1]), g[t]=gcd(g[k], g[k|1]);}void modify1(int l, int r, int t, int x, int y){ if(l==r) return (void)(mn[t]=mx[t]=y); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; if(x&lt;=mid) modify1(l, mid, k, x, y); else modify1(mid+1, r, k|1, x, y); mn[t]=min(mn[k], mn[k|1]), mx[t]=max(mx[k], mx[k|1]);}void modify2(int l, int r, int t, int x, int y){ if(l==r) return (void)(g[t]=y); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; if(x&lt;=mid) modify2(l, mid, k, x, y); else modify2(mid+1, r, k|1, x, y); g[t]=gcd(g[k], g[k|1]);}void modify3(int l, int r, int t, int x, int y){ if(l==r) return (void)(pre[t]=y); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; if(x&lt;=mid) modify3(l, mid, k, x, y); else modify3(mid+1, r, k|1, x, y); pre[t]=max(pre[k], pre[k|1]);}pair&lt;int,int&gt; query1(int l, int r, int t, int L, int R){ if(L&lt;=l &amp;&amp; r&lt;=R) return make_pair(mn[t], mx[t]); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; if(R&lt;=mid) return query1(l, mid, k, L, R); if(L&gt;mid) return query1(mid+1, r, k|1, L, R); pair&lt;int,int&gt; x=query1(l, mid, k, L, R), y=query1(mid+1, r, k|1, L, R); return make_pair(min(x.first, y.first), max(x.second, y.second));}int query2(int l, int r, int t, int L, int R){ if(L&lt;=l &amp;&amp; r&lt;=R) return g[t]; int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; if(R&lt;=mid) return query2(l, mid, k, L, R); if(L&gt;mid) return query2(mid+1, r, k|1, L, R); return gcd(query2(l, mid, k, L, R), query2(mid+1, r, k|1, L, R));}int query3(int l, int r, int t, int L, int R){ if(L&lt;=l &amp;&amp; r&lt;=R) return pre[t]; int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; return max(L&lt;=mid?query3(l, mid, k, L, R):0, R&gt;mid?query3(mid+1, r, k|1, L, R):0);}int main() { read(n), read(m); for(int i=1; i&lt;=n; ++i){ read(a[i]); set&lt;int&gt; *s=&amp;f[a[i]]; set&lt;int&gt;::iterator it=s-&gt;end(); if(it!=s-&gt;begin()) modify3(1, n, 1, i, *--it); s-&gt;insert(i); } build(1, n, 1); while(m--){ static int opt, x, y, k; read(opt), read(x), read(y), x^=ans, y^=ans; if(opt==1){ modify1(1, n, 1, x, y); modify2(1, n, 1, x, y-a[x-1]); modify2(1, n, 1, x+1, a[x+1]-y); set&lt;int&gt; *s=&amp;f[a[x]]; set&lt;int&gt;::iterator it=s-&gt;find(x); if(++it!=s-&gt;end()) k=*it, modify3(1, n, 1, k, (--it==s-&gt;begin()?0:*--it)); s-&gt;erase(x); s=&amp;f[a[x]=y]; it=s-&gt;lower_bound(x); if(it!=s-&gt;end()) modify3(1, n, 1, *it, x); if(it!=s-&gt;begin()) modify3(1, n, 1, x, *--it); else modify3(1, n, 1, x, 0); s-&gt;insert(x); } else{ read(k), k^=ans; pair&lt;int,int&gt; tmp=query1(1, n, 1, x, y); if(x==y) puts(&quot;Yes&quot;), ++ans; else if(k==0 &amp;&amp; tmp.second==tmp.first) puts(&quot;Yes&quot;), ++ans; else if(tmp.second-tmp.first==(ll)(y-x)*k &amp;&amp; query3(1, n, 1, x, y)&lt;x &amp;&amp; abs(query2(1, n, 1, x+1, y))==k) puts(&quot;Yes&quot;), ++ans; else puts(&quot;No&quot;); } } return 0;}","link":"/bzoj-4373/"},{"title":"「Codeforces 1034C」Region Separation","text":"没有思维能力了 Codeforces 1034C 题意给你一棵 $n$ 个点的树，有点权$a_1,..,a_n$，整棵树是一个1级区域 除非 $i$ 是最后一个等级，否则每一个i级区域都要被分成至少两个i+1级区域 每个点必须恰好属于一个每种等级的区域 一个区域必须是连通的 每个相同等级的区域必须拥有相同的点权和 求有多少种不同的划分方案，模 $10^9+7$ $n\\le 10^6,a_i\\le 10^9$ 做法先考虑能不能把整棵树划分为$k$个2级区域 令 $sum=\\sum_{i=1}^n a_i$ 每个2级区域的权值和必然是 $\\frac{sum}{k}$ 有一种显然的判断方式，自底向上找到权值和恰好等于 $\\frac{sum}{k}$ 的子树并割开，若都能满足，则 $k$ 是合法的 定义 $s_i$ 表示点 $i$ 的子树权值和，可以发现上述过程割开的点的 $s_i$ 都是 $\\frac{sum}{k}$ 的倍数，即 $s_i \\equiv 0\\pmod{\\frac{sum}{k}}$ 显然 $k$ 合法当且仅当满足 $s_i \\equiv 0\\pmod{\\frac{sum}{k}}$ 的点 $i$ 恰有 $k$ 个 并且有 $1 \\le k \\le n$ 我们考虑一个点 $i$ 会对哪些 $k$ 产生贡献 设 $s_i=\\frac{sum}{k} * a$，其中 $a$ 是整数，即 $k=\\frac{sum}{s_i} * a$ 可以发现合法的 $k$ 恰好是 $\\frac{sum}{\\gcd(sum,s_i)}$ 的倍数 可以记下来之后 $\\mathcal O(n\\ln n)$ 地枚举倍数处理 接下来考虑dp 令 $f_i$ 表示最后一级分成 $i$ 个区域的方案数 对于合法的 $k$，有 $f_k=\\sum_{d\\mid k,d\\ne k} f_d$ 预处理约数即可 总复杂度 $\\mathcal O(n(\\log n + \\log sum))$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int N = 1000005, P = 1000000007;int ans, n, a[N], fa[N], f[N], g[N];ll sum, s[N];vector&lt;int&gt; d[N];inline ll gcd(ll x, ll y){ return y?gcd(y, x%y):x;}int main() { read(n); for(int i=1; i&lt;=n; ++i) read(a[i]), sum+=a[i]; for(int i=2; i&lt;=n; ++i) read(fa[i]); for(int i=n; i; --i){ s[i]+=a[i], s[fa[i]]+=s[i]; ll x=sum/gcd(sum, s[i]); if(x&lt;=n) ++f[x]; } for(int i=n; i; --i) for(int j=i&lt;&lt;1; j&lt;=n; j+=i) f[j]+=f[i], d[j].push_back(i); ans=g[1]=1; for(int i=2; i&lt;=n; ++i) if(f[i]==i){ for(int j:d[i]) (g[i]+=g[j])%=P; (ans+=g[i])%=P; } return printf(&quot;%d&quot;, ans), 0;}","link":"/codeforces-1034c-region-separation/"},{"title":"「BZOJ 3064」「Tyvj 1518」CPU监控","text":"BZOJ 3064 题意你有一个长度为$n$的数列，$m$个操作。 查询区间最大值 查询所有历史版本（包括现在）的区间最大值的最大值 区间加 区间覆盖 $n,m\\le 10^5$ 实现线段树，每个节点维护 最大值 加标记 覆盖标记 历史最大值的最大值 历史最大加标记 历史最大覆盖标记 其中最后两项记录的是，从上一次该节点标记下传至子节点之后，到现在的最大值 对于一个节点，出现覆盖标记时，可以清空加法标记，并且之后出现区间加时直接在覆盖标记上更改。 即每次下传前，一个节点有“加”和“覆盖”两个阶段，并且“加”在前。 所以下传的时候，需要先用加标记和历史最大加标记去更新子节点的各个信息。 复杂度 $\\mathcal O(m\\log n)$ 代码假装不会出现 -inf 的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) { if (c == '-') iosig = true; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x + (x &lt;&lt; 2)) &lt;&lt; 1) + (c ^ '0'); if (iosig) x = -x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh = obuf;inline void print(char c) { if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf; *ooh++ = c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x == 0) print('0'); else { if (x &lt; 0) print('-'), x = -x; for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48; while (cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 100005, inf = 0x7fffffff;int n, m, a[N], add[N&lt;&lt;2], madd[N&lt;&lt;2], cov[N&lt;&lt;2], mcov[N&lt;&lt;2], mx[N&lt;&lt;2], mmx[N&lt;&lt;2];inline void chkmx(int &amp;x, int y){ x&lt;y?x=y:0;}inline void pushdown(int t){ int k=t&lt;&lt;1; if(add[t] || madd[t]){ chkmx(mmx[k], mx[k]+madd[t]), mx[k]+=add[t]; if(cov[k]!=-inf) chkmx(mcov[k], cov[k]+madd[t]), cov[k]+=add[t]; else chkmx(madd[k], add[k]+madd[t]), add[k]+=add[t]; chkmx(mmx[k|1], mx[k|1]+madd[t]), mx[k|1]+=add[t]; if(cov[k|1]!=-inf) chkmx(mcov[k|1], cov[k|1]+madd[t]), cov[k|1]+=add[t]; else chkmx(madd[k|1], add[k|1]+madd[t]), add[k|1]+=add[t]; } if(cov[t]!=-inf){ chkmx(mmx[k], mcov[t]), mx[k]=cov[t]; add[k]=0, chkmx(mcov[k], mcov[t]), cov[k]=cov[t]; chkmx(mmx[k|1], mcov[t]), mx[k|1]=cov[t]; add[k|1]=0, chkmx(mcov[k|1], mcov[t]), cov[k|1]=cov[t]; } add[t]=madd[t]=0, cov[t]=mcov[t]=-inf;}inline void update(int t){ int k=t&lt;&lt;1; mx[t]=max(mx[k], mx[k|1]); mmx[t]=max(mmx[k], mmx[k|1]);}void build(int l, int r, int t){ madd[t]=add[t]=0, mcov[t]=cov[t]=-inf; if(l==r) return (void)(mmx[t]=mx[t]=a[l]); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; build(l, mid, k), build(mid+1, r, k|1); mmx[t]=mx[t]=max(mx[k], mx[k|1]);}void Plus(int l, int r, int t, int L, int R, int x){ if(L&lt;=l &amp;&amp; r&lt;=R) return chkmx(mmx[t], mx[t]+=x), cov[t]==-inf?chkmx(madd[t], add[t]+=x):chkmx(mcov[t], cov[t]+=x); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; pushdown(t); if(L&lt;=mid) Plus(l, mid, k, L, R, x); if(R&gt;mid) Plus(mid+1, r, k|1, L, R, x); update(t);}void change(int l, int r, int t, int L, int R, int x){ if(L&lt;=l &amp;&amp; r&lt;=R) return chkmx(mmx[t], mx[t]=x), add[t]=0, chkmx(mcov[t], cov[t]=x); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; pushdown(t); if(L&lt;=mid) change(l, mid, k, L, R, x); if(R&gt;mid) change(mid+1, r, k|1, L, R, x); update(t);}int query1(int l, int r, int t, int L, int R){ if(L&lt;=l &amp;&amp; r&lt;=R) return mx[t]; int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; pushdown(t); return max(L&lt;=mid?query1(l, mid, k, L, R):-inf, R&gt;mid?query1(mid+1, r, k|1, L, R):-inf);}int query2(int l, int r, int t, int L, int R){ if(L&lt;=l &amp;&amp; r&lt;=R) return mmx[t]; int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; pushdown(t); return max(L&lt;=mid?query2(l, mid, k, L, R):-inf, R&gt;mid?query2(mid+1, r, k|1, L, R):-inf);}int main() { read(n); for(int i=1; i&lt;=n; ++i) read(a[i]); build(1, n, 1); read(m); while(m--){ static char opt; static int x, y, z; while(isspace(opt=read())); read(x), read(y); if(opt=='Q') print(query1(1, n, 1, x, y)), print('\\n'); else if(opt=='A') print(query2(1, n, 1, x, y)), print('\\n'); else if(opt=='P') read(z), Plus(1, n, 1, x, y, z); else read(z), change(1, n, 1, x, y, z); } return flush(), 0;}","link":"/bzoj-3064/"},{"title":"「Codeforces 1034D」Intervals of Intervals","text":"zx2003说多 log 过不去，不然就去写了 Codeforces 1034D 题意你有 $n$ 个区间 $[a_i, b_i]$，定义区间的区间 $[l,r]$ 的价值是第 $l$ 个区间到第 $r$ 个区间的并的总长度 你需要找出 $k$ 个不同的区间的区间，使得它们的总价值最大 输出总价值 $1\\le n \\le 3 * 10^5,1 \\le k \\le \\min{\\frac{n(n+1)}{2},10^9}$ 做法显然我们要选出最大的 $k$ 个区间的区间 显然可以二分其中最小的一个的价值 显然对于一个 $r$，满足价值不小于常数 $x$ 的区间的区间 $[l,r]$ 的可能的 $l$ 是一个前缀 显然单调增加 $r$，最大的 $l$ 是单调的 考虑用平衡树维护线段及编号，并记录每条线段剩余未被覆盖的长度，加入线段时把覆盖的部分删除即可 这样就可以维护一个 $l$ 的最大值，单次 $\\mathcal O(n\\log n\\log w)$，其中 $w$ 是值域 但是显然这里删除和插入线段的总次数是 $\\mathcal O(n)$ 的，于是我们可以只做一次，记录每次删除的情况，之后可以单次 $\\mathcal O(n)$ 地检验一个答案 以上复杂度 $\\mathcal O(n(\\log n+\\log w))$ 还有一个问题是要求出最大的 $k$ 个区间的区间的价值和 和单次的检验一样，也是维护每条线段未被覆盖的长度 记当前右端点是 $r$，可行的 $l$ 的最大值为 $max_l$ 对于 $[max_l,r]$ 之间的线段，贡献 $max_l$ 次，对于 $i&gt;max_l$ 贡献 $i$ 次 简单维护一下就好了 这里未被覆盖的长度就可以避免重复计算 注意选出的区间的区间不一定是恰好 $k$ 个，但是多出的部分价值必然是二分出来的价值，减去就好了 由于当价值相同的区间的区间很多的时候，计算出来的总贡献应该会爆long long，但是答案是不会爆的，减去之后会自然溢出回来，所以直接写就好了 排斥set维护线段，本来就去写线段树了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;set&gt;#include&lt;vector&gt;using namespace std;#define ll long long#define pb push_backinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int N = 300005, inf = 1e9+1;int mx, n, k, id, a[N], b[N], len[N];struct seg{ int l, r, col; inline bool operator &lt;(const seg &amp;rhs)const{ return l&lt;rhs.l || (l==rhs.l &amp;&amp; r&lt;rhs.r);}};set&lt;seg&gt; s;vector&lt;seg&gt; e[N];inline void init(){ s.insert((seg){0, inf, 0}); for(int i=1; i&lt;=n; ++i){ auto it=s.lower_bound((seg){a[i], inf, 0}); --it; if(it-&gt;r &gt;= b[i]){ e[i].pb((seg){a[i], b[i], it-&gt;col}); if(it-&gt;l &lt; a[i]) s.insert((seg){it-&gt;l, a[i]-1, it-&gt;col}); if(it-&gt;r &gt; b[i]) s.insert((seg){b[i]+1, it-&gt;r, it-&gt;col}); s.erase(it); s.insert((seg){a[i], b[i], i}); continue; } e[i].pb((seg){a[i], it-&gt;r, it-&gt;col}); if(it-&gt;l &lt; a[i]) s.insert((seg){it-&gt;l, a[i]-1, it-&gt;col}); s.erase(it++); if(it-&gt;r&lt;a[i]) ++it; while(it-&gt;r &lt; b[i]) e[i].pb(*it), s.erase(it++); e[i].pb((seg){it-&gt;l, b[i], it-&gt;col}); if(it-&gt;r &gt; b[i]) s.insert((seg){b[i]+1, it-&gt;r, it-&gt;col}); s.erase(it); s.insert((seg){a[i], b[i], i}); }}inline bool check(int x){ int sum=0; ll cnt=0; for(int i=1, l=1; i&lt;=n; ++i){ sum+=(len[i]=b[i]-a[i]+1); for(auto j:e[i]){ len[j.col]-=j.r-j.l+1; if(j.col &amp;&amp; j.col&gt;=l) sum-=j.r-j.l+1; } while(sum&gt;=x) sum-=len[l], ++l; cnt+=l-1; } return cnt&gt;=k;}inline ll solve(int x){ int sum=0; ll ans=0, cnt=0, now=0; for(int i=1, l=1; i&lt;=n; ++i){ sum+=(len[i]=b[i]-a[i]+1); for(auto j:e[i]){ len[j.col]-=j.r-j.l+1; if(j.col &amp;&amp; j.col&gt;=l) sum-=j.r-j.l+1; if(j.col &amp;&amp; j.col&lt;l) now-=(ll)j.col*(j.r-j.l+1); } while(sum&gt;=x) sum-=len[l], now+=(ll)l*len[l], ++l; ans+=now+(ll)sum*(l-1); cnt+=l-1; } return ans-(ll)(cnt-k)*x;}int main() { read(n), read(k); for(int i=1; i&lt;=n; ++i) read(a[i]), read(b[i]), --b[i]; init(); int l=1, r=1e9, ans=0; while(l&lt;=r){ int mid=(l+r)/2; if(check(mid)) l=mid+1, ans=mid; else r=mid-1; } return printf(&quot;%lld&quot;, solve(ans)), 0;}","link":"/codeforces-1034d-intervals-of-intervals/"},{"title":"「Codeforces 1046B」Hyperspace Highways","text":"Codeforces 1046B 题意给你一张 $n$ 个点 $m$ 条边的无向图，满足每一个简单环上的点两两有边 $q$ 次询问两个点之间的最短路 $n\\le 10^5,m\\le510^5,q\\le210^5$ 做法建圆方树，两个点的距离就是树上距离的一半 时间复杂度 $O(m+q\\log n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;vector&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 100005, M = 500005;int n, m, q, num, cnt, stop, p, stk[N], dfn[N], low[N], h[N], top[N&lt;&lt;1], siz[N&lt;&lt;1], dep[N&lt;&lt;1], fa[N&lt;&lt;1], e[M&lt;&lt;1], pre[M&lt;&lt;1];vector&lt;int&gt; a[N&lt;&lt;1];inline void add(int x, int y){ e[++num]=y, pre[num]=h[x], h[x]=num;}void tarjan(int u){ dfn[u]=low[u]=++cnt; stk[++stop]=u; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa[u]){ if(!dfn[e[i]]){ tarjan(e[i]), low[u]=min(low[u], low[e[i]]); if(low[e[i]]&gt;=dfn[u]){ ++p; a[u].push_back(p); do a[p].push_back(stk[stop]); while(stk[stop--]!=e[i]); } } else low[u]=min(low[u], dfn[e[i]]); }}void dfs1(int u){ siz[u]=1; for(int v:a[u]) fa[v]=u, dep[v]=dep[u]+1, dfs1(v), siz[u]+=siz[v];}void dfs2(int u){ int son=0; for(int v:a[u]) if(siz[v]&gt;siz[son]) son=v; if(son) top[son]=top[u], dfs2(son); for(int v:a[u]) if(v!=son) top[v]=v, dfs2(v);}int main() { read(n), read(m), read(q), p=n; for(int i=1, x, y; i&lt;=m; ++i) read(x), read(y), add(x, y), add(y, x); tarjan(1); dfs1(1), top[1]=1, dfs2(1); while(q--){ static int x, y, ans; read(x), read(y); ans=dep[x]+dep[y]; while(top[x]!=top[y]) if(dep[top[x]]&lt;dep[top[y]]) y=fa[top[y]]; else x=fa[top[x]]; print(ans/2-min(dep[x], dep[y])), print('\\n'); } return flush(), 0;}","link":"/codeforces-1046b-hyperspace-highways/"},{"title":"「Codeforces 1060G」Balls and Pockets","text":"Codeforces 1060G. Balls and Pockets 题意有一个从 $0$ 到 $\\infty$ 的序列，第 $a_1,a_2,\\dotsc,a_n$ 个位置上各有一个口袋 每秒每个口袋会吃掉当前位置上的数，较大的数会向较小的方向移动以填补空位 $m$ 次询问在 $k_i$ 秒后一个位置 $x_i$ 上的数是什么 $a_1&lt; a_2&lt; \\cdots&lt; a_n$ $n,m\\le 10^5, a_i,k_i,x_i\\le 10^9$ 做法考虑每个口袋吃掉的数是不重复的，在无穷远处连续的 $n$ 个数字最终会被不同的口袋吃掉。 可以用平衡树简单模拟这一过程。 求解一组询问 $x_i,k_i$ 时，如果 $x_i&lt;a_1$，这个位置不会改变。 否则 $x_i$ 必然会被上述过程中的恰好一个数字经过。记录下经过的数字设为 $y$，时间为 $t$，即数字 $y$ 在 $t$ 秒后到了 $x_i$ 的位置。 要求 $k_i$ 秒后在 $x_i$ 位置上的数，即 $y$ 在 $t-k_i$ 秒后到达的位置，这可以再进行一遍上述过程求出。 具体描述一下模拟的过程。 假设当前这些数占据了 $[l,l+w-1]$ 的位置，如果不考虑口袋的影响，$1$ 秒后会移动到 $[l-w,l-1]$ 的位置。如果移动多次没有碰到口袋，可以快速计算；如果移动后覆盖了至少一个口袋，可以从后往前依次吃掉，假设吃掉的是第 $e$ 个位置上的数，即当前存在的数中的第 $e-l+1$ 个，可以用平衡树简单维护。 复杂度 $\\mathcal O((n+m)\\log n)$ 代码手写线段树会快很多吧..但是用 pb_ds 抢到了长度第一和速度第二 = = 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#include&lt;ext/pb_ds/assoc_container.hpp&gt;#include&lt;ext/pb_ds/tree_policy.hpp&gt;using namespace std;using namespace __gnu_pbds;#define ll long longconst int N = 100005;int n, m, cnt, a[N];ll ans[N];tree&lt;int,null_type,less&lt;int&gt;,rb_tree_tag,tree_order_statistics_node_update&gt; s;struct query{ ll x; int t, id; inline bool operator&lt;(const query &amp;r)const{ return x&lt;r.x;}} q[N], f[N];int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, a+i); for(int i=1; i&lt;=m; ++i){ ++cnt; scanf(&quot;%lld%d&quot;, &amp;q[cnt].x, &amp;q[cnt].t); if(q[cnt].x&lt;a[1]) ans[i]=q[cnt].x, --cnt; else q[cnt].id=i; } sort(q+1, q+cnt+1); for(int i=0; i&lt;n; ++i) s.insert(i); ll now=1e18, tim=0; int i=n, j=cnt; while(j){ ll x=(now-a[i]-1)/i+1; while(j &amp;&amp; q[j].x&gt;=now-i*x) f[j].x=tim+(now-q[j].x-1)/i+1-q[j].t, f[j].t=*s.find_by_order(i-(now-q[j].x+i-1)%i-1), f[j].id=q[j].id, --j; tim+=x, now-=i*x; while(i &amp;&amp; a[i]&gt;=now) s.erase(s.find_by_order(a[i--]-now)); } sort(f+1, f+cnt+1); s.clear(); for(int i=0; i&lt;n; ++i) s.insert(i); now=1e18, tim=0, i=n, j=1; while(j&lt;=cnt){ ll x=(now-a[i]-1)/i+1; while(j&lt;=cnt &amp;&amp; tim+x&gt;=f[j].x) ans[f[j].id]=now+s.order_of_key(f[j].t)-(f[j].x-tim)*i, ++j; tim+=x, now-=i*x; while(i &amp;&amp; a[i]&gt;=now) s.erase(s.find_by_order(a[i--]-now)); } for(int i=1; i&lt;=m; ++i) printf(&quot;%lld\\n&quot;, ans[i]); return 0;}","link":"/codeforces-1060g/"},{"title":"「Codeforces 1097G」Vladislav and a Great Legend","text":"Codeforces 1097G. Vladislav and a Great Legend 当时不会做 题意给定一棵 $n$ 个点的树 对于每个非空的点集 $X\\subseteq {1,2,\\dotsc,n}$，定义 $f(X)$ 表示最少的能让点集 $X$ 联通的边的数量 求 $$\\sum_{X\\subseteq {1,2,\\dotsc,n},X\\ne \\varnothing} (f(X))^k$$ 模 $10^9+7$ $n\\le 10^5,k\\le 200$ 做法先考虑 $X$ 是树上一个联通子树的点集怎么做 令 $f_{i,j}$ 表示以 $i$ 为根的子树，选择了 $i$ 的所有方案的边数的 $j$ 次和 直接二项式展开，合并两个子树是 $\\mathcal O(k^2)$ 的，总复杂度 $\\mathcal O(nk^2)$ 无法通过此题 考虑令 $f_{i,j}$ 表示以 $i$ 为根的子树，选择了 $i$ 的所有方案的边数的 $j$ 阶下降幂的和 对于下降幂我们有 $$\\begin{align}(x+1)^{\\underline n} &amp; = n! \\binom{x+1}{n} \\&amp; = n!\\left(\\binom{x}{n}+\\binom{x}{n-1}\\right) \\&amp; = x^{\\underline n} + n\\times x^{\\underline {n-1}}\\end{align}$$ $$\\begin{align}(x+y)^{\\underline n} &amp; = n! \\binom{x+y}{n} \\&amp; = n! \\sum_{i=0}^n \\binom{x}{i} \\binom{y}{n-i} \\&amp; = n! \\sum_{i=0}^n \\frac{x^{\\underline i}}{i!} \\times \\frac{y^{\\underline {n-i}}}{(n-i)!} \\&amp; = \\sum_{i=0}^n \\binom{n}{i} x^{\\underline i} y^{\\underline {n-i}}\\end{align}$$ 因此我们可以 $\\mathcal O(k)$ 地加入一条边和 $\\mathcal O(k^2)$ 地合并两个子树 总复杂度还是 $\\mathcal O(nk^2)$ 的，无法通过 由于下降幂的性质，当以 $i$ 为根的子树中的点数不大于 $j$ 时，$f_{i,j}=0$ 我们可以记 $size_i$ 表示以 $i$ 为根的子树的点数，每次合并严格 $\\mathcal O(min{size_x, k}, min{size_y, k})$ 地合并两个子树 $x, y$，注意不能包含 $min{size_x,k}^2$ 合并两个相邻子树 $x,y$ 时，我们选出 $x$ 的子树中 dfs 序最大的 $k$ 个点和 $y$ 的子树中 dfs 序最小的 $k$ 个点，这样每个点最多会对前后 $2k$ 个点形成贡献，于是总复杂度是 $\\mathcal O(nk)$ 最后用斯特林数 $$x^k = \\sum_{i=0}^k \\begin{Bmatrix} k \\ i \\end{Bmatrix} x^{\\underline{i}}$$ 复原出 $k$ 次幂和即可 接下来考虑不是联通子树的情况 定义叶子是联通子树上度为 $1$ 的点，可以发现一个联通子树需要计算 $2^a$ 次，其中 $a$ 是非叶子数量 统计 $i$ 处的答案时，若方案包含了至少两个 $i$ 的儿子， $i$ 就不是叶子，则需要乘系数 $2$，这可以全部计算，最后减去只含一个儿子的情况 做完 $i$ 之后，只要方案包含了至少一个儿子，由于 $i$ 的父亲必须选择，$i$ 就不是叶子，因此把除了 $i$ 单个点的方案都乘 $2$ 即可 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 100005, K = 202, P = 1000000007;int n, k, num, Ans, ans[K], p[K], C[K][K], S[K][K], siz[N], h[N], e[N&lt;&lt;1], pre[N&lt;&lt;1], f[N][K];inline void add(int x, int y){ e[++num]=y, pre[num]=h[x], h[x]=num;}void dfs(int u, int fa=0){ f[u][0]=1; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa){ dfs(e[i], u), siz[u]+=siz[e[i]]; for(int j=min(siz[u], k); j; --j){ f[e[i]][j]=(f[e[i]][j]+(ll)f[e[i]][j-1]*j)%P; ans[j]=(ans[j]-f[e[i]][j]+P)%P; } ++f[e[i]][0]; for(int j=min(siz[u], k); ~j; --j){ f[u][j]=(ll)f[u][j]*f[e[i]][0]%P; for(int t=max(j-siz[e[i]], 0); t&lt;j &amp;&amp; t&lt;=siz[u]-siz[e[i]]; ++t) f[u][j]=(f[u][j]+(ll)f[u][t]*f[e[i]][j-t]%P*C[j][t])%P; } } for(int i=0; i&lt;=k &amp;&amp; i&lt;=siz[u]; ++i) f[u][i]=f[u][i]*2%P; f[u][0]=(f[u][0]-1+P)%P; for(int i=0; i&lt;=k &amp;&amp; i&lt;=siz[u]; ++i) (ans[i]+=f[u][i])%=P; ++siz[u];}int main() { read(n), read(k); C[0][0]=S[0][0]=p[0]=1; for(int i=1; i&lt;=k; ++i) p[i]=p[i-1]*2%P; for(int i=1; i&lt;=k; ++i) for(int j=0; j&lt;=i; ++j){ C[i][j]=(C[i-1][j]+(j?C[i-1][j-1]:0))%P; if(j) S[i][j]=(S[i-1][j-1]+(ll)j*S[i-1][j])%P; } for(int i=1, x, y; i&lt;n; ++i) read(x), read(y), add(x, y), add(y, x); dfs(1); for(int i=0; i&lt;=k; ++i) Ans=(Ans+(ll)ans[i]*S[k][i])%P; return printf(&quot;%d&quot;, Ans), 0;}","link":"/codeforces-1097g/"},{"title":"「Codeforces 1034E」Little C Loves 3 III","text":"Codeforces 1034E 题意给你两个 $2^n$ 的数组 $a_0,..,a_{2^n-1}$ 和 $b_0,..,b_{2^n-1}$ 在模 $4$ 意义下求子集卷积 $n\\le 21$ 做法显然有 $\\mathcal O(n^2 * 2^n)$ 的暴力子集卷积做法 令 $A_{S,k}$ 表示对于 $a$，集合为 $S$，集合大小是 $k$ 的值，$B_{S,k}$ 同理 只有 $A_{S,|S|}=a_S$ 是有效的，其余位置都是无效的 通过限制集合大小来保证转化为集合并卷积之后不会多算 $$f_{X,k}=\\sum_{S\\cup T=X} \\sum_{i+j=k} A_{S,i}B_{T,j}$$ 答案就是每个 $f_{S,|S|}$ 把第二维看成一个形式幂级数，就有 $$f_X(x)=\\sum_{S\\cup T=X} A_S(x) B_T(x)$$ 答案就是 $[x^{|S|}]f_S(x)$ 形式幂级数的加法是 $\\mathcal O(n)$ 的，乘法是 $\\mathcal O(n^2)$ 的，FMT是 $\\mathcal O(n * 2^n)$ 的，总复杂度 $\\mathcal O(n^2 * 2^n)$，无法通过此题 由于这里模数特殊，考虑把系数压到一个unsigned long long中处理，两位恰好存一个系数 于是我们可以 $\\mathcal O(1)$ 地完成加法和乘法，总复杂度 $\\mathcal O(n * 2^n)$，可以通过此题 可能会有进位，但是通过分类处理加法和乘法还是可以完成的 事实上这里并不需要考虑进位的影响，因为 $[x^i]A_S(x)$ 和 $[x^j]B_T$ 会贡献到 $[x^{i+j}]f_{S\\cup T}$，这里总是有 $i+j\\ge |S\\cup T|$，我们需要的是 $[x^{|S\\cup T|}]f_{S\\cup T}$，进位是不会对最低位产生影响的 所以直接+和*就好了 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ull unsigned long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 1&lt;&lt;21;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 1&lt;&lt;21, M = 22;int n, cnt[N];ull a[N], b[N];int main() { read(n); for(int i=1; i&lt;1&lt;&lt;n; ++i) cnt[i]=cnt[i^(i&amp;-i)]+2; char x; while(isspace(x=read())); for(int i=0; i&lt;1&lt;&lt;n; ++i) a[i]=(ull)(x-'0')&lt;&lt;cnt[i], x=read(); while(isspace(x=read())); for(int i=0; i&lt;1&lt;&lt;n; ++i) b[i]=(ull)(x-'0')&lt;&lt;cnt[i], x=read(); for(int i=0; i&lt;n; ++i) for(int j=0; j&lt;1&lt;&lt;n; ++j) if(j&gt;&gt;i&amp;1) a[j]+=a[j^(1&lt;&lt;i)], b[j]+=b[j^(1&lt;&lt;i)]; for(int i=0; i&lt;1&lt;&lt;n; ++i) a[i]*=b[i]; for(int i=0; i&lt;n; ++i) for(int j=0; j&lt;1&lt;&lt;n; ++j) if(j&gt;&gt;i&amp;1) a[j]-=a[j^(1&lt;&lt;i)]; for(int i=0; i&lt;1&lt;&lt;n; ++i) print((char)('0'+(a[i]&gt;&gt;cnt[i]&amp;3))); return flush(), 0;}","link":"/codeforces-1034e-little-c-loves-3-iii/"},{"title":"「Codeforces 1063F」String Journey","text":"第一篇算法相关 第一次自己想sam Codeforces 1063F 题意给出一个长度为$n$的字符串$s$。 如果一个字符串序列$t_1,\\dotsc,t_k$，$\\forall1&lt;i\\le k$，$t_i$是$t_{i-1}$的一个子串，且长度严格小，那么称这个字符串序列是一个journey。 一个journey的长度是其中字符串的数量 求最长的journey，满足存在字符串序列$u_1,\\dotsc,u_{k+1}$(可以为空)，使$s=u_1t_1u_2t_2\\cdots u_kt_ku_{k+1}$。 分析 观察：存在最长的journey $t$，满足$|t_i|=|t_{i-1}|-1$，即长度每次减少1 显然 这可以通过删减一定字符得到 观察：若存在以$s$中的第$i$个位置开头的长度为$k$的journey，那么存在以该位置开头的长度为$t，1\\le t\\le k$的journey 这也可以删除一定字符得到 然后考虑从右向左dp，令$f_i$表示以$s$中第$i$个位置开头的最长的journey的长度。 $f_i$是可以二分的，但是并不好检验 观察：$f_{i+1}\\ge f_i-1$ 这也可以通过删除一定字符得到 移项得$f_i\\le f_{i+1}+1$ 因此不需要二分，由于均摊的性质，直接推下来，总检验次数是线性的 观察：在dp过程中，能被转移的位置$(\\ge i+f_i-1)$单调不严格左移 在从$i+1$转移到$i$时，能被转移的位置不变：$i+f_i=i+f_{i+1}-1=(i+1)+f_{i+1}$ 在检验$f_i$失败的时候，$f_i$减小，$i+f_i-1$也减小 于是需要数据结构维护 插入一个位置 检验是否有位置$j$与当前的$i$满足最长公共前缀$lcp(s[i..n],s[j..n])\\ge f_i-1$，且$f_j\\ge f_i-1$ 考虑使用sam+线段树 对$s$的反串建sam，插入一个位置$p$的时候，从这个位置对应的parent树终止节点向上跳到最深的一个能表示出长度$f_p$的节点$u$，($len_u\\ge f_p$，$len_u$表示$u$能表示的最长字符串)。 $u$子树中所有的节点表示的串和$u$的最长公共前缀$\\ge f_p-1$。 并且对于$u$的任意祖先$v$，$v$的子树中所有节点表示的串和$u$的最长公共前缀$\\ge len_v$。 这些可以转化到dfs序上的区间取max，用线段树维护 而检验一个$f_p$的时候只要查询覆盖i对应的终止节点处的最大值是否$\\ge f_p-1$ 考虑到更新$u$的祖先$v$的时候复杂度并不优秀，但是更新的值是$len_v$，这只和$v$自身有关，打个标记避免重复，可以做到$\\mathcal O(n)$次 字符集大小为常数，总复杂度$\\mathcal O(n\\log n)$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;vector&gt;using namespace std;#define ll long longconst int N = 500005;int n, cnt, last, pl, pr, idfn, ans, f[N], g[N], dfn[N&lt;&lt;1], rdfn[N&lt;&lt;1], fa[N&lt;&lt;1], len[N&lt;&lt;1], w[N&lt;&lt;3], ch[N&lt;&lt;1][26];bool vis[N&lt;&lt;1];char s[N];vector&lt;int&gt; e[N&lt;&lt;1];inline void extend(int c){ int p=last, np=++cnt; last=cnt, len[np]=len[p]+1; while(p &amp;&amp; !ch[p][c]) ch[p][c]=np, p=fa[p]; if(!p) fa[np]=1; else{ int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else{ int nq=++cnt; len[nq]=len[p]+1, memcpy(ch[nq], ch[q], 26&lt;&lt;2); fa[nq]=fa[q], fa[q]=fa[np]=nq; while(ch[p][c]==q) ch[p][c]=nq, p=fa[p]; } }}void change(int l, int r, int t, int L, int R, int x){ if(L&lt;=l &amp;&amp; r&lt;=R) return (void)(w[t]=max(w[t], x)); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; if(L&lt;=mid) change(l, mid, k, L, R, x); if(R&gt;mid) change(mid+1, r, k|1, L, R, x);}int query(int l, int r, int t, int x){ if(l==r) return w[t]; int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; return max(w[t], x&lt;=mid?query(l, mid, k, x):query(mid+1, r, k|1, x));}inline bool check(int x){ return query(1, cnt, 1, dfn[pl])&gt;=x-1 || query(1, cnt, 1, dfn[pr])&gt;=x-1;}inline void dfs(int x){ dfn[x]=++idfn; for(int i:e[x]) dfs(i); rdfn[x]=idfn;}inline void solve(int x){ if(vis[x] || x&lt;=1) return; vis[x]=1; change(1, cnt, 1, dfn[x], rdfn[x], len[x]); solve(fa[x]);}int main() { scanf(&quot;%d%s&quot;, &amp;n, s+1); last=cnt=1; for(int i=n; i; --i) extend(s[i]-'a'); for(int i=2; i&lt;=cnt; ++i) e[fa[i]].push_back(i); dfs(1); g[n+1]=pl=pr=1; for(int i=n; i; --i){ pr=pl, pl=ch[pl][s[i]-'a']; f[i]=f[i+1]+1; while(!check(f[i])){ --f[i]; change(1, cnt, 1, dfn[g[i+f[i]]], rdfn[g[i+f[i]]], f[i+f[i]]); solve(fa[g[i+f[i]]]); } ans=max(ans, f[i]); g[i]=ch[g[i+1]][s[i]-'a']; while(len[fa[g[i]]]&gt;=f[i]) g[i]=fa[g[i]]; } return printf(&quot;%d&quot;, ans), 0;}","link":"/codeforces-1063f-string-journey/"},{"title":"「Codeforces 573C」Bear and Drawing","text":"失去思维能力 Codeforces 573C 题意给出$n$个点的树，问能否边不相交地画在两行平行的点上，$n\\le 10^5$ 分析问题可以转化为以下条件 有一条主链，主链上的点无度数限制 和主链直接相连的点的度数$\\le 3$ 其他点度数$\\le 2$ 实现只考虑度数$\\le 2$的点，把和度数$=1$的叶子连通的这些点全部删掉。 重新统计度数 把原先度数$=3$的点，新度数$=1$的点删掉 重新统计度数 这时候应该只剩下一条主链，检验是否有点的度数$&gt;2$即可 复杂度 $\\mathcal O(n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) { if (c == '-') iosig = true; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x + (x &lt;&lt; 2)) &lt;&lt; 1) + (c ^ '0'); if (iosig) x = -x;}const int N = 100005;int n, ans, num, tot, h[N], d[N], dd[N], e[N&lt;&lt;1], pre[N&lt;&lt;1];bool vis[N];inline void add(int x, int y){ e[++num]=y, pre[num]=h[x], h[x]=num;}void dfs(int u){ vis[u]=1; for(int i=h[u]; i; i=pre[i]) if(d[e[i]]==2 &amp;&amp; !vis[e[i]]) dfs(e[i]);}int main() { read(n); for(int i=1; i&lt;n; ++i){ static int x, y; read(x), read(y); add(x, y), add(y, x), ++d[x], ++d[y]; } for(int i=1; i&lt;=n; ++i) if(d[i]==1) dfs(i); memcpy(dd, d, sizeof d); for(int i=1; i&lt;=n; ++i) if(vis[i]) for(int j=h[i]; j; j=pre[j]) --d[e[j]]; for(int i=1; i&lt;=n; ++i) if(dd[i]==3 &amp;&amp; d[i]==1) for(int j=h[i]; j; j=pre[j]) --d[e[j]]; int mx=0; for(int i=1; i&lt;=n; ++i) mx=max(mx, d[i]); return puts(mx&lt;=2?&quot;Yes&quot;:&quot;No&quot;), 0;}","link":"/codeforces-573c-bear-and-drawing/"},{"title":"「Codeforces 1090H」Linearization","text":"Codeforces 1090H. Linearization 题意定义一个长度为 $n(n=2^k,k\\in N)$ 的 01 串 $s$（从 0 开始标号）是线性的，当且仅当存在整数 $x$ 和 二进制数位 $b$，使得 $\\forall i\\in [0,n),s_i=P(i{\\rm and}x){\\rm xor}b$，其中 $P(a)$ 表示 $a$ 的二进制表示中 $1$ 的数量的奇偶性 定义一个 01 串的线性化难度为，进行最少的取反一个区间的操作，使之成为线性的操作次数 给定一个长度为 $m$ 的 01 串 $t$，$q$ 次询问指定一个子串，要求计算其线性化难度 $m,q\\le 2\\times 10^5$ 做法看了 毛子语的试题分析 才会 先考虑一个长度为 $2^k$ 的 01 串 $s$ 是线性的等价条件 把 $s$ 分成两个 $2^{k-1}$ 的串： 两部分都是线性的 两部分相等或相反 考虑差分，令 $t_i=s_i{\\rm xor}s_{i-1},1\\le i &lt; 2^k$ 于是上述限制转化为 $\\forall i\\in [1,2^{k-1}),t_i=t_{i+2^{k-1}}$，并且递归两侧 理性分析一下 递归保证了两部分都是线性的 两部分相等或相反即最左侧的位置相同或不同，只考虑剩余的位即可 这些限制把 $2^k-1$ 个位置划分为若干联通块，联通块内的位置要全都相等，此时贪心地取 $0$ 和 $1$ 中较少的一个改变即可 假设求出最后最少需要改变的 $t$ 序列中的位置有 $a$ 个，答案即为 $\\lfloor \\frac{a+1}{2} \\rfloor$，因为每次区间取反可以改变 $2$ 个位置 直接做显然无法通过，观察一下联通块可以发现 只有 $k$ 个联通块，第 $i$ 个联通块是以 $2^{i-1}$ 开头的步长为 $2^i$ 的等差数列 直接预处理即可 复杂度 $\\mathcal O((m+q)\\log m)$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 200005, M = 18;int n, q, f[M][N];char s[N];int main() { read(n); while(isspace(s[0]=read())); for(int i=1; i&lt;n; ++i) s[i]=read(); for(int i=n; --i;) s[i]^=s[i-1]; for(int i=1; 1&lt;&lt;i&lt;n; ++i){ for(int j=0; j&lt;1&lt;&lt;i; ++j) f[i][j]=s[j]; for(int j=1&lt;&lt;i; j&lt;n; ++j) f[i][j]=f[i][j-(1&lt;&lt;i)]+s[j]; } read(q); while(q--){ int l, r, len, now, ans=0; read(l), read(r), now=r, len=r-l+1; for(int i=1; 1&lt;&lt;i&lt;len; ++i){ int x=f[i][now]-(now&gt;=len?f[i][now-len]:0); ans+=min(x, len/(1&lt;&lt;i)-x), now-=1&lt;&lt;(i-1); } print((ans+1)/2), print('\\n'); } return flush(), 0;}","link":"/codeforces-1090h/"},{"title":"「Codeforces 662C」Binary Table","text":"Codeforces 662C 题意给出一个$n$行$m$列的$01$矩阵，可以任意次取反一行或一列，最小化矩阵中$1$的总数 $n\\le20,m\\le10^5$ 分析由于 $n$ 非常小，考虑状压，把 $m$ 列看成 $m$ 个 $n$ 位二进制数 同时也用一个 $n$ 位二进制数 $s$ 表示取反了的行 对于一个被表示为 $x$ 的列 若不选择取反，对答案的贡献是 ${\\rm popcount}(x \\oplus s)$ 其中 ${\\rm popcount}(t)$ 表示 $t$ 二进制中为 $1$ 的位数，$\\oplus$ 表示异或 若取反，则为 $n-{\\rm popcount}(x \\oplus s)$。 由于列之间是独立的，可以贪心选择，记 $g_i=\\min({\\rm popcount}(i),n-{\\rm popcount}(i))$ 记$f_i$表示$m$个数中$i$的数量 对于一种选择 $s$，答案是 $$\\sum_{i=0}^{2^n-1}f_i\\cdot g_{i \\oplus s}$$ 即 $$\\sum_{i \\oplus j=s}f_i\\cdot g_j$$ 使用 FWT 完成这个异或卷积 复杂度 $\\mathcal O(nm+n\\times 2^n)$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) { if (c == '-') iosig = true; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x + (x &lt;&lt; 2)) &lt;&lt; 1) + (c ^ '0'); if (iosig) x = -x;}const int N = 22, M = 100005, K = 1&lt;&lt;20;int n, m, a[M];ll f[K], g[K];inline void FWT(ll *f, int g, int len=1&lt;&lt;n){ for(int i=1; i&lt;len; i&lt;&lt;=1) for(int j=0; j&lt;len; j+=i&lt;&lt;1) for(int k=j; k&lt;j+i; ++k){ ll x=f[k], y=f[k+i]; f[k]=x+y, f[k+i]=x-y; } if(g==-1) for(int i=0; i&lt;len; ++i) f[i]&gt;&gt;=n;}int main() { read(n), read(m); for(int i=0; i&lt;n; ++i){ char ch; while(isspace(ch=read())); for(int j=0; j&lt;m; ++j, ch=read()) a[j]=a[j]&lt;&lt;1|(ch^'0'); } for(int i=0; i&lt;m; ++i) ++f[a[i]]; for(int i=1; i&lt;1&lt;&lt;n; ++i) g[i]=g[i^(i&amp;-i)]+1; for(int i=0; i&lt;1&lt;&lt;n; ++i) g[i]=min(g[i], n-g[i]); FWT(f, 1), FWT(g, 1); for(int i=0; i&lt;1&lt;&lt;n; ++i) f[i]*=g[i]; FWT(f, -1); int ans=1e9; for(int i=0; i&lt;1&lt;&lt;n; ++i) ans=min(ans, (int)f[i]); return printf(&quot;%d&quot;, ans), 0;}","link":"/codeforces-662c-binary-table/"},{"title":"「Codeforces 755G」PolandBall and Many Other Balls","text":"Codeforces 755G. PolandBall and Many Other Balls 题意有 $n$ 个球编号为 $1,2,\\dotsc,n$，一组可以是一个球 ${i}$ 或者是两个相邻的球 ${i,i+1}$ 对于 $i=1,2,\\dotsc,k$ 求 $n$ 个球划分成 $i$ 组的方案数，每个球至多在一个组内，并且可以不在任何一个组内 对 $998244353$ 取模 $n\\le 10^9,k\\le 2^{15}$ 做法显然有 $\\mathcal O(nk)$ 的 dp 做法 令 $f_{i,j}$ 表示前 $i$ 个球分成 $k$ 组的方案数 转移是 $$f_{i,j}=f_{i-1,j}+f_{i-1,j-1}+f{i-2,j-1}$$ 用生成函数表示第二维，有 $$f_i(x)=f_{i-1}(x)+x\\cdot f_{i-1}(x)+x\\cdot f_{i-2}(x)$$ 矩阵这个东西可以矩阵转移 $$\\begin{bmatrix}x+1 &amp; x \\1 &amp; 0\\end{bmatrix}\\begin{pmatrix}f_i(x) \\f_{i-1}(x)\\end{pmatrix}\\begin{pmatrix}f_{i+1}(x) \\f_i(x)\\end{pmatrix}$$ 快速幂一下就好了 复杂度 $\\mathcal O(k\\log k\\log n)$ 倍增上述算法写得不好就被卡常了，直接倍增常数小得多 大概要讨论一下最中间的几个球的情况，没写 复杂度还是 $\\mathcal O(k\\log k\\log n)$ 通项写出递推关于 $z$ 特征方程 $$z^2=(x+1)z+x$$ 其中系数是多项式 解得 $$\\begin{align}z_0&amp;=\\frac{x+1-\\sqrt{x^2+6x+1}}{2} \\z_1&amp;=\\frac{x+1+\\sqrt{x^2+6x+1}}{2}\\end{align}$$ 因此 $f_n(x)$ 可以被表示为 $A z_0^n+B z_1^n$ 根据 $$\\begin{cases}f_0(x) = A+B =1 \\f_1(x) = A z_0 + B z_1 = x+1\\end{cases}$$ 解得 $$\\begin{cases}A=\\frac{-x-1+\\sqrt{x^2+6x+1}}{2\\sqrt{x^2+6x+1}} \\B=\\frac{x+1+\\sqrt{x^2+6x+1}}{2\\sqrt{x^2+6x+1}}\\end{cases}$$ 事实上由于 $z_0$ 和 $A$ 的常数项为 $0$，$A z_0^n$ 对答案的前 $n$ 项没有影响，而答案除了前 $n$ 项都为 $0$，可以特判后忽略这部分 于是 $$\\begin{align}f_n(x) &amp;\\equiv B z_1^n &amp;\\pmod{x^{n+1}} \\&amp;= \\frac{z_1^{n+1}}{\\sqrt{x^2+6x+1}} &amp;\\end{align}$$ 直接做复杂度也是 $\\mathcal O(k\\log k\\log n)$，常数想必更小 由于这里 $z_1$ 的常数项为 $1$，可以方便地用 $\\ln$ 和 $\\exp$ 计算 总复杂度 $\\mathcal O(k\\log k)$ 代码矩乘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ll long longconst int N = 1&lt;&lt;15, M = N&lt;&lt;1, P = 998244353;int n, k, w[M];vector&lt;int&gt; ans;inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}inline void DFT(vector&lt;int&gt; &amp;f, int n){ static unsigned ll F[M]; for(int i=0, j=0; i&lt;n; ++i){ F[i]=f[j]; for(int k=n&gt;&gt;1; (j^=k)&lt;k; k&gt;&gt;=1); } for(int i=1; i&lt;n; i&lt;&lt;=1) for(int j=0; j&lt;n; j+=i&lt;&lt;1) for(int k=j; k&lt;j+i; ++k){ int t=F[k+i]*w[i+k-j]%P; F[k+i]=F[k]+P-t, F[k]+=t; } for(int i=0; i&lt;n; ++i) f[i]=F[i]%P;}inline void IDFT(vector&lt;int&gt; &amp;f, int n){ reverse(f.begin()+1, f.end()), DFT(f, n); for(int i=0, I=Pow(n); i&lt;n; ++i) f[i]=(ll)f[i]*I%P;}inline int Calc(int x){ int ans=1; while(ans&lt;=x) ans&lt;&lt;=1; return ans;}inline vector&lt;int&gt; operator *(const vector&lt;int&gt; &amp;x, const vector&lt;int&gt; &amp;y){ if(!x.size() || !y.size()){ vector&lt;int&gt; a; return a.push_back(0), a; } vector&lt;int&gt; a=x, b=y; int n=Calc(x.size()+y.size()-2); a.resize(n), b.resize(n), DFT(a, n), DFT(b, n); for(int i=0; i&lt;n; ++i) a[i]=(ll)a[i]*b[i]%P; IDFT(a, n); return a.resize(min((int)x.size()+(int)y.size()-1, k+1)), a;}inline void operator *=(vector&lt;int&gt; &amp;x, const vector&lt;int&gt; &amp;y){ x=x*y;}inline vector&lt;int&gt; operator +(const vector&lt;int&gt; &amp;x, const vector&lt;int&gt; &amp;y){ vector&lt;int&gt; ans=x; if(y.size()&gt;x.size()) ans.resize(y.size()); for(unsigned i=0; i&lt;y.size(); ++i) (ans[i]+=y[i])%=P;// return ans;}inline void operator +=(vector&lt;int&gt; &amp;x, const vector&lt;int&gt; &amp;y){ x=x+y;}struct matrix{ vector&lt;int&gt; a[2][2]; inline matrix operator *(const matrix &amp;rhs)const{ matrix ans; for(int i=0; i&lt;2; ++i) for(int k=0; k&lt;2; ++k) for(int j=0; j&lt;2; ++j) ans.a[i][j]+=a[i][k]*rhs.a[k][j]; return ans; }} A;inline matrix Pow(matrix x, int y){ matrix ans=x; --y; for(; y; y&gt;&gt;=1, x=x*x) if(y&amp;1) ans=ans*x; return ans;}int main() { for(int i=1; i&lt;M; i&lt;&lt;=1){ w[i]=1, w[i+1]=Pow(3, (P-1)/i/2); for(int j=2; j&lt;i; ++j) w[i+j]=(ll)w[i+j-1]*w[i+1]%P; } scanf(&quot;%d%d&quot;, &amp;n, &amp;k); A.a[0][0]={1, 1}, A.a[0][1]={0, 1}, A.a[1][0]={1}; A=Pow(A, n), ans=A.a[1][0]*vector&lt;int&gt;{1,1}+A.a[1][1]; for(int i=1; i&lt;=k; ++i) printf(&quot;%d &quot;, i&gt;n?0:ans[i]); return 0;} 通项纯手写 刚刚卡了下常数还是没最快= = 数组迭代实现好快= = 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ll long longconst int OUT_LEN = 1000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 1&lt;&lt;15, M = N&lt;&lt;1, P = 998244353;int n, k, w[M], inv[M];inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}inline void DFT(vector&lt;int&gt; &amp;f, int n){ static unsigned ll F[M]; for(int i=0, j=0; i&lt;n; ++i){ F[i]=f[j]; for(int k=n&gt;&gt;1; (j^=k)&lt;k; k&gt;&gt;=1); } for(int i=1; i&lt;n; i&lt;&lt;=1) for(int j=0; j&lt;n; j+=i&lt;&lt;1){ int *W=w+i; unsigned ll *F0=F+j, *F1=F+j+i; for(int k=j; k&lt;j+i; ++k, ++W, ++F0, ++F1){ int t=*F1**W%P; *F1=*F0+P-t, *F0+=t; } } for(int i=0; i&lt;n; ++i) f[i]=F[i]%P;}inline void IDFT(vector&lt;int&gt; &amp;f, int n){ reverse(f.begin()+1, f.end()), DFT(f, n); for(int i=0, I=Pow(n); i&lt;n; ++i) f[i]=(ll)f[i]*I%P;}inline int Calc(int x){ int ans=1; while(ans&lt;=x) ans&lt;&lt;=1; return ans;}inline vector&lt;int&gt; operator *(const vector&lt;int&gt; &amp;x, const vector&lt;int&gt; &amp;y){ if(!x.size() || !y.size()) return {0}; if((unsigned ll)x.size()*y.size()&lt;=1&lt;&lt;8){ vector&lt;int&gt; ans(x.size()+y.size()-1); for(unsigned i=0; i&lt;x.size(); ++i) for(unsigned j=0; j&lt;y.size(); ++j) ans[i+j]=(ans[i+j]+(ll)x[i]*y[j])%P; return ans; } vector&lt;int&gt; a=x, b=y; int n=Calc(x.size()+y.size()-2); a.resize(n), b.resize(n), DFT(a, n), DFT(b, n); for(int i=0; i&lt;n; ++i) a[i]=(ll)a[i]*b[i]%P; IDFT(a, n); return a.resize(min((int)x.size()+(int)y.size()-1, k+1)), a;}inline void operator *=(vector&lt;int&gt; &amp;x, const vector&lt;int&gt; &amp;y){ x=x*y;}inline vector&lt;int&gt; operator +(const vector&lt;int&gt; &amp;x, const vector&lt;int&gt; &amp;y){ vector&lt;int&gt; ans=x; if(y.size()&gt;x.size()) ans.resize(y.size()); for(unsigned i=0; i&lt;y.size(); ++i) (ans[i]+=y[i])%=P; return ans;}inline void operator +=(vector&lt;int&gt; &amp;x, const vector&lt;int&gt; &amp;y){ x=x+y;}inline vector&lt;int&gt; operator -(const vector&lt;int&gt; &amp;x, const vector&lt;int&gt; &amp;y){ vector&lt;int&gt; ans=x; if(y.size()&gt;x.size()) ans.resize(y.size()); for(unsigned i=0; i&lt;y.size(); ++i) (ans[i]+=P-y[i])%=P; return ans;}inline vector&lt;int&gt; PolyDiv2(const vector&lt;int&gt; &amp;x){ vector&lt;int&gt; ans(x.size()); for(unsigned i=0; i&lt;x.size(); ++i) ans[i]=(x[i]&amp;1?x[i]+P:x[i])&gt;&gt;1; return ans;}inline vector&lt;int&gt; Ext(const vector&lt;int&gt; &amp;a, int n){ if(n&lt;=(int)a.size()) return vector&lt;int&gt;(a.begin(), a.begin()+n); vector&lt;int&gt; ans=a; return ans.resize(n), ans;}vector&lt;int&gt; PolyInv(const vector&lt;int&gt; &amp;a, int n=-1){ if(n==-1) n=a.size(); if(n==1) return {Pow(a[0])}; vector&lt;int&gt; ans=PolyInv(a, (n+1)/2), tmp=Ext(a, n); int m=Calc(n*2-1); ans.resize(m), tmp.resize(m), DFT(ans, m), DFT(tmp, m); for(int i=0; i&lt;m; ++i) ans[i]=(2+(ll)(P-tmp[i])*ans[i])%P*ans[i]%P; IDFT(ans, m); return ans.resize(n), ans;}vector&lt;int&gt; PolySqrt(const vector&lt;int&gt; &amp;a, int n=-1){ if(n==-1) n=a.size(); if(n==1) return {1}; vector&lt;int&gt; ans=PolySqrt(a, (n+1)/2); return PolyDiv2(Ext(ans+Ext(a, n)*PolyInv(Ext(ans, n)), n));}inline vector&lt;int&gt; D(const vector&lt;int&gt; &amp;a){ vector&lt;int&gt; ans(a.size()-1); for(unsigned i=1; i&lt;a.size(); ++i) ans[i-1]=(ll)a[i]*i%P; return ans;}inline vector&lt;int&gt; Int(const vector&lt;int&gt; &amp;a){ vector&lt;int&gt; ans(a.size()+1); for(unsigned i=0; i&lt;a.size(); ++i) ans[i+1]=(ll)a[i]*inv[i+1]%P; return ans;}inline vector&lt;int&gt; PolyLn(const vector&lt;int&gt; &amp;a){ return Int(Ext(D(a)*PolyInv(a), a.size()-1));}vector&lt;int&gt; PolyExp(const vector&lt;int&gt; &amp;a, int n=-1){ if(n==-1) n=a.size(); if(n==1) return {1}; vector&lt;int&gt; ans=PolyExp(a, (n+1)/2); return Ext(ans*(Ext(a, n)-PolyLn(Ext(ans, n))+vector&lt;int&gt;{1}), n);}int main() { for(int i=1; i&lt;M; i&lt;&lt;=1){ w[i]=1, w[i+1]=Pow(3, (P-1)/i/2); for(int j=2; j&lt;i; ++j) w[i+j]=(ll)w[i+j-1]*w[i+1]%P; } inv[1]=1; for(int i=2; i&lt;M; ++i) inv[i]=(ll)(P-P/i)*inv[P%i]%P; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); vector&lt;int&gt; s={1, 6, 1}, c; s.resize(k+1), s=PolySqrt(s); c=PolyLn(PolyDiv2(vector&lt;int&gt;{1, 1}+s)); for(int &amp;i:c) i=(ll)i*(n+1)%P; c=PolyExp(c)*PolyInv(s); for(int i=1; i&lt;=k; ++i) (i&gt;n?print('0'):print(c[i])), print(' '); return flush(), 0;}","link":"/codeforces-775g/"},{"title":"修电脑杂记","text":"修电脑是生活的一部分。 本文不定期更新。 2022.8.4 移动硬盘寒假时候一块机械硬盘通着电掉到了地上，直接坏了，数据也不怎么能恢复，于是又买了一块，因为电脑在修，移动硬盘上还存着 BBC 的 “Pride and Prejudice”，就拿扩展坞连着 iPad 看。iPad 没有外置存储安全弹出的机制，一次拔出就让硬盘上只剩下了一部 “Green Book”，所有所有其他文件都再索引不到，尽管看到一半的剧拖进度条还能跳，说明硬盘的某些数据并没损坏而且可以正常读取，但因为技术不够并没有恢复出来。格式化之后似乎仍可以正常使用。再也不会拿移动硬盘接扩展坞或者 iPad 了。 经此一役，一些存了五六年的文件也终于丢失，对一个试图让一切留下痕迹的人的打击不可谓不沉痛。Life goes on, 再重新开始吧。 2022.7.26 自动关机在打开原神、Witcher 3 等游戏的状态自动关机，在 Windows 事件查看器中第一个异常事件是 Kernel-Power 的事件 86，内容如下： 1234由于严重的热事件，系统已关闭。关闭时间 = 2022 - 07 - 26T14:11:12.336401600Z高级配置和电源接口热区域 = Intel(R) Innovation Platform Framework: BAT0_CRT = 400K 已经是第十几次遇见，尚未解决。 Update 2022.7.27： 戴尔技术支持人员比预期的好一些，可惜仍然无法解决问题，不过在检查是否是多显示器引起的问题时定位到问题其实是由有线网卡引起的，不插网线改用 WiFi 就不会自动关机（尽管温度也很高）。目前打算将就使用 WiFi，未来遇到必须使用网线的场景再考虑重装系统或者送修。 PS：这电脑的有线网卡也是绝了，堪比上一台联想的无线网卡，约等于不能用，区别是后者只是不能上网，前者能上网却会导致系统故障。 对话记录 Cekavis: 您好，我的电脑是Dell G15 5520，服务编号是XXXXXXX，现在遇到了运行大型游戏时电脑自动关机的问题，就像是手动执行了关机，并不是突然黑屏或死机。已经遇到过十几次，会导致问题的游戏至少有三种，因此我认为可能是电脑本身的问题，在 Windows 事件查看器中第一个异常事件是 Kernel-Power 的事件 86，内容如下： 由于严重的热事件，系统已关闭。 关闭时间 = 2022 - 07 - 26T14:11:12.336401600Z 高级配置和电源接口热区域 = Intel(R) Innovation Platform Framework: BAT0 _CRT = 400K 室温不到30℃，风扇正常运行，在AIDA64和HWiNFO看到部分CPU传感器温度有时超过90℃，未到达100℃，且自动关机前并无任何卡顿、温度异常等现象。电脑今年3月在京东一家专卖店购买的，选择的是由店家升级硬盘和内存的配置，因此SSD和内存是更换过的（该SSD还经常触发英特尔傲腾的SMART事件警告，查看详细信息也是过热的问题，在稍微密集的读写时就会报警）。该自动关机的问题出现之前我还自行加装了一条内存，与原先店家给我安装的（单通道）内存不是同一品牌，但是频率相同。 电脑无其它异常情况。 戴尔技术支持: 小戴正在努力为您转接在线工程师🏻‍🔧🏻‍🔧。由于目前咨询人数较多，等待时间可能较长，如果您还有其它问题，可以尝试使用微信底部【自助菜单】解决您的问题。感谢您的理解和耐心等待...小戴正在积极转接中....... 戴尔技术支持: 您好，现已为您转入人工服务，不好意思让您久等了。这里是戴尔微信技术支持1532号小编，很高兴为您服务\\~查到您的机器是DELL G15 5520对吗？小编这边看到您机器遇到的问题是电脑运行游戏自动关机呢 戴尔技术支持: 实在是非常的抱歉给您的使用添麻烦啦 那这边情况呢是可能是您的温度和显卡导致的该情况，温度的情况呢 一般是两个原因造成的呢 一个是电脑的散热故障 一个呢 是外界因素影响呢 那这样哈 咱们这边做一下硬件检测 看看具体内部温度和散热情况哈 戴尔技术支持: 麻烦您嘈杂一下硬件检测，然后您操作完先不要退出该页面哈，麻烦拍一张照片给小编确认 硬件检测方法：请您连接好电源适配器，开机看到Dell Logo前就马上反复敲击F12, 选中Diagnostics或Enter Epsa选项, 回车, 进行硬件测试。如果看到全屏彩色条纹出现时, 请及时按 Y 键继续, 然后等等看是否有报错信息。 Cekavis: 好的，正在做检测 戴尔技术支持: 嗯嗯，您操作完给小编拍一张照片确认一下哈 Cekavis: [图片] Cekavis: 不好意思，之前提供的服务编号有些问题 戴尔技术支持: 麻烦您点击一下左下角的箭头，然后进入页面点击system开头的，然后点击health给小编拍一张照片哈 Cekavis: [图片] Cekavis: [图片] 戴尔技术支持: 您这边最高温度才81°，您可以不用担心的哈，麻烦您点击exit会退出该页面然后您复制以下链接到浏览器进行下载安装哈 显卡驱动：https://dl.dell.com/FOLDER08602677M/1/NVIDIA-GeForce-RTX-3070-Graphics-Driver_W7DX4_WIN_30.0.15.1272_A03.EXE 散热驱动：https://dl.dell.com/FOLDER08227480M/2/Intel-Dynamic-Tuning-Driver_D39FK_WIN64_9.0.10705.25772_A04_01.EXE BIOS驱动：https://dl.dell.com/FOLDER08602782M/1/Dell_G15_5520_5521_G16_7620_1.8.0.exe（先点击update，然后点击restart，电脑会重启等待重启就行了哈） 戴尔技术支持: 您运行游戏的时候可以点击fn+f9开启g模式哈，如果无法开启直接点击f9 戴尔技术支持: 实在是抱歉，您的机器享有基础保修服务，我们基础保修服务的人工客服小编服务时间为： 周一至周五 ：9:00 - 21:00 周六周日：9:00-18.00法定节假日休息 有什么问题辛苦您在服务时间内进线呢，服务时间外您的信息会被系统拦截呢 戴尔技术支持: 感谢您选择戴尔微信技术支持，本条消息为自动发送。针对您刚刚咨询的机器: XXXXXXX，我们已为您创建案例编号，编号为 147556810。您可以在联系我们时提供这个编号作为参考, 我们将会继续协助您处理您遇到的问题，谢谢您的配合。 Cekavis: 谢谢！麻烦您了！ 戴尔技术支持: 您好，打扰您了，您这边操作完进入游戏运行后是否还会出现一样的情况呢？辛苦您的反馈了哈 Cekavis: 还是一样的问题。实际上玩部分游戏时检测到的“CPU封装”温度可以达到103℃ 戴尔技术支持: 您这边是使用什么软件进行检测的呢？ Cekavis: HWiNFO 戴尔技术支持: 十分的抱歉，第三方软件的检测数据是只能用于参考的哈，小编这边在硬件检测查看您电脑温度是比较准确的哈，您运行的时候还是会出现黑屏的话，小编这边在带您具体检测一下哈 戴尔技术支持: 您是否有开启独显直连呢？ Cekavis: 噢我现在是两个显示器，笔记本自带的显示器和一个外接到HDMI的显示器，自带显示器连接到核显，外界显示器连接到独显 戴尔技术支持: 您是运行什么游戏的时候出现该情况的呢？ Cekavis: 遇到问题的游戏有原神、巫师3、微软模拟飞行 Cekavis: 需要我断开外接显示器试试问题是否存在吗？ 戴尔技术支持: 嗯嗯，您这边先断开显示器，然后您再进行测试哈 Cekavis: 现在是独显直连，暂时没有出现问题（有可能只是负载变小不过热了 戴尔技术支持: 好的呢，小编这边建议您可以不外接显示屏进行操作哈，您也可以尝试一下该方法操作一下，您在外接哈，建议您把游戏效果调到比较低配置的哦 机器现有的配置上面这些优化希望对您有帮助 1. 接入电源充电器使用 2 然后电源模式选择高性能（右键桌面右下角的电源图标--电源选项--选择高性能，假如没有，可以点击左边添加更多电源计划，选择高性能，命名后下一步，然后确定） 2. 关闭xbox录屏功能 游戏的垂直同步和调低画面效果 3.独立显卡设置高性能右键桌面-NVIDIA控制面板-3d设置-里面可以设置全局高性能 Cekavis: 我是在正常的环境中使用电脑（室温并没有很高），调低游戏画面效果这种治标不治本的措施是不是不太合理呢。如果是机型本身的因素，我可以接受降低温度墙、限制功耗之类的方式解决问题，但您提供的方法并不能解决问题，毕竟随时有自动关机风险的电脑没人想要用。 另外，我刚才断开外接显示屏的时候也拔掉了网线改用WiFi，我插上网线之后打开游戏立刻又出现了自动关机的问题（单屏），我怀疑是有线网卡的问题。目前不插网线双屏也没有再自动关机了。请问关于有线网卡这个问题是否有解决办法？ 一个多月前这台电脑关于有线网卡还有另一个故障，当时是连着网线便会偶尔蓝屏，有时开机几分钟没动电脑就蓝屏了，报错是DRIVER_VERIFIER_DMA_VIOLATION，后来在b站看到其他人也有类似情况，似乎是G15 5520的一个普遍问题，在BIOS里关闭两个关于DMA的选项之后问题没有再出现。 戴尔技术支持: 那咱当前是游戏温度高是吗\\~ Cekavis: 可能问题并不在温度上？虽然的确记录到是过热事件导致关机，但插不插网线游戏温度似乎没有区别（都挺高），只有插了网线才会自动关机。 戴尔技术支持: 那咱有试过更新有线网卡驱动看看吗\\~ Cekavis: 在一个多月前蓝屏问题的时候更新过，当时更新了也没解决问题，之后并没有新版本的驱动，现在仍然是最新版本 Cekavis: 在dell官网查找的驱动 戴尔技术支持: 那咱BIOS驱动有更新吗\\~ Cekavis: 也是最新的 戴尔技术支持: 咱这边接网线正常使用电脑会吗，还是说连接网线后，只有开游戏才会呢\\~ Cekavis: 只有开游戏才会的 戴尔技术支持: 那咱这边电脑有安装support assist吗\\~ Cekavis: 装过但后来打不开了，想重装又装不上，我再试试 戴尔技术支持: 那劳烦咱这边安装看看呢\\~咱这边接有线网的话是开所有游戏都会吗\\~ Cekavis: 应该是一些大型游戏才会吧 Cekavis: [图片] Cekavis: 还是安装不了，重启也不行 戴尔技术支持: 开启高级管理员： 使用Win+x组合键，打开系统快捷菜单，然后选择 power shell （管理 员A）进入 在输入net user administrator /active:yes 回车，开启内置的Administrator账户 .注销机器使用administrator 登录， 如需关闭内置的Administrator账户，在成功登录原账户后，重新打开Windows PowerShell（管理员），输入net user administrator /active:no，回车即可 戴尔技术支持: 咱这边开启超级管理员的身份看下可以安装吗 Cekavis: 和图中一样安装不了 戴尔技术支持: 咱目前这个问题先考虑系统问题，您这边系统有更新吗，咱更新系统看看是否依旧，然后考虑恢复系统看看，如果系统更新或UI否后依旧会出现这个问题的话，那咱这边就考了硬件问题，可以前往维修站进行检测看看呢\\~ Cekavis: 系统目前没有更新，恢复系统的话我更倾向于暂时不使用网线了，以后要用到我会再考虑的。谢谢啦\\~ 戴尔技术支持: 您客气了吖\\~那您这边后续有什么问题您随时联系小编哈\\~ღ( ´･ᴗ･` )比心 ️ Cekavis: 嗯嗯，辛苦您了 戴尔技术支持: 不会的呐\\~能帮助到您的话小编也会很开心呐\\~ Update later： 还是有问题，送到武林广场的 Dell 网点去修，一会儿告诉我显卡坏了，但在保修内可以免费换，可能要两周。两三天修好了但告诉我不能邮寄，只能再去取，还好本来也打算和桌桌去杭州一趟，取回来没有再出现问题。 2022.7.26 MSNWindows 11 自动在 Edge 打开 MSN，已经不是第一次出现，在这里有人提到是 Clash for Windows 的问题，待确认。 2022.6.16 绿屏今天 Dell G15 5520 又绿屏了，上次试了试 XTU 和 MSI Afterburner 之后就开始绿屏，大约十分钟内便有一次，后来又莫名其妙好了。因为这次是插上了网线和移动硬盘之后犯的病，我怀疑是这两者的原因导致了绿屏。拔掉移动硬盘后仍然会绿屏，所以目标只剩下网线。 打开 Dell 官网发现十几天前有个有线网卡驱动更新，并且是紧急，更新里写到修复了插着网线看在线视频的时候 Windows 报错的问题，不确定是否就是我遇到的问题，但更新后一小段时间内的确没有继续绿屏了，后来离开寝室没网线了，目前不确定问题是否完全解决。 Update 2022.6.17： 插上网线又绿屏了，但这次 Google 居然直接搜到了一篇《十几秒解决戴尔G15 5520 win11蓝屏 【DRIVER_ VERIFIER_ DMA_ VIOLATION】》，在 BIOS 里关掉两项 DMA 就可以了。看评论区反应大概是正确解决办法了。","link":"/computer-repair/"},{"title":"「Codeforces 487E」Tourists","text":"Codeforces 487E 题意给你一张 $n$ 个点 $m$ 条边的无向图，每个点有点权，$q$ 次操作 C a w，将第 $a$ 个点的权值改为 $w$ A a b，询问 $a$ 到 $b$ 所有可能的简单路径上的点权最小值 简单路径即不经过一个点超过一次的路径 $n,m,q\\le 10^5$ 做法建圆方树，每个方点维护一个可以删除的小根堆，保存圆方树上这个方点所有儿子的权值 考虑两个点路径上的点权最小值就是在圆方树上路径经过的所有方点的堆顶的最小值和LCA位置的特判 若LCA是方点，这时LCA所在的点双的深度最小点并没有被计算到，即LCA的树上父亲，判一下即可 若LCA是圆点，这时LCA本身没有被计算到，判一下即可 用树剖维护链上最小值 每次修改只要在一个堆中删除和插入各一次 总复杂度 $\\mathcal O(n\\log^2n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 100005, inf = 1e9;int n, m, q, num, cnt, stop, p, low[N], stk[N], w[N], h[N], siz[N&lt;&lt;1], top[N&lt;&lt;1], e[N&lt;&lt;1], pre[N&lt;&lt;1], dfn[N&lt;&lt;1], fa[N&lt;&lt;1], b[N&lt;&lt;1], dep[N&lt;&lt;1], s[N&lt;&lt;3];vector&lt;int&gt; a[N&lt;&lt;1];struct heap{ priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; a, b; inline void push(int x){ a.push(x);} inline void erase(int x){ b.push(x);} inline int top(){ while(b.size() &amp;&amp; a.top()==b.top()) a.pop(), b.pop(); return a.top(); }} f[N];inline void add(int x, int y){ e[++num]=y, pre[num]=h[x], h[x]=num;}void tarjan(int u){ dfn[u]=low[u]=++cnt; stk[++stop]=u; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa[u]){ if(!dfn[e[i]]){ tarjan(e[i]), low[u]=min(low[u], low[e[i]]); if(low[e[i]]&gt;=dfn[u]){ ++p; a[u].push_back(p); do a[p].push_back(stk[stop]), f[p-n].push(w[stk[stop]]); while(stk[stop--]!=e[i]); } } else low[u]=min(low[u], dfn[e[i]]); }}void dfs1(int u){ siz[u]=1; for(int v:a[u]) fa[v]=u, dep[v]=dep[u]+1, dfs1(v), siz[u]+=siz[v];}void dfs2(int u){ dfn[u]=++cnt, b[dfn[u]]=(u&gt;n?f[u-n].top():inf); int son=0; for(int v:a[u]) if(siz[v]&gt;siz[son]) son=v; if(son) top[son]=top[u], dfs2(son); for(int v:a[u]) if(v!=son) top[v]=v, dfs2(v);}void build(int l, int r, int t){ if(l==r) return (void)(s[t]=b[l]); int mid=(l+r)/2, k=t&lt;&lt;1; build(l, mid, k), build(mid+1, r, k|1); s[t]=min(s[k], s[k|1]);}void modify(int l, int r, int t, int x, int y){ if(l==r) return (void)(s[t]=y); int mid=(l+r)/2, k=t&lt;&lt;1; if(x&lt;=mid) modify(l, mid, k, x, y); else modify(mid+1, r, k|1, x, y); s[t]=min(s[k], s[k|1]);}int query(int l, int r, int t, int L, int R){ if(L&lt;=l &amp;&amp; r&lt;=R) return s[t]; int mid=(l+r)/2, k=t&lt;&lt;1; return min(L&lt;=mid?query(l, mid, k, L, R):inf, R&gt;mid?query(mid+1, r, k|1, L, R):inf);}int main() { read(n), read(m), read(q), p=n; for(int i=1; i&lt;=n; ++i) read(w[i]); for(int i=1, x, y; i&lt;=m; ++i) read(x), read(y), add(x, y), add(y, x); tarjan(1); dfs1(1), top[1]=1, cnt=0, dfs2(1); build(1, p, 1); while(q--){ static char opt; static int x, y; while(isspace(opt=read())); read(x), read(y); if(opt=='C'){ if(x!=1){ f[fa[x]-n].erase(w[x]), f[fa[x]-n].push(y); modify(1, p, 1, dfn[fa[x]], f[fa[x]-n].top()); } w[x]=y; } else{ int ans=inf; while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]]) swap(x, y); ans=min(ans, query(1, p, 1, dfn[top[x]], dfn[x])); x=fa[top[x]]; } if(dep[x]&gt;dep[y]) swap(x, y); ans=min(ans, query(1, p, 1, dfn[x], dfn[y])); print(min(ans, x&gt;n?w[fa[x]]:w[x])), print('\\n'); } } return flush(), 0;}","link":"/codeforces-487e-tourists/"},{"title":"北大集训 2019 游记","text":"咕咕咕 （当时为什么不想写呢？可能是前两天太自闭了。）","link":"/ctt2019/"},{"title":"北大集训 2020 游记","text":"OI生活结束时，已不知道该如何提笔了。 12.7早上的高铁，信号比印象中好了很多，可能是因为换了手机吧，但路上肯定不是5G。快两点办好入住，熟悉的地方，并没有上次那么炎热，但是静电还是一样多。三点是开幕式，所以要等晚上再去修电脑。室友是广东的高二小哥。开幕式后碰到了 wy 和 ztr，带我们去了刚开的新食堂，四楼有火锅，但是没有七人桌，我就自己去修电脑了，回来路上找了家麦当劳解决。本来以为这么热闹的地方的联想维修网点肯定是什么都有，虽然店员很多但是与我想象的还是不太一致。 晚上九点多就睡了，睡着倒是没有太难，但是经常醒来。 12.8 - Day 1零下十一度 lj 穿着拖鞋把我们送到校门口。 第一题是一个数学题，有一些数论和线性代数。第二题第一感觉是个大数据结构，多个区间询问让我很害怕。真的很害怕，我到比赛结束前两分钟才发现是签到题。我笑一下，也许自己也不觉得奇怪了。第三题是个有趣的交互题，后来知道是 pjy 出的。写了一个奇怪的做法得了 32 分，后来便再没有突破，改变随机种子和随机方式会少 2~4 分，我想也许是 fyj 的生日带给我的，但是我有什么资格拥有她呢。放弃治疗后试了自己生日也是 32，好难过。 出来之后发现大家都是两百多，37+20+32，rank 60，一切都结束了。第三题是第四高分，真奇怪。 讲题之后和 yzr 去逛 PKU 校园，没有雪，明年就会见到吧，会有雪，也会有 fyj 吗。 十点多睡觉，十一点多才睡着，不过质量比昨天改善不少。 12.9 - Day 2五点多醒来继续睡着了。 37 分钟过了第一题，重拾一丝信心。写了第三题暴力，再改成三方。不会第二题，自觉写不出分段函数，手算了 2 的答案得到了 5 分。猜是一个脑筋急转弯，但是凑不出来。第三题也不会再优化。最后一个小时发现很多人 ak 离场了，真的结束了。100+5+60，rank 45。 鸽了讲题，在游戏里可以忘记一些哀伤。一直玩到晚上。 12.10 - Day 3睡眠好了一些，也不紧张了。 第一题不知道用行列式枚举排列，找了很久性质，可惜了。第二题冲上去写根号 log，发现要跑 20s，很难过，咬咬牙改成根号下 log，还是卡不进去。还剩二十分钟时发现数据结构学傻了，用了十几分钟改过了，虽然还要二分，但是跑得快极了。第三题来不及写暴力了。 过的人最多的居然是第一题。集训队内排名 33，指望明天了。 晚上 yzr 说要不要去外面玩，我说可以，但是没地方去。这种时候更喜欢一个人散步。yzr 去打狼人杀了，我却决定出去，八点骑车到了一个郊野公园，门口说调整关闭时间为八点，于是只能扫兴而返。但是我不想就此结束，沿清河而下，绕了圆明园外半边轮廓回到酒店。不想现在去圆明园，想等到合适的人一起去。 12.11 - Day 4什么都不会，没有可写的了。 最后一天最后的挣扎，没有进前三十，没有冬令营，最后一场OI比赛来得比预想早了一些。 考完去参加 PKU 的座谈。相比大学生活什么的，我更向往和她的生活。有人信吗，我也不信。 下午去取了电脑，没修好，也没收我钱。 晚上想刷光临时饭卡失败了，饮料喝不下，不过等到了 cwy 和 pjy，跟着混进了一节不去要写五百字报告的课——《王选的世界》。错误估计了时长，不过本来也没事做。 回去发现电脑电池是固件问题，震撼我*，遂打隔膜到第二天。","link":"/ctt2020/"},{"title":"CSP-S2019 退役记","text":"退役了。 Day 0去秋游了，走了三万多步，人没了（退役 flag x 1）。 回来就颓颓颓颓（退役 flag x 2）。 Day 111 点睡觉的，1 点多被爆肝的室友吵醒，醒了大半个小时才睡着（退役 flag x 3），6 点多就得起床了。 考场是某校名中带有学车二字的学校的负一层教室（地下停车场），只提供睿智的移动厕所，厕所不能冲水（退役 flag x 4）。 考场座位对面就有一个显示屏，随时可以看到时间，觉得很爽（退役 flag x 5）。 开考，直接把第一题走了。 第二题调了很久智障错误（退役 flag x 6），比如什么左括号的点没算贡献、没做前缀和…… 我想 AK（退役 flag x 7）。 第三题一开始去想一个拆子问题的算法了（退役 flag x 8），大概是 $1$ 一定会走到另外的编号最小点，于是对于这条链挂出的若干子树搞一搞，一开始还以为是对的，成功自闭。 后来想到正解方向，只是模糊觉得限制都是一条边要在另一条边之前做，于是全局暴力维护一个顺序关系（优化以后再说）（退役 flag x 9），后来发现无法解决的是一条边必须紧接着一条边选的情况，成功自闭。 还有一个小时就冲上去写暴力了，十分不冷静，写了一个假的链，然后不会做菊花，最后就是把阶乘和链和假的算法结合了一下。后来很开心地发现链挂了，然后意识到我的假算法对于链的情况应该是对的？获得了 10pts 的好成绩。 出来发现大家都 AK 了，滚回学校继续颓（退役 flag x 10）。 Day 2换了个寝室住，但是也没睡好（退役 flag x 11）。 我想 AK（退役 flag x 12）。 开考前在正常的厕所外面排了一会儿队，然后意识到好像不想上厕所。 开考，看到一个 $998244353$，直接把 dp 走了。 看到第二题慌的一批，有点点斜率优化的感觉（？）（退役 flag x 13）。先猜了一个段数相同情况下每一段尽量往右延伸的结论，然后再猜了一个段数越多越优的结论，乱写一通从前往后贪心，发现写不来，于是不会做（退役 flag x 14）。 想扔了看第三题（退役 flag x 15），但是模糊意识到反过来做最后一段尽量短，然后写了一个二分，过不去大样例（退役 flag x 16）。冷静了一下，写了个暴力，发现右端点确定时段长不能二分。 再冷静了一下，发现左端点确定时段长可以二分（注定了想不到单调队列优化（退役 flag x 17）），写了个 88pts 跑路了。 第三题一开始想对于每条边求出具体两边中心的，搞了一会儿还是不会做。突然想到对每个点算贡献，随便推了一下发现好像是可以维护的，就把线段树合并走了（退役 flag x 18），到根的链单独拿个树状数组维护。大概 1h 后过了大样例，还有 20min，觉得自己好强（退役 flag x 19）。极限数据本机跑了 3.5s 不想卡，改了个用 getchar() 的读入优化没有任何变化，怕写挂就改回去了（退役 flag x 20）。 出来发现大家都 AK 了，滚回学校继续颓（退役 flag x 21）。 学会了德扑，赌了两局都破产了（退役 flag x 22），还重学了 UNO。 100+100+10+100+88+(100-?)，大家再见。","link":"/csp-s-2019/"},{"title":"灰色的停课生活","text":"停课了可真休闲啊 大家高高兴兴颓废，不过有些可能要退役了呢 今天的效率也很低，在一句while(n--)里面调用线段树func(0, n+2000, *)调了几小时。 模拟赛也垫底了，水平低啊。 还有很多题要做，文化课该怎么补","link":"/grey-class-suspension-life/"},{"title":"「HDU 5306」Gorgeous Sequence","text":"HDU 5306 题意你有一个长为 $n$ 的序列 $a$，有 $m$ 次操作 给出 $l,r,x$，对于 $i\\in[l,r]$，令 $a_i=min(a_i,x)$ 给出 $l,r$，询问 $[l,r]$ 中的最大值 给出 $l,r$，询问 $\\sum_{i=l}^ra_i$ 多组数据，$\\sum n\\le 10^6,\\sum m\\le 10^6$ 做法参考2016候选队论文 吉如一《区间最值操作与历史最值问题》 实现线段树，每个节点维护 区间最大值 ${\\rm max}$ 最大值出现次数 ${\\rm cnt}$ 严格次大值 ${\\rm sec}$ 区间和 ${\\rm sum}$ 考虑一次修改操作 $l,r,x$，可以在线段树上定位出 $\\mathcal O(\\log n)$ 个区间 对每个节点暴力搜索 若${\\rm max} \\le x$，退出 若${\\rm sec}&lt;x&lt;{\\rm max}$，给 ${\\rm sum}$ 加上 ${\\rm cnt}\\times (x-{\\rm max})$，更新 ${\\rm max}$ 并打上标记 若 $x\\le {\\rm sec}$，递归左右儿子 这里的标记可以不用单独记录，每次直接用 ${\\rm max}$ 和子节点比较 复杂度这是 $\\mathcal O((n+m)\\log n)$ 的 可以参考论文的势能分析 感觉用不同的值的个数均摊可以直观理解 每次修改操作最多增加 $1$ 个不同的值 每次修改操作访问到的点数量，是根节点定位到的 $\\mathcal O(\\log n)$ 个点和次大值被修改的点以及它们的至多一层子节点构成的虚树，大小 $\\mathcal O(k\\log n)$，其中 $k$ 是最底层的次大值被修改的节点数，而一次操作会减少 $k$ 个不同的值 最多把所有值变成相同，总复杂度 $\\mathcal O((n+m)\\log n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) { if (c == '-') iosig = true; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x + (x &lt;&lt; 2)) &lt;&lt; 1) + (c ^ '0'); if (iosig) x = -x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh = obuf;inline void print(char c) { if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf; *ooh++ = c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x == 0) print('0'); else { if (x &lt; 0) print('-'), x = -x; for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48; while (cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 1000005;int T, n, m, a[N], mx[N&lt;&lt;2], se[N&lt;&lt;2], cnt[N&lt;&lt;2];ll s[N&lt;&lt;2];inline void update(int t){ int k=t&lt;&lt;1; if(mx[k]&lt;mx[k|1]) mx[t]=mx[k|1], cnt[t]=cnt[k|1], se[t]=max(mx[k], se[k|1]); else if(mx[k]&gt;mx[k|1]) mx[t]=mx[k], cnt[t]=cnt[k], se[t]=max(mx[k|1], se[k]); else mx[t]=mx[k], cnt[t]=cnt[k]+cnt[k|1], se[t]=max(se[k], se[k|1]); s[t]=s[k]+s[k|1];}void pushdown(int t){ int k=t&lt;&lt;1; if(mx[t]&lt;mx[k]) s[k]-=(ll)(mx[k]-mx[t])*cnt[k], mx[k]=mx[t]; if(mx[t]&lt;mx[k|1]) s[k|1]-=(ll)(mx[k|1]-mx[t])*cnt[k|1], mx[k|1]=mx[t];}void build(int l, int r, int t){ if(l==r) return (void)(mx[t]=s[t]=a[l], cnt[t]=1, se[t]=-1); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; build(l, mid, k), build(mid+1, r, k|1); update(t);}void change(int l, int r, int t, int L, int R, int x){ if(x&gt;=mx[t]) return; if(L&lt;=l &amp;&amp; r&lt;=R &amp;&amp; x&gt;se[t]) return (void)(s[t]-=(ll)(mx[t]-x)*cnt[t], mx[t]=x); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; pushdown(t); if(L&lt;=mid) change(l, mid, k, L, R, x); if(R&gt;mid) change(mid+1, r, k|1, L, R, x); update(t);}int query1(int l, int r, int t, int L, int R){//max if(L&lt;=l &amp;&amp; r&lt;=R) return mx[t]; int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; pushdown(t); if(R&lt;=mid) return query1(l, mid, k, L, R); if(L&gt;mid) return query1(mid+1, r, k|1, L, R); return max(query1(l, mid, k, L, R), query1(mid+1, r, k|1, L, R));}ll query2(int l, int r, int t, int L, int R){//sum if(L&lt;=l &amp;&amp; r&lt;=R) return s[t]; int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; pushdown(t); return (L&lt;=mid?query2(l, mid, k, L, R):0)+(R&gt;mid?query2(mid+1, r, k|1, L, R):0);}int main() { read(T); while(T--){ read(n), read(m); for(int i=1; i&lt;=n; ++i) read(a[i]); build(1, n, 1); while(m--){ static int opt, l, r, t; read(opt), read(l), read(r); if(!opt) read(t), change(1, n, 1, l, r, t); else if(opt==1) print(query1(1, n, 1, l, r)), print('\\n'); else print(query2(1, n, 1, l, r)), print('\\n'); } } return flush(), 0;}","link":"/hdu-5306/"},{"title":"「HDU 6057」Kanade&#39;s convolution","text":"HDU 6057 题意给你两个数组 $A[0\\dotsc 2^m-1]$ 和 $B[0 \\dotsc 2^m-1]$ 你需要计算 $$C[k]=\\sum_{i{\\rm and}j=k}A[i{\\rm xor}j]\\times B[i{\\rm or}j]$$ 输出 $\\sum_{i=0}^{2^m-1}C[i]\\times 1526^i \\bmod 998244353$ $m\\le 19$ 做法由于 $i{\\rm and}j=k$，所以有 $i{\\rm or}j=i{\\rm xor}j{\\rm xor}k$，($i{\\rm xor}j$ 与 $k$ 无交) 那么可以转化 $$\\begin{align}C[k]&amp;=\\sum_{x{\\rm xor}y=k}[x{\\rm and}y=x]\\times A[x]\\times B[y]\\times 2^{ {\\rm popcount}(x)} \\&amp;=\\sum_{x{\\rm xor}y=k}[{\\rm popcount}(y)-{\\rm popcount}(x)={\\rm popcount}(k)]\\times A[x]\\times B[y]\\times 2^{ {\\rm popcount}(x)}\\end{align}$$ 其中 ${\\rm popcount}(x)$ 等于 $x$ 的二进制表示中 $1$ 的个数 定义$a_{i,j}=[{\\rm popcount}(j)=i]\\times A[j],b_{i,j}=[{\\rm popcount}(j)=i]\\times B[j]$ 也就是增加一维集合大小，那么 $$c_{i,k}=\\sum_{j=0}^i\\sum_{x\\ {\\rm xor}\\ y=k}a_{j,x}\\times b_{i-j,y}\\times 2^j$$ $C[i]=c_{ {\\rm popcount}(i),i}$，其他多余的位置是没有意义的 那么我们对每一个 $a_i,b_i$ 做 FWT，再暴力枚举第一维，加到对应的 $c_i$ 上 时间复杂度 $\\mathcal O(m^2 \\times 2^m)$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int N = 20, M = 1&lt;&lt;19, P = 998244353;int ans, m, cnt[M], a[N][M], b[N][M], c[N][M];inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}inline void FWT(int *f, int g){ for(int i=1; i&lt;1&lt;&lt;m; i&lt;&lt;=1) for(int j=0; j&lt;1&lt;&lt;m; j+=i&lt;&lt;1) for(int k=j; k&lt;j+i; ++k){ int x=f[k], y=f[k+i]; f[k]=(x+y)%P, f[k+i]=(x-y+P)%P; } if(g==-1) for(int i=0, I=Pow(1&lt;&lt;m); i&lt;1&lt;&lt;m; ++i) f[i]=(ll)f[i]*I%P;}int main() { read(m); for(int i=1; i&lt;1&lt;&lt;m; ++i) cnt[i]=cnt[i^(i&amp;-i)]+1; for(int i=0; i&lt;1&lt;&lt;m; ++i) read(a[cnt[i]][i]); for(int i=0; i&lt;1&lt;&lt;m; ++i) read(b[cnt[i]][i]); for(int i=0; i&lt;=m; ++i) FWT(a[i], 1), FWT(b[i], 1); for(int i=0, p=1; i&lt;=m; ++i, p&lt;&lt;=1) for(int j=i; j&lt;=m; ++j) for(int k=0; k&lt;1&lt;&lt;m; ++k) c[j-i][k]=(c[j-i][k]+(ll)a[i][k]*b[j][k]%P*p)%P; for(int i=0; i&lt;=m; ++i) FWT(c[i], -1); for(int i=0, k=1; i&lt;1&lt;&lt;m; ++i, k=k*1526ll%P) ans=(ans+(ll)k*c[cnt[i]][i])%P; return printf(&quot;%d\\n&quot;, ans), 0;}","link":"/hdu-6057/"},{"title":"任意模数 NTT 和 DFT 的优化","text":"可能就存个板子，而且先咕了 来更了 参考 毛啸《再探快速傅里叶变换》 三模数 NTT不说了 拆系数 FFT描述令 $M=2^{15}=32768$，对于需要卷积的数列 $A_i$ 和 $B_i$ 中的每个数 $x$，拆成 $x=k\\times M+b$ 的形式 当长度是 $10^5$ ，模数在 $10^9$ 左右时，最大的数字大约在 $10^{14}$，单位根处理得好一点就不会爆 double 的精度 把 $A_i$ 拆出的两个数列和 $B_i$ 拆出的两个数列 DFT 后各选一个相乘，最终的系数分别是 $1,2^{15},2^{15},2^{30}$，相同的两项可以一起 IDFT 总共需要 7 次 DFT 已经挺快的了 代码就是下面的模板题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 1000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 1&lt;&lt;18;const double Pi=acos(-1);int n, m, p, l, k;struct cp{ double a, b; inline cp operator +(const cp &amp;rhs)const{ return (cp){a+rhs.a, b+rhs.b};} inline cp operator -(const cp &amp;rhs)const{ return (cp){a-rhs.a, b-rhs.b};} inline cp operator *(const cp &amp;rhs)const{ return (cp){a*rhs.a-b*rhs.b, a*rhs.b+b*rhs.a};} inline cp operator *(const double rhs)const{ return (cp){a*rhs, b*rhs};}} a[N], b[N], c[N], d[N], f[N], g[N], h[N], w[N+1];inline int Get(int n){ int p=1; while(p&lt;=n) p&lt;&lt;=1; return p;}void DFT(cp *f, int n){ for(int i=0, j=0; i&lt;n; ++i){ if(i&gt;j) swap(f[i], f[j]); for(int k=n&gt;&gt;1; (j^=k)&lt;k; k&gt;&gt;=1); } for(int i=1; i&lt;n; i&lt;&lt;=1) for(int j=0; j&lt;n; j+=i&lt;&lt;1) for(int k=j; k&lt;j+i; ++k){ cp t=w[i+k-j]*f[k+i]; f[k+i]=f[k]-t, f[k]=f[k]+t; }}void IDFT(cp *f, int n){ reverse(f+1, f+n), DFT(f, n); double k=1./n; for(int i=0; i&lt;n; ++i) f[i]=f[i]*k;}int main() { read(n), read(m), read(p), l=Get(n+m); for(int i=0, x; i&lt;=n; ++i) read(x), a[i].a=x&gt;&gt;15, b[i].a=x&amp;32767; for(int i=0, x; i&lt;=m; ++i) read(x), c[i].a=x&gt;&gt;15, d[i].a=x&amp;32767; for(int i=1; i&lt;l; i&lt;&lt;=1) for(int j=0; j&lt;i; ++j) w[i+j]=(cp){cos(Pi*j/i), sin(Pi*j/i)}; DFT(a, l), DFT(b, l), DFT(c, l), DFT(d, l); for(int i=0; i&lt;l; ++i) f[i]=f[i]+a[i]*c[i], g[i]=g[i]+a[i]*d[i]+b[i]*c[i], h[i]=h[i]+b[i]*d[i]; IDFT(f, l), IDFT(g, l), IDFT(h, l); for(int i=0; i&lt;=n+m; ++i, print(' ')) print((((ll)(f[i].a+.5)%p&lt;&lt;30)+((ll)(g[i].a+.5)&lt;&lt;15)+(ll)(h[i].a+.5))%p); return flush(), 0;} DFT 的优化描述假设 $n$ 是 $2$ 的整数次幂，现在需要对长度为 $n$ 的多项式 $A(x)$ 和 $B(x)$ 进行 DFT，我们可以合并只做一次 做法令 $$\\begin{align}P(x)=A(x)+iB(x) \\Q(x)=A(x)-iB(x)\\end{align}$$ 设 $P’[k]$ 和 $Q’[k]$ 分别是 $P(x)$ 和 $Q(x)$ 进行 DFT 后的序列 有 $P’[k]=P(\\omega_n^k),Q’[j]=Q(\\omega_n^k)$，即代入 $n$ 次单位根的幂后的点值 推导直接拉了 令 $\\text{conj}(x)$ 表示 $x$ 的共轭复数，$A_i$ 即 $A(x)$ 的 $i$ 次项系数 $$\\begin{align}P’[k] &amp;= A(\\omega_{n}^{k}) + i B(\\omega_{n}^{k}) \\&amp; = \\sum_{j=0}^{n-1} A_{j} \\omega_{n}^{jk} + i B_{j} \\omega_{n}^{jk} \\&amp; = \\sum_{j=0}^{n-1} (A_{j} + i B_{j}) \\left(\\cos \\left(\\frac{2 \\pi jk}{n}\\right) + i \\sin \\left(\\frac{2 \\pi jk}{n}\\right)\\right) \\\\Q’[k] &amp;= A(\\omega_{n}^{k}) - i B(\\omega_{n}^{k}) \\&amp; = \\sum_{j=0}^{n-1} A_{j} \\omega_{n}^{jk} - i B_{j} \\omega_{n}^{jk} \\&amp; = \\sum_{j=0}^{n-1} (A_{j} - i B_{j}) \\left(\\cos \\left(\\frac{2 \\pi jk}{n}\\right) + i \\sin \\left(\\frac{2 \\pi jk}{n}\\right)\\right) \\&amp; = \\sum_{j=0}^{n-1} \\left(A_{j} \\cos \\left(\\frac{2 \\pi jk}{n}\\right) + B_{j} \\sin \\left(\\frac{2 \\pi jk}{n}\\right)\\right) + i \\left(A_{j} \\sin \\left(\\frac{2 \\pi jk}{n}\\right) - B_{j} \\cos \\left(\\frac{2 \\pi jk}{n}\\right)\\right) \\&amp; = \\text{conj} \\left( \\sum_{j=0}^{n-1} \\left(A_{j} \\cos \\left(\\frac{2 \\pi jk}{n}\\right) + B_{j} \\sin \\left(\\frac{2 \\pi jk}{n}\\right)\\right) - i \\left(A_{j} \\sin \\left(\\frac{2 \\pi jk}{n}\\right) - B_{j} \\cos \\left(\\frac{2 \\pi jk}{n}\\right)\\right) \\right) \\&amp; = \\text{conj} \\left( \\sum_{j=0}^{n-1} \\left(A_{j} \\cos \\left(\\frac{-2 \\pi jk}{n}\\right) - B_{j} \\sin \\left(\\frac{-2 \\pi jk}{n}\\right)\\right) + i \\left(A_{j} \\sin \\left(\\frac{-2 \\pi jk}{n}\\right) + B_{j} \\cos \\left(\\frac{-2 \\pi jk}{n}\\right)\\right) \\right) \\&amp; = \\text{conj} \\left( \\sum_{j=0}^{n-1} (A_{j} + i B_{j}) \\left(\\cos \\left(\\frac{-2 \\pi jk}{n}\\right) + i \\sin \\left(\\frac{-2 \\pi jk}{n}\\right)\\right)\\right) \\&amp; = \\text{conj} \\left( \\sum_{j=0}^{n-1} (A_{j} + i B_{j}) \\omega_{n}^{-jk} \\right) \\&amp; = \\text{conj} \\left( \\sum_{j=0}^{n-1} (A_{j} + i B_{j}) \\omega_{n}^{(n-k)j} \\right) \\&amp; = \\text{conj} (P’[n-k])\\end{align}$$ 于是我们可以通过 $P(x)$ 得到 $Q(x)$ 注意最后得到的 $n-k$ 是模 $n$ 意义下的，当 $k=0$ 时需要特殊处理 设 $A’[k]$ 和 $B’[k]$ 分别是 $A(x)$ 和 $B(x)$ 进行 DFT 后的序列 有 $$\\begin{align}A’[k]=\\frac{P’[k]+Q’[k]}{2} \\B’[k]=\\frac{P’[k]-Q’[k]}{2i}\\end{align}$$ 通过这种方法可以用一次长度不变的 DFT 同时计算两个序列 DFT 后的结果 假设对 $P’[k]$ 进行了 IDFT，实部和虚部分别就是 $A(x)$ 和 $B(x)$ 了 单个 DFT 的优化可以分奇次项和偶次项拆成两个序列，可以用一次原先一半长度的 DFT 来得到 DFT 的结果，我就不学了 update: 来学了 半次 DFT DFT考虑把多项式 $f(x)$ 的偶次系数和奇次系数分开得到两个一半长度的序列，当做多项式分别是 $f_0(x)$ 和 $f_1(x)$ 于是 $$\\begin{align}f(x) &amp;= f_0(x^2)+x \\times f_1(x^2) \\\\f(\\omega_n^k) &amp;= f_0(\\omega_n^{2k})+\\omega_n^k \\times f_1(\\omega_n^{2k}) \\&amp;= f_0(\\omega_{\\frac{n}{2}}^k)+\\omega_n^k \\times f_1(\\omega_{\\frac{n}{2}}^k)\\end{align}$$ 我们把两个一半长度的多项式合并做 DFT，通过上式可以算出原多项式 DFT 的结果 IDFT几乎是反的，用 $f(\\omega_n^k)$ 和 $f(\\omega_n^{k+\\frac{n}{2}})$ 可以解出 $f_0(\\omega_{\\frac{n}{2}}^k)$ 和 $f_1(\\omega_{\\frac{n}{2}}^k)$ 然后那样塞回一半长度的序列，做 IDFT 后实部和虚部分别就是偶次和奇次的系数了 实现可以参考 $3.5$ 次的模板 应用在上面的拆系数 FFT 中可以优化到 $4$ 次或者所谓的 $3.5$ 次的 DFT 模板Luogu P4245 【模板】任意模数NTT 代码$4$ 次 DFT123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;using namespace std;#define ll long longstatic char buf[1&lt;&lt;21], *s=buf;inline void read(int &amp;x) { while(isspace(*s)) ++s; x=*s++^'0'; while(isdigit(*s)) x=x*10+(*s++^'0');}char obuf[1&lt;&lt;20], *ooh=obuf;inline void print(int x) { static int buf[30], cnt; if (x==0) *ooh++='0'; else { for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) *ooh++=buf[cnt--]; }}const int N = 1&lt;&lt;18;const double Pi=acos(-1);int n, m, p, l, k;struct cp{ double a, b; inline void operator +=(const cp &amp;rhs){ a+=rhs.a, b+=rhs.b;} inline cp operator +(const cp &amp;rhs)const{ return (cp){a+rhs.a, b+rhs.b};} inline cp operator -(const cp &amp;rhs)const{ return (cp){a-rhs.a, b-rhs.b};} inline cp operator *(const cp &amp;rhs)const{ return (cp){a*rhs.a-b*rhs.b, a*rhs.b+b*rhs.a};} inline cp operator *(const double rhs)const{ return (cp){a*rhs, b*rhs};} inline cp operator ~()const{ return (cp){a, -b};}} a[N], b[N], f[N], g[N], w[N];inline int Get(int n){ int p=1; while(p&lt;=n) p&lt;&lt;=1; return p;}inline void DFT(cp *f, int n){ for(register int i=0, j=0; i&lt;n; ++i){ if(i&gt;j) swap(f[i], f[j]); for(register int k=n&gt;&gt;1; (j^=k)&lt;k; k&gt;&gt;=1); } for(register int i=1; i&lt;n; i&lt;&lt;=1) for(register int j=0; j&lt;n; j+=i&lt;&lt;1) for(register int k=j; k&lt;j+i; ++k){ cp t=w[i+k-j]*f[k+i]; f[k+i]=f[k]-t, f[k]+=t; }}inline void IDFT(cp *f, int n){ reverse(f+1, f+n), DFT(f, n);}int main() { fread(s, 1, 1&lt;&lt;21, stdin); read(n), read(m), read(p), l=Get(n+m); for(register int i=0, x=0; i&lt;=n; ++i) read(x), f[i].a=x&gt;&gt;15, f[i].b=x&amp;32767; for(register int i=0, x=0; i&lt;=m; ++i) read(x), g[i].a=x&gt;&gt;15, g[i].b=x&amp;32767; for(register int i=1; i&lt;l; i&lt;&lt;=1){ w[i]=(cp){1, 0}; for(register int j=1; j&lt;i; ++j) w[i+j]=((j&amp;31)==1?(cp){cos(Pi*j/i), sin(Pi*j/i)}:w[i+j-1]*w[i+1]); } DFT(f, l), DFT(g, l); for(register int i=0; i&lt;l; ++i){ static cp q, f0, f1, g0, g1; q=~f[i?l-i:0], f0=(f[i]-q)*(cp){0, -.5}, f1=(f[i]+q)*.5; q=~g[i?l-i:0], g0=(g[i]-q)*(cp){0, -.5}, g1=(g[i]+q)*.5; a[i]=f1*g1, b[i]=f1*g0+f0*g1+f0*g0*(cp){0, 1}; } IDFT(a, l), IDFT(b, l); double k=1./l; for(register int i=0; i&lt;=n+m; ++i, *ooh++=' ') print((((ll)(a[i].a*k+.5)%p&lt;&lt;30)+((ll)(b[i].a*k+.5)&lt;&lt;15)+(ll)(b[i].b*k+.5))%p); return fwrite(obuf, 1, ooh - obuf, stdout), 0;} $3.5$ 次 DFT123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;using namespace std;#define ll long longstatic char buf[1&lt;&lt;21], *s=buf;inline void read(int &amp;x) { while(isspace(*s)) ++s; x=*s++^'0'; while(isdigit(*s)) x=x*10+(*s++^'0');}char obuf[1&lt;&lt;20], *ooh=obuf;inline void print(int x) { static int buf[30], cnt; if (x==0) *ooh++='0'; else { for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) *ooh++=buf[cnt--]; }}const int N = 1&lt;&lt;18;const double Pi=acos(-1);int n, m, p, l, k;struct cp{ double a, b; inline void operator +=(const cp &amp;rhs){ a+=rhs.a, b+=rhs.b;} inline cp operator +(const cp &amp;rhs)const{ return (cp){a+rhs.a, b+rhs.b};} inline cp operator -(const cp &amp;rhs)const{ return (cp){a-rhs.a, b-rhs.b};} inline cp operator *(const cp &amp;rhs)const{ return (cp){a*rhs.a-b*rhs.b, a*rhs.b+b*rhs.a};} inline cp operator *(const double rhs)const{ return (cp){a*rhs, b*rhs};} inline cp operator ~()const{ return (cp){a, -b};}} a[N], b[N], c[N], d[N], f[N], g[N], h[N], w[N];inline int Get(int n){ int p=1; while(p&lt;=n) p&lt;&lt;=1; return p;}inline void DFT_(cp *f, int n){ for(register int i=0, j=0; i&lt;n; ++i){ if(i&gt;j) swap(f[i], f[j]); for(register int k=n&gt;&gt;1; (j^=k)&lt;k; k&gt;&gt;=1); } for(register int i=1; i&lt;n; i&lt;&lt;=1) for(register int j=0; j&lt;n; j+=i&lt;&lt;1) for(register int k=j; k&lt;j+i; ++k){ cp t=w[i+k-j]*f[k+i]; f[k+i]=f[k]-t, f[k]+=t; }}inline void DFT(cp *f, int n){ if(n==1) return; n&gt;&gt;=1; static cp a[N/2]; for(register int i=0; i&lt;n; ++i) a[i]=(cp){f[i&lt;&lt;1].a, f[i&lt;&lt;1|1].a}; DFT_(a, n); for(register int i=0; i&lt;n; ++i){ cp q=~a[(n-i)&amp;(n-1)], x=(a[i]+q)*.5, y=(a[i]-q)*(cp){0, -.5}, t=y*w[n+i]; f[i]=x+t, f[n+i]=x-t; }}inline void IDFT(cp *f, int n){ if(n==1) return; reverse(f+1, f+n), n&gt;&gt;=1; static cp a[N/2]; for(register int i=0; i&lt;n; ++i) a[i]=(f[i]+f[i+n])*.5 + (f[i]-f[i+n])*(cp){0, .5}*w[n+i]; DFT_(a, n); double k=1./n; for(register int i=0; i&lt;n; ++i) f[i&lt;&lt;1]=(cp){a[i].a*k, 0}, f[i&lt;&lt;1|1]=(cp){a[i].b*k, 0};}int main() { fread(s, 1, 1&lt;&lt;21, stdin); read(n), read(m), read(p), l=Get(n+m); for(register int i=0, x=0; i&lt;=n; ++i) read(x), a[i].a=x&gt;&gt;15, b[i].a=x&amp;32767; for(register int i=0, x=0; i&lt;=m; ++i) read(x), c[i].a=x&gt;&gt;15, d[i].a=x&amp;32767; for(register int i=1; i&lt;l; i&lt;&lt;=1){ w[i]=(cp){1, 0}; for(register int j=1; j&lt;i; ++j) w[i+j]=((j&amp;31)==1?(cp){cos(Pi*j/i), sin(Pi*j/i)}:w[i+j-1]*w[i+1]); } DFT(a, l), DFT(b, l), DFT(c, l), DFT(d, l); for(register int i=0; i&lt;l; ++i) f[i]=a[i]*c[i], g[i]=a[i]*d[i]+c[i]*b[i], h[i]=b[i]*d[i]; IDFT(f, l), IDFT(g, l), IDFT(h, l); for(register int i=0; i&lt;=n+m; ++i, *ooh++=' ') print((((ll)(f[i].a+.5)%p&lt;&lt;30)+((ll)(g[i].a+.5)&lt;&lt;15)+(ll)(h[i].a+.5))%p); return fwrite(obuf, 1, ooh - obuf, stdout), 0;} 例题贴代码，方便以后拉 多项式求逆Luogu P4239 【模板】多项式求逆（加强版） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;vector&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) { if (c == '-') iosig = true; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x + (x &lt;&lt; 2)) &lt;&lt; 1) + (c ^ '0'); if (iosig) x = -x;}const int OUT_LEN = 1000000;char obuf[OUT_LEN], *ooh = obuf;inline void print(char c) { if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf; *ooh++ = c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x == 0) print('0'); else { if (x &lt; 0) print('-'), x = -x; for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48; while (cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const double Pi = acos(-1);const int P = 1000000007;int n, k;vector&lt;int&gt; a;namespace Poly{ const int LEN = 1&lt;&lt;18; vector&lt;int&gt; ans;// for Evaluate() vector&lt;vector&lt;int&gt;&gt; p;// for Evaluate() &amp; Interpolate() struct cp{ double a, b; inline void operator +=(const cp &amp;rhs){ a+=rhs.a, b+=rhs.b;} inline cp operator +(const cp &amp;rhs)const{ return (cp){a+rhs.a, b+rhs.b};} inline cp operator -(const cp &amp;rhs)const{ return (cp){a-rhs.a, b-rhs.b};} inline cp operator *(const cp &amp;rhs)const{ return (cp){a*rhs.a-b*rhs.b, a*rhs.b+b*rhs.a};} inline cp operator *(const double rhs)const{ return (cp){a*rhs, b*rhs};} inline cp operator ~()const{ return (cp){a, -b};} } f[LEN], g[LEN], w[LEN]; inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans; } inline void Init(){ for(int i=1; i&lt;LEN; i&lt;&lt;=1){ w[i]=(cp){1, 0}; for(int j=1; j&lt;i; ++j) w[i+j]=((j&amp;31)==1?(cp){cos(Pi*j/i), sin(Pi*j/i)}:w[i+j-1]*w[i+1]); } } inline int Get(int x){ int n=1; while(n&lt;=x) n&lt;&lt;=1; return n;} inline void DFT_(cp *f, int n){ for(register int i=0, j=0; i&lt;n; ++i){ if(i&gt;j) swap(f[i], f[j]); for(register int k=n&gt;&gt;1; (j^=k)&lt;k; k&gt;&gt;=1); } for(register int i=1; i&lt;n; i&lt;&lt;=1) for(register int j=0; j&lt;n; j+=i&lt;&lt;1) for(register int k=j; k&lt;j+i; ++k){ cp t=w[i+k-j]*f[k+i]; f[k+i]=f[k]-t, f[k]+=t; } } inline void DFT(cp *f, int n){ if(n==1) return; n&gt;&gt;=1; static cp a[LEN/2]; for(register int i=0; i&lt;n; ++i) a[i]=(cp){f[i&lt;&lt;1].a, f[i&lt;&lt;1|1].a}; DFT_(a, n); for(register int i=0; i&lt;n; ++i){ cp q=~a[(n-i)&amp;(n-1)], x=(a[i]+q)*.5, y=(a[i]-q)*(cp){0, -.5}, t=y*w[n+i]; f[i]=x+t, f[n+i]=x-t; } } inline void IDFT(cp *f, int n){ if(n==1) return; reverse(f+1, f+n), n&gt;&gt;=1; static cp a[LEN/2]; for(register int i=0; i&lt;n; ++i) a[i]=(f[i]+f[i+n])*.5 + (f[i]-f[i+n])*(cp){0, .5}*w[n+i]; DFT_(a, n); double k=1./n; for(register int i=0; i&lt;n; ++i) f[i&lt;&lt;1]=(cp){a[i].a*k, 0}, f[i&lt;&lt;1|1]=(cp){a[i].b*k, 0}; } inline vector&lt;int&gt; Mul(const vector&lt;int&gt; &amp;f, const vector&lt;int&gt; &amp;g){ vector&lt;int&gt; ans(f.size()+g.size()-1); if(f.size()*g.size()&lt;=1000){ for(unsigned i=0; i&lt;f.size(); ++i) for(unsigned j=0; j&lt;g.size(); ++j) ans[i+j]=(ans[i+j]+(ll)f[i]*g[j])%P; return ans; } int l=Get(f.size()+g.size()-2); static cp f0[LEN], f1[LEN], g0[LEN], g1[LEN], A[LEN], B[LEN], C[LEN]; memset(f0, 0, sizeof(cp)*l), memset(f1, 0, sizeof(cp)*l); memset(g0, 0, sizeof(cp)*l), memset(g1, 0, sizeof(cp)*l); for(unsigned i=0; i&lt;f.size(); ++i) f0[i].a=f[i]&amp;32767, f1[i].a=f[i]&gt;&gt;15; for(unsigned i=0; i&lt;g.size(); ++i) g0[i].a=g[i]&amp;32767, g1[i].a=g[i]&gt;&gt;15; DFT(f0, l), DFT(f1, l), DFT(g0, l), DFT(g1, l); for(int i=0; i&lt;l; ++i) A[i]=f1[i]*g1[i], B[i]=f1[i]*g0[i]+f0[i]*g1[i], C[i]=f0[i]*g0[i]; IDFT(A, l), IDFT(B, l), IDFT(C, l); for(unsigned i=0; i&lt;ans.size(); ++i) ans[i]=(((ll)(A[i].a+.5)%P&lt;&lt;30)+((ll)(B[i].a+.5)&lt;&lt;15)+(ll)(C[i].a+.5))%P; return ans; } vector&lt;int&gt; PolyInv(const vector&lt;int&gt; &amp;f, int n=-1){ if(n==-1) n=f.size(); if(n==1){ vector&lt;int&gt; ans; return ans.push_back(Pow(f[0])), ans; } vector&lt;int&gt; ans=PolyInv(f, (n+1)/2), tmp(&amp;f[0], &amp;f[0]+n); tmp=Mul(Mul(tmp, ans), ans), tmp.resize(n); for(unsigned i=0; i&lt;ans.size(); ++i) tmp[i]=(2*ans[i]-tmp[i])%P, tmp[i]=(tmp[i]&lt;0?tmp[i]+P:tmp[i]); for(int i=ans.size(); i&lt;n; ++i) tmp[i]=(tmp[i]?P-tmp[i]:0); return tmp; }}int main() { Poly::Init(); read(n), a.resize(n); for(int i=0; i&lt;n; ++i) read(a[i]); a=Poly::PolyInv(a); for(int i=0; i&lt;n; ++i) print(a[i]), print(' '); return flush(), 0;} 传球Luogu P5173 传球 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ll long longconst double Pi=acos(-1);const int N = 3505, P = 1000000007, L = 1&lt;&lt;13;int C, m, Ans[N], x[N];struct cp{ double a, b; inline void operator +=(const cp &amp;rhs){ a+=rhs.a, b+=rhs.b;} inline cp operator +(const cp &amp;rhs)const{ return (cp){a+rhs.a, b+rhs.b};} inline cp operator -(const cp &amp;rhs)const{ return (cp){a-rhs.a, b-rhs.b};} inline cp operator *(const cp &amp;rhs)const{ return (cp){a*rhs.a-b*rhs.b, a*rhs.b+b*rhs.a};} inline cp operator *(const double rhs)const{ return (cp){a*rhs, b*rhs};} inline cp operator ~()const{ return (cp){a, -b};}} a[L], b[L], c[L], d[L], f[L], g[L], h[L], w[L];inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}inline int Get(int n){ int p=1; while(p&lt;=n) p&lt;&lt;=1; return p;}inline void DFT_(cp *f, int n){ for(register int i=0, j=0; i&lt;n; ++i){ if(i&gt;j) swap(f[i], f[j]); for(register int k=n&gt;&gt;1; (j^=k)&lt;k; k&gt;&gt;=1); } for(register int i=1; i&lt;n; i&lt;&lt;=1) for(register int j=0; j&lt;n; j+=i&lt;&lt;1) for(register int k=j; k&lt;j+i; ++k){ cp t=w[i+k-j]*f[k+i]; f[k+i]=f[k]-t, f[k]+=t; }}inline void DFT(cp *f, int n){ if(n==1) return; n&gt;&gt;=1; static cp a[L/2]; for(register int i=0; i&lt;n; ++i) a[i]=(cp){f[i&lt;&lt;1].a, f[i&lt;&lt;1|1].a}; DFT_(a, n); for(register int i=0; i&lt;n; ++i){ cp q=~a[(n-i)&amp;(n-1)], x=(a[i]+q)*.5, y=(a[i]-q)*(cp){0, -.5}, t=y*w[n+i]; f[i]=x+t, f[n+i]=x-t; }}inline void IDFT(cp *f, int n){ if(n==1) return; reverse(f+1, f+n), n&gt;&gt;=1; static cp a[L/2]; for(register int i=0; i&lt;n; ++i) a[i]=(f[i]+f[i+n])*.5 + (f[i]-f[i+n])*(cp){0, .5}*w[n+i]; DFT_(a, n); double k=1./n; for(register int i=0; i&lt;n; ++i) f[i&lt;&lt;1]=(cp){a[i].a*k, 0}, f[i&lt;&lt;1|1]=(cp){a[i].b*k, 0};}inline void sqr(int *A, int &amp;len){ int n=Get(len*2-2); memset(a, 0, sizeof(cp)*n), memset(b, 0, sizeof(cp)*n); for(int i=0; i&lt;len; ++i) a[i].a=A[i]&gt;&gt;15, b[i].a=A[i]&amp;32767; DFT(a, n), DFT(b, n); for(int i=0; i&lt;n; ++i) f[i]=a[i]*a[i], g[i]=a[i]*b[i]*2, h[i]=b[i]*b[i]; IDFT(f, n), IDFT(g, n), IDFT(h, n); for(int i=0; i&lt;len*2-1 &amp;&amp; i&lt;C; ++i) A[i]=(((ll)(f[i].a+.5)%P&lt;&lt;30)+((ll)(g[i].a+.5)&lt;&lt;15)+(ll)(h[i].a+.5))%P; for(int i=C; i&lt;len*2-1; ++i) A[i-C]=(A[i-C]+(((ll)(f[i].a+.5)%P&lt;&lt;30)+((ll)(g[i].a+.5)&lt;&lt;15)+(ll)(h[i].a+.5)))%P; len=min(C, len*2-1);}void mul(int *A, int *B, int &amp;lena, int lenb){ int n=Get(lena+lenb-2); memset(a, 0, sizeof(cp)*n), memset(b, 0, sizeof(cp)*n); memset(c, 0, sizeof(cp)*n), memset(d, 0, sizeof(cp)*n); for(int i=0; i&lt;lena; ++i) a[i].a=A[i]&gt;&gt;15, b[i].a=A[i]&amp;32767; for(int i=0; i&lt;lenb; ++i) c[i].a=B[i]&gt;&gt;15, d[i].a=B[i]&amp;32767; DFT(a, n), DFT(b, n), DFT(c, n), DFT(d, n); for(int i=0; i&lt;n; ++i) f[i]=a[i]*c[i], g[i]=a[i]*d[i]+b[i]*c[i], h[i]=b[i]*d[i]; IDFT(f, n), IDFT(g, n), IDFT(h, n); for(int i=0; i&lt;lena+lenb-1 &amp;&amp; i&lt;C; ++i) A[i]=(((ll)(f[i].a+.5)%P&lt;&lt;30)+((ll)(g[i].a+.5)&lt;&lt;15)+(ll)(h[i].a+.5))%P; for(int i=C; i&lt;lena+lenb-1; ++i) A[i-C]=(A[i-C]+(((ll)(f[i].a+.5)%P&lt;&lt;30)+((ll)(g[i].a+.5)&lt;&lt;15)+(ll)(h[i].a+.5)))%P; lena=min(lena+lenb-1, C);}inline void solve(int *ans, int n){ memset(ans, 0, C&lt;&lt;2), memset(x, 0, C&lt;&lt;2), x[0]=x[2]=1, ans[0]=1; int lenx=3, lena=1; for(; n; n&gt;&gt;=1, sqr(x, lenx)) if(n&amp;1) mul(ans, x, lena, lenx);}int main() { for(int i=1; i&lt;L; i&lt;&lt;=1){ w[i]=(cp){1, 0}; for(int j=1; j&lt;i; ++j) w[i+j]=((j&amp;31)==1?(cp){cos(Pi*j/i), sin(Pi*j/i)}:w[i+j-1]*w[i+1]); } scanf(&quot;%d%d&quot;, &amp;C, &amp;m); solve(Ans, m); printf(&quot;%d\\n&quot;, Ans[m%C]); return 0;} FlairLOJ #6132. 「2017 山东三轮集训 Day1」Flair 性质令最大的两个数的乘积为 $a$，所有数的 $\\gcd$ 为 $b$，选择了 $i$ 个的浪费是 $f_i$ 对于 $i\\ge a$ 有 $f_i=f_{i+b}$ 那么我们做长度为 $b$ 的循环卷积快速幂，对于 $a$ 以内的特判就好了 考试的时候没带脑子 有些细节不管复杂度就是 $\\mathcal O(b\\log b\\log n + m\\times a)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ll long longconst double Pi=acos(-1);const int N = 10005, M = 105, P = 1000000007, L = 1&lt;&lt;15;int T, n, m, p, mx, mn, C[M], s[N], Ans[N], x[N];struct cp{ double a, b; inline void operator +=(const cp &amp;rhs){ a+=rhs.a, b+=rhs.b;} inline cp operator +(const cp &amp;rhs)const{ return (cp){a+rhs.a, b+rhs.b};} inline cp operator -(const cp &amp;rhs)const{ return (cp){a-rhs.a, b-rhs.b};} inline cp operator *(const cp &amp;rhs)const{ return (cp){a*rhs.a-b*rhs.b, a*rhs.b+b*rhs.a};} inline cp operator *(const double rhs)const{ return (cp){a*rhs, b*rhs};} inline cp operator ~()const{ return (cp){a, -b};}} a[L], b[L], c[L], d[L], f[L], g[L], h[L], w[L];int gcd(int x, int y){ return y?gcd(y, x%y):x;}inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}inline int Get(int n){ int p=1; while(p&lt;=n) p&lt;&lt;=1; return p;}inline void DFT_(cp *f, int n){ for(register int i=0, j=0; i&lt;n; ++i){ if(i&gt;j) swap(f[i], f[j]); for(register int k=n&gt;&gt;1; (j^=k)&lt;k; k&gt;&gt;=1); } for(register int i=1; i&lt;n; i&lt;&lt;=1) for(register int j=0; j&lt;n; j+=i&lt;&lt;1) for(register int k=j; k&lt;j+i; ++k){ cp t=w[i+k-j]*f[k+i]; f[k+i]=f[k]-t, f[k]+=t; }}inline void DFT(cp *f, int n){ if(n==1) return; n&gt;&gt;=1; static cp a[L/2]; for(register int i=0; i&lt;n; ++i) a[i]=(cp){f[i&lt;&lt;1].a, f[i&lt;&lt;1|1].a}; DFT_(a, n); for(register int i=0; i&lt;n; ++i){ cp q=~a[(n-i)&amp;(n-1)], x=(a[i]+q)*.5, y=(a[i]-q)*(cp){0, -.5}, t=y*w[n+i]; f[i]=x+t, f[n+i]=x-t; }}inline void IDFT(cp *f, int n){ if(n==1) return; reverse(f+1, f+n), n&gt;&gt;=1; static cp a[L/2]; for(register int i=0; i&lt;n; ++i) a[i]=(f[i]+f[i+n])*.5 + (f[i]-f[i+n])*(cp){0, .5}*w[n+i]; DFT_(a, n); double k=1./n; for(register int i=0; i&lt;n; ++i) f[i&lt;&lt;1]=(cp){a[i].a*k, 0}, f[i&lt;&lt;1|1]=(cp){a[i].b*k, 0};}inline void sqr(int *A, int &amp;len){ int n=Get(len*2-2); memset(a, 0, sizeof(cp)*n), memset(b, 0, sizeof(cp)*n); for(int i=0; i&lt;len; ++i) a[i].a=A[i]&gt;&gt;15, b[i].a=A[i]&amp;32767; DFT(a, n), DFT(b, n); for(int i=0; i&lt;n; ++i) f[i]=a[i]*a[i], g[i]=a[i]*b[i]*2, h[i]=b[i]*b[i]; IDFT(f, n), IDFT(g, n), IDFT(h, n); for(int i=0; i&lt;len*2-1 &amp;&amp; i&lt;mn; ++i) A[i]=(((ll)(f[i].a+.5)%P&lt;&lt;30)+((ll)(g[i].a+.5)&lt;&lt;15)+(ll)(h[i].a+.5))%P; for(int i=mn; i&lt;len*2-1; ++i) A[i-mn]=(A[i-mn]+(((ll)(f[i].a+.5)%P&lt;&lt;30)+((ll)(g[i].a+.5)&lt;&lt;15)+(ll)(h[i].a+.5)))%P; len=min(mn, len*2-1);}void mul(int *A, int *B, int &amp;lena, int lenb){ int n=Get(lena+lenb-2); memset(a, 0, sizeof(cp)*n), memset(b, 0, sizeof(cp)*n); memset(c, 0, sizeof(cp)*n), memset(d, 0, sizeof(cp)*n); for(int i=0; i&lt;lena; ++i) a[i].a=A[i]&gt;&gt;15, b[i].a=A[i]&amp;32767; for(int i=0; i&lt;lenb; ++i) c[i].a=B[i]&gt;&gt;15, d[i].a=B[i]&amp;32767; DFT(a, n), DFT(b, n), DFT(c, n), DFT(d, n); for(int i=0; i&lt;n; ++i) f[i]=a[i]*c[i], g[i]=a[i]*d[i]+b[i]*c[i], h[i]=b[i]*d[i]; IDFT(f, n), IDFT(g, n), IDFT(h, n); for(int i=0; i&lt;lena+lenb-1 &amp;&amp; i&lt;mn; ++i) A[i]=(((ll)(f[i].a+.5)%P&lt;&lt;30)+((ll)(g[i].a+.5)&lt;&lt;15)+(ll)(h[i].a+.5))%P; for(int i=mn; i&lt;lena+lenb-1; ++i) A[i-mn]=(A[i-mn]+(((ll)(f[i].a+.5)%P&lt;&lt;30)+((ll)(g[i].a+.5)&lt;&lt;15)+(ll)(h[i].a+.5)))%P; lena=min(lena+lenb-1, mn);}inline void solve(int *ans, int n){ memset(ans, 0, mn&lt;&lt;2), memset(x, 0, mn&lt;&lt;2), x[0]=100-p, x[1]=p, ans[0]=1; int lenx=2, lena=1; for(; n; n&gt;&gt;=1, sqr(x, lenx)){ if(n&amp;1) mul(ans, x, lena, lenx); }}int main() { freopen(&quot;flair.in&quot;, &quot;r&quot;, stdin); freopen(&quot;flair.out&quot;, &quot;w&quot;, stdout); for(int i=1; i&lt;L; i&lt;&lt;=1){ w[i]=(cp){1, 0}; for(int j=1; j&lt;i; ++j) w[i+j]=((j&amp;31)==1?(cp){cos(Pi*j/i), sin(Pi*j/i)}:w[i+j-1]*w[i+1]); } scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;p); for(int i=1; i&lt;=m; ++i) scanf(&quot;%d&quot;, C+i); if(m==1) mx=C[1]; else sort(C+1, C+m+1), mx=C[m]*C[m-1]; mn=C[1]; for(int i=2; i&lt;=m; ++i) mn=gcd(mn, C[i]); solve(Ans, n); int ans=0; for(int i=1; i&lt;mn; ++i) ans=(ans+(ll)Ans[i]*(mn-i))%P; // for(int i=0; i&lt;mn &amp;&amp; i&lt;=16; ++i) printf(&quot;[%d]\\n&quot;, Ans[i]); puts(&quot;&quot;); memset(s, 0, (mx+1)&lt;&lt;2); s[0]=1; for(int i=1; i&lt;=m; ++i) for(int j=C[i]; j&lt;mx; ++j) s[j]|=s[j-C[i]]; for(int i=mx-1; ~i; --i) s[i]=(s[i]?0:s[i+1]+1); for(int i=0, k=1; i&lt;mx &amp;&amp; i&lt;=n; k=(ll)k*(n-i)%P*Pow(i+1)%P, ++i) ans=(ans+(ll)Pow(p, i)*Pow(100-p, n-i)%P*k%P*(s[i]-(i+mn-1)/mn*mn+i))%P; printf(&quot;%d\\n&quot;, (ans+P)%P); } return 0;}","link":"/fft-optimization/"},{"title":"多项式的多点求值和快速插值","text":"前言常数好大 多点求值描述给一个 $n-1$ 次的多项式 $f(x)$ 和 $m$ 个位置 $x_0,x_1,..,x_{m-1}$，求$f(x_0),f(x_1),..,f(x_{m-1})$ 暴力做法不难发现 $$f(x_0)\\equiv f(x)\\pmod{(x-x_0)}$$ 因为设 $f(x)=d(x)(x-x_0)+r$，显然有$f(x_0)=r$ 于是我们可以分治，设 $$\\begin{align}L(x)&amp;=\\prod_{i=0}^{\\lfloor\\frac{m}{2}\\rfloor}(x-x_i) \\R(x)&amp;=\\prod_{i=\\lfloor\\frac{m}{2}\\rfloor+1}^{m-1}(x-x_i)\\end{align}$$ 对于 $0\\le i\\le \\lfloor\\frac{m}{2}\\rfloor$，有 $f(x_i)=(f\\ mod\\ L)(x_i)$ 对于 $\\lfloor\\frac{m}{2}\\rfloor&lt;i&lt;m$，有 $f(x_i)=(f\\ mod\\ R)(x_i)$ 可以把次数减少一半 求出每个 $L(x)$ 和 $R(x)$ 可以用分治FFT，复杂度和后面的取模相同 $n,m$ 同阶，总复杂度 $\\mathcal O(m\\log^2m)$ 插值描述给 $n$ 个点 $(x_0,y_0),(x_1,y_1),..,(x_{n-1},y_{n-1})$，求一个 $n-1$ 次多项式 $f(x)$ 满足 $f(x_i)=y_i$ 暴力有 $\\mathcal O(n^2)$ 拉格朗日插值，这里不展开 快速做法还是考虑拉格朗日插值 $$f(x)=\\sum_{i=0}^{n-1}\\frac {\\prod_{j\\ne i}(x-x_j)} {\\prod_{j\\ne i}(x_i-x_j)}y_i$$ 先计算每个 $\\prod_{j\\ne i}(x_i-x_j)$ 设 $$\\begin{align}M(x)&amp;=\\prod_{i=0}^{n-1} (x-x_i) \\g_i(x)&amp;=\\frac{M(x)}{x-x_i}\\end{align}$$ 那么 $$\\prod_{j\\ne i}(x_i-x_j)=g_i(x_i)$$ 分子分母都是 $0$，根据洛必达法则 $$\\prod_{j\\ne i}(x_i-x_j)=g_i(x_i)=M’(x_i)$$ 于是可以使用多点求值在 $\\mathcal O(n\\log^2n)$ 的时间内求得 设 $z_i=\\frac{y_i}{\\prod_{j\\ne i}(x_i-x_j)}$，问题就是求 $f(x)=\\sum_{i=0}^{n-1}z_i\\prod_{j\\ne i}(x-x_j)$ 可以分治FFT，同样地设 $$\\begin{align}L(x)&amp;=\\prod_{i=0}^{\\lfloor\\frac{n}{2}\\rfloor}(x-x_i) \\R(x)&amp;=\\prod_{i=\\lfloor\\frac{n}{2}\\rfloor+1}^{n-1}(x-x_i)\\end{align}$$ 于是 $$f(x)=R(x)\\sum_{i=0}^{\\lfloor\\frac{n}{2}\\rfloor}z_i\\prod_{0\\le j\\le \\lfloor\\frac{n}{2}\\rfloor,j\\ne i}(x-x_j)+L(x)\\sum_{i=\\lfloor\\frac{n}{2}\\rfloor+1}^{n-1}\\prod_{\\lfloor\\frac{n}{2}\\rfloor&lt;j&lt;n,j\\ne i}(x-x_j)$$ 总复杂度还是 $\\mathcal O(n\\log^2n)$ 例题NFLSOJ #53. 多项式多点求值和多点插值模板 这是一个不完整的多项式板子. 之后会放一个比较全的 在这里**挑战多项式** 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;vector&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }int n, m;vector&lt;int&gt; x, y, z;namespace Poly{ const int P = 998244353; vector&lt;int&gt; ans;// for Evaluate() vector&lt;vector&lt;int&gt;&gt; p;// for Evaluate() &amp; Interpolate() inline int Pow(ll x, int y=P-2){ // x^y int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans; } inline int Ge(int x){ int n=1; while(n&lt;=x) n&lt;&lt;=1; return n;} inline int Mod(int x){ return x&lt;P?x:x-P;} inline void NTT(vector&lt;int&gt; &amp;f, int g, int n){ f.resize(n); for(int i=0, j=0; i&lt;n; ++i){ if(i&gt;j) swap(f[i], f[j]); for(int k=n&gt;&gt;1; (j^=k)&lt;k; k&gt;&gt;=1); } vector&lt;int&gt; w(n&gt;&gt;1); for(int i=1; i&lt;n; i&lt;&lt;=1){ for(int j=w[0]=1, w0=(g==1?Pow(3, (P-1)/i/2):Pow(Pow(3, (P-1)/i/2))); j&lt;i; ++j) w[j]=(ll)w[j-1]*w0%P; for(int j=0; j&lt;n; j+=i&lt;&lt;1){ for(int k=j; k&lt;j+i; ++k){ int t=(ll)f[k+i]*w[k-j]%P; f[k+i]=Mod(f[k]-t+P); f[k]=Mod(f[k]+t); } } } if(g==-1) for(int i=0, I=Pow(n); i&lt;n; ++i) f[i]=(ll)f[i]*I%P; } inline vector&lt;int&gt; Add(const vector&lt;int&gt; &amp;f, const vector&lt;int&gt; &amp;g){ vector&lt;int&gt; ans=f; for(unsigned i=0; i&lt;f.size(); ++i) (ans[i]+=g[i])%=P; return ans; } inline vector&lt;int&gt; Mul(const vector&lt;int&gt; &amp;f, const vector&lt;int&gt; &amp;g){// f*g vector&lt;int&gt; F=f, G=g; int p=Ge(f.size()+g.size()-2); NTT(F, 1, p), NTT(G, 1, p); for(int i=0; i&lt;p; ++i) F[i]=(ll)F[i]*G[i]%P; NTT(F, -1, p); return F.resize(f.size()+g.size()-1), F; } inline vector&lt;int&gt; PolyInv(const vector&lt;int&gt; &amp;f, int n=-1){// 1/f if(n==-1) n=f.size(); vector&lt;int&gt; ans; if(n==1) return ans.push_back(Pow(f[0])), ans; ans=PolyInv(f, (n+1)/2); vector&lt;int&gt; tmp(&amp;f[0], &amp;f[0]+n); int p=Ge(n*2-2); NTT(tmp, 1, p), NTT(ans, 1, p); for(int i=0; i&lt;p; ++i) ans[i]=(2-(ll)ans[i]*tmp[i]%P+P)*ans[i]%P; NTT(ans, -1, p); return ans.resize(n), ans; } inline void PolyDiv(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b, vector&lt;int&gt; &amp;d, vector&lt;int&gt; &amp;r){//a=d*b+r if(b.size()&gt;a.size()) return (void)(d.clear(), r=a); vector&lt;int&gt; A=a, B=b, iB; int n=a.size(), m=b.size(); reverse(A.begin(), A.end()), reverse(B.begin(), B.end()); B.resize(n-m+1), iB=PolyInv(B, n-m+1); d=Mul(A, iB); d.resize(n-m+1), reverse(d.begin(), d.end()); r=Mul(b, d); for(int i=0; i&lt;m-1; ++i) r[i]=(P+a[i]-r[i])%P; r.resize(m-1); } inline vector&lt;int&gt; Derivative(const vector&lt;int&gt; &amp;a){ // a' vector&lt;int&gt; ans; ans.resize(a.size()-1); for(unsigned i=1; i&lt;a.size(); ++i) ans[i-1]=(ll)a[i]*i%P; return ans; } void Evaluate_Interpolate_Init(int l, int r, int t, const vector&lt;int&gt; &amp;a){ if(l==r) return p[t].clear(), p[t].push_back(P-a[l]), p[t].push_back(1); int mid=(l+r)/2, k=t&lt;&lt;1; Evaluate_Interpolate_Init(l, mid, k, a), Evaluate_Interpolate_Init(mid+1, r, k|1, a); p[t]=Mul(p[k], p[k|1]); } inline void Evaluate(int l, int r, int t, const vector&lt;int&gt; &amp;f, const vector&lt;int&gt; &amp;a){ if(r-l+1&lt;=512){ for(int i=l; i&lt;=r; ++i){ int x=0, j=f.size(), a1=a[i], a2=(ll)a[i]*a[i]%P, a3=(ll)a[i]*a2%P, a4=(ll)a[i]*a3%P, a5=(ll)a[i]*a4%P, a6=(ll)a[i]*a5%P, a7=(ll)a[i]*a6%P, a8=(ll)a[i]*a7%P; while(j&gt;=8) x=((ll)x*a8+(ll)f[j-1]*a7+(ll)f[j-2]*a6+(ll)f[j-3]*a5+(ll)f[j-4]*a4+(ll)f[j-5]*a3+(ll)f[j-6]*a2+(ll)f[j-7]*a1+f[j-8])%P, j-=8; while(j--) x=((ll)x*a[i]+f[j])%P; ans.push_back(x); } return; } vector&lt;int&gt; tmp; PolyDiv(f, p[t], tmp, tmp); Evaluate(l, (l+r)/2, t&lt;&lt;1, tmp, a), Evaluate((l+r)/2+1, r, t&lt;&lt;1|1, tmp, a); } inline vector&lt;int&gt; Evaluate(const vector&lt;int&gt; &amp;f, const vector&lt;int&gt; &amp;a, int flag=-1){// f(a_i) if(flag==-1) p.resize(a.size()&lt;&lt;2), Evaluate_Interpolate_Init(0, a.size()-1, 1, a); ans.clear(), Evaluate(0, a.size()-1, 1, f, a); return ans; } vector&lt;int&gt; Interpolate(int l, int r, int t, const vector&lt;int&gt; &amp;x, const vector&lt;int&gt; &amp;f){ if(l==r){ vector&lt;int&gt; ans; return ans.push_back(f[l]), ans; } int mid=(l+r)/2, k=t&lt;&lt;1; return Add(Mul(Interpolate(l, mid, k, x, f), p[k|1]), Mul(Interpolate(mid+1, r, k|1, x, f), p[k])); } inline vector&lt;int&gt; Interpolate(const vector&lt;int&gt; &amp;x, const vector&lt;int&gt; &amp;y){// (x_i,y_i) int n=x.size(); p.resize(n&lt;&lt;2), Evaluate_Interpolate_Init(0, n-1, 1, x); vector&lt;int&gt; f=Evaluate(Derivative(p[1]), x, 0); for(int i=0; i&lt;n; ++i) f[i]=(ll)y[i]*Pow(f[i])%P; return Interpolate(0, n-1, 1, x, f); }}using namespace Poly;int main() { read(n), x.resize(n), y.resize(n); for(int i=0; i&lt;n; ++i) read(x[i]), read(y[i]); read(m), z.resize(m); for(int i=0; i&lt;m; ++i) read(z[i]); x=Evaluate(Interpolate(x, y), z); for(int i:x) print(i), print(' '); return flush(), 0;}","link":"/fast-polynomial-evaluation-and-interpolation/"},{"title":"单位根反演","text":"恒等式$$[d|n]=\\frac{1}{d} \\sum_{i=0}^{d-1} \\omega_d^{i\\times n}$$ 其中 $\\omega_d$ 是 $d$ 次单位根 当 $d|n$，右边和式中每一项都为 $1$ 当 $d\\nmid n$，容易得到右边为 $0$ 例题PYXFIBBZOJ 3328: PYXFIB 题意令数列 $f_0=f_1=1,f_n=f_{n-1}+f_{n-2}$ 给出 $n,k,p$ 求 $$\\sum_{i=0}^{\\lfloor \\frac{n}{k} \\rfloor} \\binom{n}{i\\times k}\\times f_{i\\times k}$$ 模质数 $p$ 的值，且 $p \\equiv 1 \\pmod{k}$ 不超过 $20$ 组数据 $n\\le 10^{18}, p\\le 10^9, k\\le 20000$ 做法所求转化为 $$\\sum_{i=0}^n [k|i] \\binom{n}{i}\\times f_{i}$$ 考虑用递推矩阵代替 $f$ 数列 令 $$A=\\begin{bmatrix}1 &amp; 1 \\1 &amp; 0\\end{bmatrix}$$ 所求即为 $$\\sum_{i=0}^n [k|i] \\binom{n}{i}\\times A^i$$ 第一行第一列的元素 把恒等式代入得到 $$\\begin{aligned}&amp; \\frac{1}{k}\\sum_{i=0}^n \\binom{n}{i}\\times A^i\\sum_{j=0}^{k-1} \\omega_k^{i\\times j} \\= &amp; \\frac{1}{k} \\sum_{j=0}^{k-1} \\sum_{i=1}^n \\binom{n}{i}\\times A^i \\times \\omega_{k}^{i\\times j} \\= &amp; \\frac{1}{k} \\sum_{j=0}^{k-1}\\left(\\omega_k^jA+I \\right)^n\\end{aligned}$$ 最后一步用了二项式定理，其中 $I=\\begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1 \\end{bmatrix}$ 由于保证了 $p \\equiv 1 \\pmod{k}$，直接在模意义下计算 $\\omega_k$ 即可 复杂度 $\\mathcal O(k\\log n)$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ll long longint k, p, T;ll n;struct matrix{ int f[2][2]; inline matrix(){} inline matrix(int a, int b, int c, int d){ f[0][0]=a, f[0][1]=b, f[1][0]=c, f[1][1]=d;} inline matrix operator +(const matrix &amp;rhs)const{ return matrix( (f[0][0]+rhs.f[0][0])%p, (f[0][1]+rhs.f[0][1])%p, (f[1][0]+rhs.f[1][0])%p, (f[1][1]+rhs.f[1][1])%p ); } inline matrix operator *(const int rhs)const{ return matrix( (ll)f[0][0]*rhs%p, (ll)f[0][1]*rhs%p, (ll)f[1][0]*rhs%p, (ll)f[1][1]*rhs%p ); } inline matrix operator *(const matrix &amp;rhs)const{ return matrix( ((ll)f[0][0]*rhs.f[0][0]+(ll)f[0][1]*rhs.f[1][0])%p, ((ll)f[0][0]*rhs.f[0][1]+(ll)f[0][1]*rhs.f[1][1])%p, ((ll)f[1][0]*rhs.f[0][0]+(ll)f[1][1]*rhs.f[1][0])%p, ((ll)f[1][0]*rhs.f[0][1]+(ll)f[1][1]*rhs.f[1][1])%p ); }} A=matrix(1, 1, 1, 0), I=matrix(1, 0, 0, 1);inline int Pow(ll x, int y=p-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%p) if(y&amp;1) ans=ans*x%p; return ans;}inline matrix Pow(matrix x, ll y){ matrix ans=I; for(; y; y&gt;&gt;=1, x=x*x) if(y&amp;1) ans=ans*x; return ans;}inline int getroot(int p){ vector&lt;int&gt; d; for(int i=2, x=p-1; i*i&lt;=x; ++i) if(x%i==0){ d.push_back(p/i), x/=i; while(x%i==0) x/=i; } for(int i=2; i&lt;p; ++i){ for(unsigned j=0; j&lt;d.size(); ++j) if(Pow(i, d[j])==1) goto nxt; return i; nxt:; }}int main() { scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%lld%d%d&quot;, &amp;n, &amp;k, &amp;p); int w=Pow(getroot(p), (p-1)/k); ll ans=0; for(int i=0, now=1; i&lt;k; now=(ll)now*w%p, ++i) ans+=Pow(A*now+I, n).f[0][0]; printf(&quot;%lld\\n&quot;, ans%p*Pow(k)%p); } return 0;} LJJ 学二项式定理LOJ #6485. LJJ 学二项式定理 题意$T$ 组数据，给出 $n,s,a_0,a_1,a_2,a_3$ 求 $$\\left(\\sum_{i=0}^n \\binom{n}{i}\\times s^i\\times a_{i\\bmod 4}\\right) \\bmod 998244353$$ $T\\le 10^5,n\\le 10^{18}$ $s,a_0,a_1,a_2,a_3\\le 10^8$ 做法考虑计算 $i$ 是 $4$ 的倍数情况 $$\\begin{aligned}&amp; \\sum_{i=0}^n [4|i] \\binom{n}{i}\\times s^i\\times a_0 \\= &amp; \\frac{1}{4} \\sum_{i=0}^n \\binom{n}{i}\\times s^i\\times a_0 \\sum_{j=0}^3 \\omega_4^{i\\times j} \\= &amp; \\frac{a_0}{4}\\sum_{j=0}^3 \\sum_{i=0}^n \\omega_4^{i\\times j} \\times \\binom{n}{i}\\times s^i \\= &amp; \\frac{a_0}{4}\\sum_{j=0}^3 (\\omega_4^j\\times s +1)^n\\end{aligned}$$ 其他 $3$ 种情况也类似，以 $i\\equiv 1\\pmod 4$ 为例 $$\\begin{aligned}&amp; \\sum_{i=0}^n [4|(i-1)] \\binom{n}{i}\\times s^i\\times a_1 \\= &amp; \\frac{1}{4} \\sum_{i=0}^n \\binom{n}{i}\\times s^i\\times a_1 \\sum_{j=0}^3 \\omega_4^{(i-1)\\times j} \\= &amp; \\frac{a_1}{4}\\sum_{j=0}^3 \\sum_{i=0}^n \\omega_4^{(i-1)\\times j} \\times \\binom{n}{i}\\times s^i \\= &amp; \\frac{a_1}{4}\\sum_{j=0}^3 \\omega_4^{-j} (\\omega_4^j\\times s +1)^n\\end{aligned}$$ 复杂度 $\\mathcal O(\\log n)$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int P = 998244353, w4 = 911660635, i4 = 748683265;int T, s, a[4];ll n;inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}int main() { read(T); while(T--){ read(n), read(s), read(a[0]), read(a[1]), read(a[2]), read(a[3]), n%=P-1; int ans=0; for(int j=0, w=1, iw=1; j&lt;4; ++j, w=(ll)w*w4%P, iw=(ll)iw*(P-w4)%P){ int t=Pow((ll)s*w%P+1, n); for(int i=0, ww=1; i&lt;4; ++i, ww=(ll)ww*iw%P) ans=(ans+(ll)t*ww%P*a[i])%P; } print((int)((ll)i4*ans%P)), print('\\n'); } return flush(), 0;} 复读机UOJ #450. 【集训队作业2018】复读机 题意有 $k$ 个不同的复读机，接下来 $n$ 秒中每秒都会挑一个复读机复读，一个复读机复读了 $d$ 的倍数次才会感到快乐 求有多少种方案使得所有复读机都感到快乐，模 $19491001$ 三种子任务 $k\\le 500000,d=1$ $k\\le 500000,d=2$ $k\\le 1000,d=3$ $n\\le 10^9$ 做法当 $d=1$ 时，答案即为 $k^n$ $d&gt;1$ 时考虑 dp 令 $f_{i,j}$ 表示 $i$ 个复读机，一共复读了 $j$ 次的方案数（方案不同当且仅当存在第 $x$ 次复读的复读机不同） 于是 $$\\begin{aligned}f_{i,j} &amp; = \\sum_{x=0}^{j} [d|x] f_{i-1,j-x}\\binom{j}{x} \\&amp; = \\frac{1}{d} \\sum_{x=0}^j f_{i-1,j-x} \\binom{j}{x} \\sum_{t=0}^{d-1} \\omega_d^{tx} \\\\frac{f_{i,j}}{j!} &amp;= \\frac{1}{d} \\sum_{x=0}^j \\frac{f_{i-1,j-x}}{(j-x)!} \\times \\frac{\\sum_{t=0}^{d-1} \\omega_d^{tx}}{x!}\\end{aligned}$$ 用生成函数表示第二维的转移即 $$\\begin{aligned}f_i(x) &amp; = \\sum_{j=0}^{\\infty} f_{i,j}x^j \\f_i(x) &amp; = f_{i-1}(x)\\times \\left(\\frac{\\sum_{j=0}^{\\infty} \\sum_{t=0}^{d-1} \\frac{\\omega_d^{tj}}{j!}x^j }{d}\\right) \\f_k(x) &amp; = \\left(\\frac{\\sum_{j=0}^{\\infty} \\sum_{t=0}^{d-1} \\frac{\\omega_d^{tj}}{j!}x^j }{d}\\right) ^k \\&amp; = \\left(\\frac{\\sum_{t=0}^{d-1} \\sum_{j=0}^{\\infty} \\frac{\\omega_d^{tj}}{j!}x^j }{d}\\right) ^k\\end{aligned}$$ 当 $d=2$ 时，展开 $t$ 的枚举，得到 $$\\left(\\sum_{j=0}^{\\infty} \\frac{x^j}{j!}\\right)+\\left(\\sum_{j=0}^{\\infty} \\frac{\\omega_2^j x^j}{j!}\\right) = e^x+e^{\\omega_2x}$$ 其中 $\\omega_2=-1$ 所求 $$\\begin{aligned}f_{k,n} &amp; = n![x^n]f_k(x) \\&amp; = n![x^n]\\left(\\frac{e^x+e^{-x}}{2}\\right)^k \\&amp; = \\frac{n![x^n]\\left(\\sum_{i=0}^k e^{ix} \\times e^{-(k-i)x}\\times \\binom{k}{i}\\right)}{2^k}\\end{aligned}$$ 复杂度 $\\mathcal O(k\\log n)$ $d=3$ 同理，展开 $$\\left( \\frac{e^x+e^{\\omega_3 x}+e^{\\omega_3^2 x}}{3}\\right)^k$$ 枚举其中两项，复杂度 $\\mathcal O(k^2\\log n)$ 代码1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;using namespace std;#define ll long longconst int N = 500005, P = 19491001, w = 18827933, ww = (ll)w*w%P, inv2 = (P+1)/2, inv3 = (P*2+1)/3;int n, k, d, ans, fac[N], ifac[N];inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;k, &amp;d); if(d==1) printf(&quot;%d&quot;, Pow(k, n)); else{ fac[0]=1; for(int i=1; i&lt;=k; ++i) fac[i]=(ll)fac[i-1]*i%P; ifac[k]=Pow(fac[k]); for(int i=k; i; --i) ifac[i-1]=(ll)ifac[i]*i%P; if(d==2){ for(int i=0; i&lt;=k; ++i) ans=(ans+(ll)Pow(i*2-k+P, n)*ifac[i]%P*ifac[k-i])%P; printf(&quot;%lld&quot;, (ll)ans*fac[k]%P*Pow(inv2, k)%P); } else{ for(int i=0; i&lt;=k; ++i) for(int j=0; i+j&lt;=k; ++j) ans=(ans+(ll)Pow((i+(ll)j*w+(ll)(k-i-j)*ww)%P, n)*ifac[i]%P*ifac[j]%P*ifac[k-i-j])%P; printf(&quot;%lld&quot;, (ll)ans*fac[k]%P*Pow(inv3, k)%P); } } return 0;} 倍数？倍数！BZOJ 4314: 倍数？倍数！ 题意求从 $0,1,\\dotsc,n-1$ 选出 $k$ 个互不相同的数和为 $n$ 的倍数的方案数，模 $10^9+7$ $n\\le 10^9, k\\le 1000$ 做法神仙题 膜 YX 大爷 先不考虑 $k$ 的限制，求从 $0,1,\\dotsc,n-1$ 中选出任意个数和为 $n$ 的倍数的方案数 考虑生成函数，答案为 $$f(x) = \\prod_{i=0}^{n-1} (x^i+1) = \\sum_{i=0}^\\infty f_ix^i$$ 的所有 $n$ 的倍数次项系数的和，即 $$\\begin{aligned}&amp; \\sum_{i=0}^\\infty [n|i]\\times f_i \\= &amp; \\frac{1}{n} \\sum_{i=0}^\\infty f_i \\sum_{j=0}^{n-1} \\omega_n^{i\\times j} \\= &amp; \\frac{1}{n} \\sum_{j=0}^{n-1} \\sum_{i=0}^\\infty f_i(\\omega_n^j)^i \\= &amp; \\frac{1}{n} \\sum_{j=0}^{n-1} f(\\omega_n^j) \\= &amp; \\frac{1}{n} \\sum_{j=0}^{n-1} \\prod_{i=0}^{n-1} (\\omega_n^{i\\times j}+1)\\end{aligned}$$ 枚举 $g=\\gcd(j,n)$，由单位根的性质，上式等于 $$\\begin{aligned}&amp; \\frac{1}{n} \\sum_{g|n} \\sum_{j=0}^{\\frac{n}{g} -1} [j \\perp \\frac{n}{g}] \\prod_{i=0}^{n-1} (\\omega_{\\frac{n}{g}}^{i\\times j}+1) \\= &amp; \\frac{1}{n} \\sum_{g|n} \\sum_{j=0}^{\\frac{n}{g} -1} [j \\perp \\frac{n}{g}] \\left( \\prod_{i=0}^{\\frac{n}{g}-1} (\\omega_{\\frac{n}{g}}^{i\\times j}+1)\\right)^g \\\\end{aligned}$$ 由于 $j$ 与 $\\frac{n}{g}$ 互质，上式等于 $$\\begin{aligned}&amp; \\frac{1}{n} \\sum_{g|n} \\sum_{j=0}^{\\frac{n}{g} -1} [j \\perp \\frac{n}{g}] \\left( \\prod_{i=0}^{\\frac{n}{g}-1} (\\omega_{\\frac{n}{g}}^{i}+1)\\right)^g \\= &amp; \\frac{1}{n} \\sum_{g|n} \\varphi(\\frac{n}{g}) \\left( \\prod_{i=0}^{\\frac{n}{g}-1} (\\omega_{\\frac{n}{g}}^{i}+1)\\right)^g\\end{aligned}$$ 考虑单位根的意义 $x^n-1=0=\\prod_{i=0}^{n-1} (x-\\omega_n^i)$ 代入 $x=-1$ 得到 $(-1)^n-1=(-1)^n \\prod_{i=0}^{n-1} (\\omega_n^i+1)$ 因此 $\\prod_{i=0}^{n-1} (\\omega_n^i+1)=1-(-1)^n$ 答案等于 $$\\frac{1}{n} \\sum_{g|n} \\varphi(\\frac{n}{g}) \\left(1-(-1)^{\\frac{n}{g}}\\right)^g$$ 考虑有了选 $k$ 个的限制 答案为 $$[y^k]\\prod_{i=0}^{n-1} (x^iy+1)$$ 的所有 $n$ 的倍数次项系数的和 大致过程与上面相同，把 $y$ 保留，在代入时代入 $-\\frac{1}{y}$，最后得到 $$\\frac{1}{n} \\sum_{g|n} \\varphi(\\frac{n}{g}) \\left(1-(-y)^{\\frac{n}{g}}\\right)^g$$ 求第 $k$ 项系数 要对答案有贡献，记 $d=\\frac{n}{g}$ 必须满足 $d|k$，因此 $\\varphi(d)$ 的部分可以做到 $\\mathcal O(k)$ 另外还要求 $\\binom{g}{\\frac{k}{d}}$，单次 $\\mathcal O(\\frac{k}{d})$，总复杂度 $\\mathcal O(\\sigma_1(k))\\approx \\mathcal O(k\\log \\log k)$ 所以 $k$ 还可以放大一点 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ll long longconst int N = 1005, P = 1000000007;int n, k, ans, cnt, phi[N], prime[N], ifac[N];bool p[N];inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}inline int C(int x, int y){ int ans=1; for(int i=0; i&lt;y; ++i) ans=(ll)ans*(x-i)%P; return (ll)ans*ifac[y]%P;}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k); ifac[0]=1; for(int i=1; i&lt;=k; ++i) ifac[i]=(ll)ifac[i-1]*i%P; ifac[k]=Pow(ifac[k]); for(int i=k; i; --i) ifac[i-1]=(ll)ifac[i]*i%P; phi[1]=1; for(int i=2; i&lt;=k; ++i){ if(!p[i]) phi[i]=i-1, prime[++cnt]=i; for(int j=1; j&lt;=cnt &amp;&amp; i*prime[j]&lt;=k; ++j){ p[i*prime[j]]=1; if(i%prime[j]==0){ phi[i*prime[j]]=phi[i]*prime[j]; break; } else phi[i*prime[j]]=phi[i]*(prime[j]-1); } } for(int i=1; i&lt;=k; ++i) if(k%i==0 &amp;&amp; n%i==0) ans=(ans+(k&amp;1?1ll:(k/i&amp;1?-1ll:1ll))*phi[i]*C(n/i, k/i))%P; return printf(&quot;%lld&quot;, (ll)Pow(n)*(ans+P)%P), 0;}","link":"/identity-of-roots-of-unity-notes/"},{"title":"「LOJ 150」挑战多项式","text":"LOJ #150 题意给定 $n$ 次多项式 $F(x)$，求 $G(x)$ 满足 $$G(x)\\equiv\\left(\\left(1+\\ln\\left(2+F(x)-F(0)-\\exp\\left(\\int\\frac{1}{\\sqrt{F(x)}}\\right)\\right)\\right)^k\\right)’ \\pmod{x^n}$$ 保证常数项是模 $998244353$ 的二次剩余。 注意 $\\pm\\sqrt{F(x)}$ 均为合法解，你只需要输出 $\\sqrt{F(x)}$，舍去 $-\\sqrt{F(x)}$，我们认为两个解中常数项较小的解为 $\\sqrt{F(x)}$。 所有运算在模 $998244353$ 意义下进行。 做法参考多项式一些基础的操作和二次剩余Cipolla’s algorithm 代码存板子为主，里面还有多点求值和快速插值 定期不更新 常数应该还看得过去. $vector$很方便啊 update 2018-12-28 10:40:33 用了定义的模意义的整数，改了 NTT 写法，优化了常数 update 2019-1-15 12:15:02 关于这里面 NTT 的写法，unsigned long long 大约是 $18\\times 10^{18}$ 的范围，由于模意义下数字几乎是随机的，可以认为每层会增加 $\\frac{P}{2}$，其中 $P$ 是 $10^9$ 左右的模数。 而一般要做的至多 $21$ 层，或者常数大的操作本身只有 $2^{18}$，卡不爆 unsigned long long 所以可以认为是对的 如果有能卡掉的请务必告知 update 2019-1-15 12:22:27 关于这个乘法小范围的特判，没搞清楚 vector::size() 是什么类型，不过肯定是 unsigned 的，怕爆 int 还是转 unsigned long long 的靠谱一点吧。 update 2019-1-15 12:27:21 之前的代码里的插值和求值都是错的. 由于只需要用到余数我调用了 PolyDiv(*, *, t, t)，之前单独改除法的时候忘了这个问题就把特判改了改，于是全错了. 现在修复了 update 2019-1-17 11:06:52 小调整 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;vector&gt;using namespace std;#define ull unsigned long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) { if (c == '-') iosig = true; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x + (x &lt;&lt; 2)) &lt;&lt; 1) + (c ^ '0'); if (iosig) x = -x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh = obuf;inline void print(char c) { if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf; *ooh++ = c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x == 0) print('0'); else { if (x &lt; 0) print('-'), x = -x; for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48; while (cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const unsigned N = 1&lt;&lt;18, P = 998244353;struct Z{ unsigned x; Z(const unsigned _x=0):x(_x){} inline Z operator +(const Z &amp;rhs)const{ return x+rhs.x&lt;P?x+rhs.x:x+rhs.x-P;} inline Z operator -(const Z &amp;rhs)const{ return x&lt;rhs.x?x-rhs.x+P:x-rhs.x;} inline Z operator -()const{ return x?P-x:0;} inline Z operator *(const Z &amp;rhs)const{ return static_cast&lt;ull&gt;(x)*rhs.x%P;} inline Z operator +=(const Z &amp;rhs){ return x=x+rhs.x&lt;P?x+rhs.x:x+rhs.x-P, *this;} inline Z operator -=(const Z &amp;rhs){ return x=x&lt;rhs.x?x-rhs.x+P:x-rhs.x, *this;} inline Z operator *=(const Z &amp;rhs){ return x=static_cast&lt;ull&gt;(x)*rhs.x%P, *this;}};int n, k;vector&lt;Z&gt; f;namespace Poly{ Z w[N];// for DFT Z Inv[N];// for Integral vector&lt;Z&gt; ans;// for Evaluate() vector&lt;vector&lt;Z&gt;&gt; p;// for Evaluate() &amp; Interpolate() inline Z Pow(Z x, int y=P-2){ Z ans=1; for(; y; y&gt;&gt;=1, x=x*x) if(y&amp;1) ans=ans*x; return ans; } inline void Init(){ for(unsigned i=1; i&lt;N; i&lt;&lt;=1){ w[i]=1; Z t=Pow(3, (P-1)/i/2); for(unsigned j=1; j&lt;i; ++j) w[i+j]=w[i+j-1]*t; } Inv[1]=1; for(unsigned i=2; i&lt;N; ++i) Inv[i]=Inv[P%i]*(P-P/i); } inline pair&lt;Z,Z&gt; Mul(pair&lt;Z,Z&gt; x, pair&lt;Z,Z&gt; y, Z f){ return make_pair((x.first*y.first+x.second*y.second*f),(x.second*y.first+x.first*y.second)); } inline Z Quadratic_residue(Z a){ if(a.x&lt;=1) return a.x; if(Pow(a, (P-1)/2).x!=1) return -1; Z x, f; do x=(((ull)rand()&lt;&lt;15)^rand())%(a.x-1)+1; while(Pow(f=x*x-a, (P-1)/2).x==1); pair&lt;Z,Z&gt; ans=make_pair(1, 0), t=make_pair(x, 1); for(int i=(P+1)/2; i; i&gt;&gt;=1, t=Mul(t, t, f)) if(i&amp;1) ans=Mul(ans, t, f); return min(ans.first.x, P-ans.first.x); } inline int Get(int x){ int n=1; while(n&lt;=x) n&lt;&lt;=1; return n;} inline void DFT(vector&lt;Z&gt; &amp;f, int n){ static ull F[N]; if((int)f.size()!=n) f.resize(n); for(int i=0, j=0; i&lt;n; ++i){ F[i]=f[j].x; for(int k=n&gt;&gt;1; (j^=k)&lt;k; k&gt;&gt;=1); } for(int i=1; i&lt;n; i&lt;&lt;=1) for(int j=0; j&lt;n; j+=i&lt;&lt;1){ Z *W=w+i; ull *F0=F+j, *F1=F+j+i; for(int k=j; k&lt;j+i; ++k, ++W, ++F0, ++F1){ ull t=(*F1)*(W-&gt;x)%P; (*F1)=*F0+P-t, (*F0)+=t; } } for(int i=0; i&lt;n; ++i) f[i]=F[i]%P; } inline void IDFT(vector&lt;Z&gt; &amp;f, int n){ f.resize(n), reverse(f.begin()+1, f.end()); DFT(f, n); Z I=Pow(n); for(int i=0; i&lt;n; ++i) f[i]=f[i]*I; } inline vector&lt;Z&gt; operator +(const vector&lt;Z&gt; &amp;f, const vector&lt;Z&gt; &amp;g){ vector&lt;Z&gt; ans=f; for(unsigned i=0; i&lt;f.size(); ++i) ans[i]+=g[i]; return ans; } inline vector&lt;Z&gt; operator *(const vector&lt;Z&gt; &amp;f, const vector&lt;Z&gt; &amp;g){ if((ull)f.size()*g.size()&lt;=1000){ vector&lt;Z&gt; ans; ans.resize(f.size()+g.size()-1); for(unsigned i=0; i&lt;f.size(); ++i) for(unsigned j=0; j&lt;g.size(); ++j) ans[i+j]+=f[i]*g[j]; return ans; } static vector&lt;Z&gt; F, G; F=f, G=g; int p=Get(f.size()+g.size()-2); DFT(F, p), DFT(G, p); for(int i=0; i&lt;p; ++i) F[i]*=G[i]; IDFT(F, p); return F.resize(f.size()+g.size()-1), F; } vector&lt;Z&gt; &amp;PolyInv(const vector&lt;Z&gt; &amp;f, int n=-1){ if(n==-1) n=f.size(); if(n==1){ static vector&lt;Z&gt; ans; return ans.clear(), ans.push_back(Pow(f[0])), ans; } vector&lt;Z&gt; &amp;ans=PolyInv(f, (n+1)/2); vector&lt;Z&gt; tmp(&amp;f[0], &amp;f[0]+n); int p=Get(n*2-2); DFT(tmp, p), DFT(ans, p); for(int i=0; i&lt;p; ++i) ans[i]=((Z)2-ans[i]*tmp[i])*ans[i]; IDFT(ans, p); return ans.resize(n), ans; } // a=d*b+r inline void PolyDiv(const vector&lt;Z&gt; &amp;a, const vector&lt;Z&gt; &amp;b, vector&lt;Z&gt; &amp;d, vector&lt;Z&gt; &amp;r){ if(b.size()&gt;a.size()) return d.clear(), (void)(r=a); vector&lt;Z&gt; A=a, B=b, iB; int n=a.size(), m=b.size(); reverse(A.begin(), A.end()), reverse(B.begin(), B.end()); B.resize(n-m+1), iB=PolyInv(B, n-m+1); d=A*iB; d.resize(n-m+1), reverse(d.begin(), d.end()); r=b*d, r.resize(m-1); for(int i=0; i&lt;m-1; ++i) r[i]=a[i]-r[i]; } inline vector&lt;Z&gt; Derivative(const vector&lt;Z&gt; &amp;a){ vector&lt;Z&gt; ans(a.size()-1); for(unsigned i=1; i&lt;a.size(); ++i) ans[i-1]=a[i]*i; return ans; } inline vector&lt;Z&gt; Integral(const vector&lt;Z&gt; &amp;a){ vector&lt;Z&gt; ans(a.size()+1); for(unsigned i=0; i&lt;a.size(); ++i) ans[i+1]=a[i]*Inv[i+1]; return ans; } inline vector&lt;Z&gt; PolyLn(const vector&lt;Z&gt; &amp;f){ vector&lt;Z&gt; ans=Derivative(f)*PolyInv(f); ans.resize(f.size()-1); return Integral(ans); } vector&lt;Z&gt; PolyExp(const vector&lt;Z&gt; &amp;f, int n=-1){ if(n==-1) n=f.size(); if(n==1) return {1}; vector&lt;Z&gt; ans=PolyExp(f, (n+1)/2), tmp; ans.resize(n), tmp=PolyLn(ans); for(Z &amp;i:tmp) i=-i; ++tmp[0].x; ans=ans*(tmp+f); return ans.resize(n), ans; } vector&lt;Z&gt; PolySqrt(const vector&lt;Z&gt; &amp;f, int n=-1){ if(n==-1) n=f.size(); if(n==1) return {Quadratic_residue(f[0])};// ! vector&lt;Z&gt; ans=PolySqrt(f, (n+1)/2), tmp(&amp;f[0], &amp;f[0]+n); ans.resize(n), ans=ans+tmp*PolyInv(ans); for(Z &amp;i:ans) i.x=(i.x&amp;1?(i.x+P)/2:i.x/2); return ans; } inline vector&lt;Z&gt; PolyPower(const vector&lt;Z&gt; &amp;f, int k){ vector&lt;Z&gt; ans=PolyLn(f); for(Z &amp;i:ans) i=i*k; return PolyExp(ans); } void Evaluate_Interpolate_Init(int l, int r, int t, const vector&lt;Z&gt; &amp;a){ if(l==r) return p[t].clear(), p[t].push_back(-a[l]), p[t].push_back(1); int mid=(l+r)/2, k=t&lt;&lt;1; Evaluate_Interpolate_Init(l, mid, k, a), Evaluate_Interpolate_Init(mid+1, r, k|1, a); p[t]=p[k]*p[k|1]; } void Evaluate(int l, int r, int t, const vector&lt;Z&gt; &amp;f, const vector&lt;Z&gt; &amp;a){ if(r-l+1&lt;=512){ for(int i=l; i&lt;=r; ++i){ Z x=0, a1=a[i], a2=a[i]*a[i], a3=a[i]*a2, a4=a[i]*a3, a5=a[i]*a4, a6=a[i]*a5, a7=a[i]*a6, a8=a[i]*a7; int j=f.size(); while(j&gt;=8) x=x*a8+f[j-1]*a7+f[j-2]*a6+f[j-3]*a5+f[j-4]*a4+f[j-5]*a3+f[j-6]*a2+f[j-7]*a1+f[j-8], j-=8; while(j--) x=x*a[i]+f[j]; ans.push_back(x); } return; } vector&lt;Z&gt; tmp; PolyDiv(f, p[t], tmp, tmp); Evaluate(l, (l+r)/2, t&lt;&lt;1, tmp, a), Evaluate((l+r)/2+1, r, t&lt;&lt;1|1, tmp, a); } inline vector&lt;Z&gt; Evaluate(const vector&lt;Z&gt; &amp;f, const vector&lt;Z&gt; &amp;a, int flag=-1){ if(flag==-1) p.resize(a.size()&lt;&lt;2), Evaluate_Interpolate_Init(0, a.size()-1, 1, a); return ans.clear(), Evaluate(0, a.size()-1, 1, f, a), ans; } vector&lt;Z&gt; Interpolate(int l, int r, int t, const vector&lt;Z&gt; &amp;x, const vector&lt;Z&gt; &amp;f){ if(l==r) return {f[l]}; int mid=(l+r)/2, k=t&lt;&lt;1; return Interpolate(l, mid, k, x, f)*p[k|1]+Interpolate(mid+1, r, k|1, x, f)*p[k]; } inline vector&lt;Z&gt; Interpolate(const vector&lt;Z&gt; &amp;x, const vector&lt;Z&gt; &amp;y){ int n=x.size(); p.resize(n&lt;&lt;2), Evaluate_Interpolate_Init(0, n-1, 1, x); vector&lt;Z&gt; f=Evaluate(Derivative(p[1]), x, 0); for(int i=0; i&lt;n; ++i) f[i]=y[i]*Pow(f[i]); return Interpolate(0, n-1, 1, x, f); } inline vector&lt;Z&gt; Solve(const vector&lt;Z&gt; &amp;f, int k){ vector&lt;Z&gt; ans=PolyExp(Integral(PolyInv(PolySqrt(f)))); for(unsigned i=1; i&lt;f.size(); ++i) ans[i]=f[i]-ans[i]; ans=PolyLn(ans); ++ans[0].x; return Derivative(PolyPower(ans, k)); }}int main() { Poly::Init(); read(n), read(k), f.resize(n+1); for(int i=0; i&lt;=n; ++i) read(f[i].x); f=Poly::Solve(f, k), f.resize(n); while(!f[f.size()-1].x) f.erase(f.end()-1); for(Z i:f) print(i.x), print(' '); return flush(), 0;}","link":"/loj-150/"},{"title":"ICPC World Finals 2017 题解","text":"在 LOJ 上有翻译题面 一份英文题解 总算搞完了 = = A. Airport Construction题意有一个 $n$ 个顶点的简单多边形，求多边形内部最长线段的长度。 $n\\le 200$。 保证相邻两条边不共线。 做法最长线段一定经过了至少两个顶点，枚举这两个顶点，直接计算这条直线在多边形内部的每个连续段的长度。 具体地，若直线与一条边（不包含端点）相交，则根据方向不同，记交的权值为 $2$ 或 $-2$；若与边的一端点相交，根据方向不同，记权值为 $1$ 或 $-1$。 从多边形外按照顺序枚举每个相交的事件，累加权值如果为 $0$ 则表示当前在多边形外部，否则在内部。 这里涉及到直线求交 = = 假设直线为 $AB$ 和 $CD$，在这里一种比较方便的办法是 $$k_1\\times \\overrightarrow{AB}-\\overrightarrow{AC}=k_2\\times \\overrightarrow{CD}$$ 由平行，两边叉积为零，可以得到 $$k_1=\\frac{\\overrightarrow{AC}\\times \\overrightarrow{CD}}{\\overrightarrow{AB} \\times \\overrightarrow{CD}}$$ $k_1\\times |AB|$ 即 $A$ 到交点的有向距离。 复杂度 $O(n^3\\log n)$。 代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 205;const double eps = 1e-10;int sgn(long double x){ return x&lt;-eps?-1:(x&gt;eps?1:0);}struct item{ long double x, y; inline item operator -(const item &amp;r)const{ return (item){x-r.x, y-r.y};} inline long double operator ^(const item &amp;r)const{ return x*r.y-y*r.x;}} p[N];int n, cnt;long double ans;pair&lt;long double,int&gt; f[N];inline long double dis(item a, item b){ return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}inline long double dis(item a, item b, item c, item d){ return ((c-a)^(d-c))/((b-a)^(d-c))*dis(a, b);}int main() { scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) scanf(&quot;%Lf%Lf&quot;, &amp;p[i].x, &amp;p[i].y); for(int a=1; a&lt;=n; ++a) for(int b=a+1; b&lt;=n; ++b){ item ab=p[b]-p[a]; cnt=0; for(int i=1; i&lt;=n; ++i){ int sgn1=sgn(ab^(p[i]-p[a])), sgn2=sgn(ab^(p[i%n+1]-p[a])); if(sgn1!=sgn2) f[++cnt]=make_pair(dis(p[a], p[b], p[i], p[i%n+1]), sgn(sgn1-sgn2)*(1+(sgn1 &amp;&amp; sgn2))); } sort(f+1, f+cnt+1); int now=0; long double len=0; for(int i=1; i&lt;=cnt; ++i){ if(now) len+=f[i].first-f[i-1].first; else ans=max(ans, len), len=0; now+=f[i].second; } ans=max(ans, len); } return printf(&quot;%.9Lf&quot;, ans), 0;} B. Get a Clue!题意有 $6$ 张写着不同角色的卡， $6$ 张写着不同武器的卡和 $9$ 张写着不同房间的卡。 $4$ 个人玩游戏，三种卡各有一张缺失，$1,2$ 号玩家初始得到 $5$ 张卡，$3,4$ 号玩家得到 $4$ 张。 你是 $1$ 号，你不知道别人手上的卡，你需要确定缺失的三张卡。 游戏进行了 $n$ 轮，从 $1$ 开始，按照 $1 \\to 2 \\to 3 \\to 4 \\to 1$ 的顺序轮流发起。 每次发起者提出一种缺失的三张卡的方案，从发起者下一个人开始，按照上述顺序，如果一个人手上存在方案中的卡，那么轮到他时必须提出反对，发起者可以知道这张卡上面的内容，其余人无法知道内容。如果有多张，他可以任意挑一张。 现在给出每轮你能知道的全部信息，求每种卡中是否能确定丢失的是什么，如果可以确定需要输出是什么。 $n\\le 50$。 做法暴力题。 当然也可以有理有据，考虑每个人卡的集合根据已知信息是否合法是独立的（除非两个人的集合冲突）。 处理出每个人的合法集合，暴力子集卷积得到所有可能的缺失方案。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 55, M = 1&lt;&lt;16, K = 21;int n, c1, c2, c3, cnt, cnt1, cnt2, cnt3, id[K], a[N], len[N], pcnt[M];char c[15], s[N][15];bool ans[K], f[M], g[M], h[M];int main() { cin&gt;&gt;n, cin.get(), cin.getline(c, 12); for(int i=0; i&lt;9; i+=2) id[c[i]-'A']=20; for(int i=0; i&lt;21; ++i) if(id[i]&lt;20) id[i]=cnt++; for(int i=0; i&lt;n; ++i){ cin.getline(s[i], 12), len[i]=strlen(s[i]); a[i]=(1&lt;&lt;id[s[i][0]-'A'])|(1&lt;&lt;id[s[i][2]-'A'])|(1&lt;&lt;id[s[i][4]-'A']); } for(int i=1; i&lt;1&lt;&lt;16; ++i){ pcnt[i]=pcnt[i&gt;&gt;1]+(i&amp;1); if(pcnt[i]==5){ f[i]=1; for(int j=0; j&lt;n; ++j){ int p=4+((81-j)&amp;3)*2; if(4&lt;p &amp;&amp; p&lt;len[j] &amp;&amp; ((s[j][p]=='-' &amp;&amp; (i&amp;a[j])) || (s[j][p]=='*' &amp;&amp; !(i&amp;a[j])) || (isupper(s[j][p]) &amp;&amp; !(i&gt;&gt;id[s[j][p]-'A']&amp;1)))) f[i]=0; } } if(pcnt[i]==4){ g[i]=h[i]=1; for(int j=0; j&lt;n; ++j){ int p=4+((82-j)&amp;3)*2; if(4&lt;p &amp;&amp; p&lt;len[j] &amp;&amp; ((s[j][p]=='-' &amp;&amp; (i&amp;a[j])) || (s[j][p]=='*' &amp;&amp; !(i&amp;a[j])) || (isupper(s[j][p]) &amp;&amp; !(i&gt;&gt;id[s[j][p]-'A']&amp;1)))) g[i]=0; p=4+((83-j)&amp;3)*2; if(4&lt;p &amp;&amp; p&lt;len[j] &amp;&amp; ((s[j][p]=='-' &amp;&amp; (i&amp;a[j])) || (s[j][p]=='*' &amp;&amp; !(i&amp;a[j])) || (isupper(s[j][p]) &amp;&amp; !(i&gt;&gt;id[s[j][p]-'A']&amp;1)))) h[i]=0; } } } for(int i=1&lt;&lt;16, j; i--;) if(pcnt[i]==9) for(j=i, f[i]=0; j; j=(j-1)&amp;i) if(f[j] &amp;&amp; g[i^j]){ f[i]=1; break;}; for(int i=1&lt;&lt;16, j; i--;) if(pcnt[i]==13) for(j=i, f[i]=0; j; j=(j-1)&amp;i) if(f[j] &amp;&amp; h[i^j]){ f[i]=1; break;}; for(int i=0; i&lt;6; ++i) for(int j=6; j&lt;12; ++j) for(int k=12; k&lt;21; ++k) if(id[i]&lt;20 &amp;&amp; id[j]&lt;20 &amp;&amp; id[k]&lt;20 &amp;&amp; f[(1&lt;&lt;16)-1-(1&lt;&lt;id[i])-(1&lt;&lt;id[j])-(1&lt;&lt;id[k])]) cnt1+=!ans[i], cnt2+=!ans[j], cnt3+=!ans[k], ans[i]=ans[j]=ans[k]=1, c1=i, c2=j, c3=k; printf(&quot;%c%c%c&quot;, cnt1==1?'A'+c1:'?', cnt2==1?'A'+c2:'?', cnt3==1?'A'+c3:'?'); return 0;} C. Mission Improbable题意有一个 $r$ 行 $c$ 列网格，每个格子上堆了若干立方体。 现在要在保证主视图，俯视图，左视图不变的情况下，拿走尽量多的立方体，求一种方案。 即保持每行每列最多的格子堆的立方体高度和每个格子是否存在立方体不变。 注意某一格的高度可以增加。 $r,c\\le 100$。 做法先把所有存在立方体的格子拿到只剩下一个。 接下来要在每行和每列安排一个最大值，尽量使得这些最大值重合。 一个位置可以重合当且仅当其原先存在立方体，且所在行列的最大值相同。 显然是一个二分图匹配问题，考虑到虽然边带权，但是每个联通块内边权相同，因此直接匈牙利即可。 复杂度 $O(rc\\times(r+c))$。 代码1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 102;int n, m, p[N], a[N], b[N], f[N][N];bool vis[N];ll ans;vector&lt;int&gt; e[N];bool match(int x){ for(int i:e[x]) if(!vis[i]){ vis[i]=1; if(!p[i] || match(p[i])) return p[i]=x, 1; } return 0;}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=m; ++j){ scanf(&quot;%d&quot;, f[i]+j); if(f[i][j]) ans+=f[i][j]-1, a[i]=max(a[i], f[i][j]), b[j]=max(b[j], f[i][j]); } for(int i=1; i&lt;=n; ++i) if(a[i]) ans-=a[i]-1; for(int i=1; i&lt;=m; ++i) if(b[i]) ans-=b[i]-1; for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=m; ++j) if(f[i][j] &amp;&amp; a[i]==b[j]) e[i].push_back(j); for(int i=1; i&lt;=n; ++i) match(i), memset(vis, 0, sizeof vis); for(int i=1; i&lt;=m; ++i) if(p[i]) ans+=b[i]-1; return printf(&quot;%lld&quot;, ans), 0;} D. Money for Nothing题意二维平面上有 $m$ 个一类点和 $n$ 个二类点，求以一个一类点作为左下角，和以一个二类点作为右上角，且边平行于坐标轴的矩形的最大面积。 $n,m\\le 5\\times 10^5$。 做法考虑以横坐标排序，只有纵坐标前缀极值的一些点有用，并且按顺序枚举左下角，最优的右上角的是单调的。 每次暴力找到中点的最优匹配点，分治计算即可。 复杂度 $O(n+m\\log n)$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ll long longconst int IN_LEN = 1000000;char buf[IN_LEN], *s, *t;inline char read() { return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}inline void read(int &amp;x) { static char c; while(isspace(c=read())); x=c-'0'; while(isdigit(c=read())) x=x*10+c-'0';}#define x first#define y secondconst int N = 500005;int m, n, nn, mm;ll ans;pair&lt;int,int&gt; a[N], b[N];void solve(int l1, int r1, int l2, int r2){ int mid=(l1+r1)&gt;&gt;1; ll now=0, x=0; for(int i=l2; i&lt;=r2 &amp;&amp; a[mid].y&lt;=b[i].y; ++i) if(a[mid].x&lt;=b[i].x &amp;&amp; (ll)(b[i].x-a[mid].x)*(b[i].y-a[mid].y)&gt;=now) now=(ll)(b[i].x-a[mid].x)*(b[i].y-a[mid].y), x=i; ans=max(ans, now); if(l1&lt;mid) solve(l1, mid-1, l2, x); if(mid&lt;r1) solve(mid+1, r1, x, r2);}int main() { read(m), read(n), mm=nn=1; for(int i=1; i&lt;=m; ++i) read(a[i].x), read(a[i].y); sort(a+1, a+m+1); for(int i=2; i&lt;=m; ++i) if(a[i].y&lt;a[mm].y) a[++mm]=a[i]; for(int i=1; i&lt;=n; ++i) read(b[i].x), read(b[i].y); sort(b+1, b+n+1), reverse(b+1, b+n+1); for(int i=2; i&lt;=n; ++i) if(b[i].y&gt;b[nn].y) b[++nn]=b[i]; reverse(b+1, b+nn+1); m=0; int j=1; for(int i=1; i&lt;=mm; ++i){ while(j&lt;=nn &amp;&amp; b[j].x&lt;a[i].x) ++j; if(j&lt;=nn &amp;&amp; b[j].y&gt;=a[i].y) a[++m]=a[i]; } if(m) solve(1, m, 1, nn); return printf(&quot;%lld&quot;, ans), 0;} E. Need for Speed题意有 $n$ 段行程，现在已知总用时和每段行程的距离 $d_i$ 和速度 $s_i$ 加上常数 $c$ 后的值。 实数，$n\\le 1000$。 做法二分即可。 代码123456789101112131415161718#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1005;const double eps = 1e-7;int n, t, mn, d[N], s[N];int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;t); mn=1000; for(int i=1; i&lt;=n; ++i) scanf(&quot;%d%d&quot;, d+i, s+i), mn=min(mn, s[i]); double l=eps-mn, r=2e6; while(r-l&gt;=eps){ double mid=(l+r)/2, ti=0; for(int i=1; i&lt;=n; ++i) ti+=d[i]/(s[i]+mid); if(ti&gt;t) l=mid; else r=mid; } return printf(&quot;%.7lf&quot;, l), 0;} F. Posterize题意有 $n$ 个数 $r_1,r_2,\\dotsc,r_n$，你需要选出 $k$ 个数 $v_1,v_2,\\dotsc,v_k$，最小化 $$\\sum_{i=1}^n \\min_{1\\le j\\le k} (r_i-v_j)^2$$ 输出最小值。 $0\\le r_i&lt;256$。 数可能很多，按照值和个数给出。 做法dp 即可，两侧的点特判，复杂度 $O(n^3)$。 代码1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 256;int n, k, a[N];ll ans, g[N][N], f[N][N];int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(int i=1, x; i&lt;=n; ++i) scanf(&quot;%d&quot;, &amp;x), scanf(&quot;%d&quot;, a+x); for(int i=0; i&lt;N; ++i) for(int j=i+1; j&lt;N; ++j) for(int t=i+1; t&lt;j; ++t) g[i][j]+=(ll)a[t]*min(t-i, j-t)*min(t-i, j-t); memset(f, 0x3f, sizeof f), ans=1e18; for(int i=0; i&lt;N; ++i){ f[i][1]=0; for(int j=0; j&lt;i; ++j) f[i][1]+=(ll)a[j]*(i-j)*(i-j); for(int j=2; j&lt;=k; ++j) for(int t=0; t&lt;i; ++t) f[i][j]=min(f[i][j], f[t][j-1]+g[t][i]); ll s=f[i][k]; for(int j=i+1; j&lt;N; ++j) s+=(ll)a[j]*(j-i)*(j-i); ans=min(ans, s); } return printf(&quot;%lld&quot;, ans), 0;} G. Replicate Replicate Rfplicbte题意初始有一个无穷大的网格，每个格子是 $0$ 或 $1$，每步每个格子会变成上一步周围 $9$ 个格子的异或和，并且有至多一个格子出现变异，即与上述变化相反。 现在给你大小为 $w\\times h$ 的结束状态，问初始的状态最小是多少，最小即最左和最右的 $1$ 相距最近，上下同理。 $w,h\\le 300$。 做法如果没有变异，每个状态有唯一前驱，每次把最左上的 $1$ 消去即可 $O(w \\times h)$ 找到前驱 可以发现前驱在四个方向上至少都缩小一格。 考虑有变异的情况，上述消元过程会消出初始边界外，如果先枚举行，那么第一次消出问题的行即变异点所在行，同理我们可以求出所在列。 找出变异点后去掉再消一次，如果仍然出现问题则说明没有前驱。 复杂度 $O(w \\times h \\times \\min{w,h} )$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;#define ll long longconst int N = 305;int n, m;char s[N];bool a[N][N], b[N][N], c[N][N];inline bool undo(){ memcpy(b, a, sizeof a), memset(c, 0, sizeof c); int x=0, y=0; for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=m; ++j) if(b[i][j]){ if(i&gt;=n-1 || j&gt;=m-1){ x=i; goto f1;} else for(int I=i; I&lt;i+3; ++I) for(int J=j; J&lt;j+3; ++J) b[I][J]^=1; } f1:; if(x){ memcpy(b, a, sizeof a); for(int j=1; j&lt;=m; ++j) for(int i=1; i&lt;=n; ++i) if(b[i][j]){ if(i&gt;=n-1 || j&gt;=m-1){ y=j; goto f2;} else for(int I=i; I&lt;i+3; ++I) for(int J=j; J&lt;j+3; ++J) b[I][J]^=1; } f2:; a[x][y]^=1; } bool f=1; for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=m; ++j) f&amp;=!a[i][j]; if(f) puts(&quot;#&quot;), exit(0); memcpy(b, a, sizeof a); for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=m; ++j) if(b[i][j]){ if(i&gt;=n-1 || j&gt;=m-1) return a[x][y]^=1, 0; else{ c[i+1][j+1]=1; for(int I=i; I&lt;i+3; ++I) for(int J=j; J&lt;j+3; ++J) b[I][J]^=1; } } return memcpy(a, c, sizeof a), 1;}int main() { scanf(&quot;%d%d&quot;, &amp;m, &amp;n); for(int i=1; i&lt;=n; ++i){ scanf(&quot;%s&quot;, s+1); for(int j=1; j&lt;=m; ++j) a[i][j]=s[j]=='#'; } while(undo()); int xl=n, xr=1, yl=n, yr=1; for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=m; ++j) if(a[i][j]) xl=min(xl, i), xr=max(xr, i), yl=min(yl, j), yr=max(yr, j); for(int i=xl; i&lt;=xr; ++i, puts(&quot;&quot;)) for(int j=yl; j&lt;=yr; ++j) putchar(a[i][j]?'#':'.'); return 0;} H. SceneryTarjan 有论文可以做到 $O(n\\log n)$。 题意有 $n$ 个区间，问是否能选出每个区间的一个长度为 $t$ 的子区间，并且这 $n$ 个子区间不相交（不含端点）。 $n\\le 10000$。 做法考虑一种错误的贪心，从小到大枚举下一次要放的区间的左端点，如果可以放就放，并且让它属于所有未被选择过的区间中，右端点最小的一个。 如图的情况，忽略红色，黄色部分即为正确的方案，但是上述贪心会在第二个区间的开头选择一个子区间，导致第一个区间无法满足。 一般化地，一个区间的集合 $S$，存在一些位置，如果之前选择了其中的某个位置作为一个子区间的左端点，那么 $S$ 就无法被满足。 如果我们可以处理出对于每个集合 $S$ 禁止的位置，不选择其中的位置作为左端点，再进行上述贪心就是正确的，如上图中红色部分即禁止的位置（的一部分）。 设集合 $S$ 中最小的左端点为 $s$，最大的右端点为 $e$，那么把 $[s,e]$ 包含的所有区间都放到 $S$ 中考虑，禁止的限制会严格变强，所以集合 $S$ 只要考虑 $O(n^2)$ 种，即某个区间 $[s,e]$ 包含的区间构成的集合。 考虑按照左端点从大到小枚举这个区间，记为 $[s,e]$。 由于所有 $&gt;s$ 的位置是否有限制与以 $s$ 为左端点的区间无关，我们现在已经得到了所有 $&gt;s$ 的位置的限制。 只考虑这些限制，忽略 $[s,e]$ 包含的区间各自的特征，只关心其数量，我们要在 $[s,e]$ 中放入数量等同于其包含区间数量的长度为 $t$ 的小区间，并且使这些区间尽可能地靠后。 设这些小区间最小的左端点为 $C$， 如果 $C&lt;s$，那么不存在方案 如果 $C&lt;s+t$，那么把 $(C-t, s)$ 这个区间标记为 forbidden，即不能被选择，否则 $[s,e]$ 包含的所有区间必然无法同时被满足 如果 $C\\ge s+t$，那么不会对 $s$ 及更小的位置造成影响 如果做完了仍未出现不合法的情况（上面的 1.），那么存在方案。 考虑证明： 我们可以在限制下跑最初的贪心，必然可以得到一组解。 假设贪心选择的某个子区间超出了原区间的右端点，设这个子区间是从左到右第 $i$ 个，该原区间右端点为 $e$， 若不存在一个更早选择的子区间，对应的原区间的右端点更大，那么 $[-\\infty,e]$ 的区间会在上述的过程中判为不合法 若存在，找出一个最靠后的区间，设是第 $j$ 个，那么找出第 $j$ 个到第 $i-1$ 个子区间对应的原区间的左端点的最小值 $s$，$[s,e]$ 会在上述过程中被判为不合法。 因此算法正确性得证。 forbidden 区间的右端点都是一个原区间的左端点，根据这个可以简单地 $O(n^2)$ 实现。 代码123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 10005;int n, t, b[N], f[N], ban[N], now[N];pair&lt;int,int&gt; a[N];int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;t); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d%d&quot;, &amp;a[i].first, &amp;a[i].second), b[i]=a[i].second; sort(a+1, a+n+1), sort(b+1, b+n+1); for(int i=1; i&lt;=n; ++i) f[i]=b[i], now[i]=n, ban[i]=a[i].first; for(int i=n; i; --i) for(int j=n; b[j]&gt;=a[i].second; --j){ f[j]-=t; while(now[j]&gt;i &amp;&amp; f[j]&lt;a[now[j]].first) f[j]=min(f[j], ban[now[j]--]); if(f[j]&lt;a[i].first) return puts(&quot;no&quot;), 0; ban[i]=min(ban[i], f[j]-t); } return puts(&quot;yes&quot;), 0;} I. Secret Chamber at Mount Rushmore题意有 $m$ 种小写字母间的转化规则，$n$ 次询问两个单词是否可以转化，长度不超过 $50$。 $m\\le 500,n\\le 50$。 做法跑 Floyd。 代码12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 30, M = 52;int n, m;bool a[N][N];char s[M], t[M];int main() { scanf(&quot;%d%d&quot;, &amp;m, &amp;n); for(int i=1; i&lt;=m; ++i){ char x, y; cin&gt;&gt;x&gt;&gt;y, a[x-'a'][y-'a']=1; } for(int k=0; k&lt;26; ++k) for(int i=0; i&lt;26; ++i) for(int j=0; j&lt;26; ++j) a[i][j]|=a[i][k] &amp;&amp; a[k][j]; while(n--){ scanf(&quot;%s%s&quot;, s, t); if(strlen(s)!=strlen(t)){ puts(&quot;no&quot;); goto nxt; } for(int i=0; s[i]; ++i) if(s[i]!=t[i] &amp;&amp; !a[s[i]-'a'][t[i]-'a']){ puts(&quot;no&quot;); goto nxt; } puts(&quot;yes&quot;); nxt:; } return 0;} J. Son of Pipe Stream题意给定一个 $n$ 个点的无向管道网络，每条边有一个容量 $c_i$。 一种液体 Flubber 从 $1$ 号点流向 $3$ 号点，水从 $2$ 号点流向 $3$ 号点。 一条管道 $i$ 中 Flubber 和水要保证同向，设其流量分别为 $f$ 和 $w$，需要满足 $v\\cdot f+w\\le c_i$，其中 $v$ 是一个给定的实数。 点要保持 Flubber 和水的流量守恒。 设 $3$ 号点 Flubber 和水的总流量为 $F$ 和 $W$，最大化 $F^a W^{1-a}$，其中 $a$ 是一个给定的实数，要求输出每条边的方向及 Flubber 和水的流量。 $n\\le 200, c_i\\le 10, 1\\le v\\le 10,0.01\\le a\\le 0.99$ 做法首先 $v$ 是没有用的，在最后除以 $v^a$ 即可。 记 $1$ 到 $3$ 的最大流为 $F_{\\max}$，$2$ 到 $3$ 的最大流为 $W_{\\max}$。 建超级源向 $1,2$ 连无穷边，最大流为 $Z$。 则 Flubber 流量 $F$ 的范围在 $[Z-W_{\\max},F_{\\max}]$ 中，简单求导可以知道取 $a\\cdot Z$ 为最优，令 $F^*$ 表示范围内最接近 $a\\cdot F$ 的值，水的流量 $W^*=Z-F^*$。 题解说事实上这里必然能取到这两个值，考虑构造一组解。 用超级源限制 Flubber 和水的流量恰好分别为 $F^*$ 和 $W^*$，跑一遍最大流，题解说事实上存在解，可以考虑两种极端情况。 用这组解给每条边定向并定容。 从 $1$ 开始限制最大流量为 $F^*$ 在新图上跑最大流，可以得到 Flubber 每条边的流量，剩余部分即为水的流量。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 205, M = 20005, inf = 1e9;const double eps = 1e-9;double V, A;int n, m, cur[N], d[N], cnt[N], id1[M], id2[M], a[M], b[M], c[M];bool rev[M];struct edge{ int v, id; double f;};vector&lt;edge&gt; e[N];inline void add(int x, int y, double z, bool t=0){ e[x].push_back((edge){y, (int)e[y].size(), z}); e[y].push_back((edge){x, (int)e[x].size()-1, t*z});}double sap(int u, double flow){ if(flow&lt;eps || u==3) return flow; double now=0; for(unsigned i=cur[u]; i&lt;e[u].size(); ++i){ edge &amp;p=e[u][i]; if(d[p.v]+1==d[u]){ double tmp=sap(p.v, min(flow-now, p.f)); p.f-=tmp, now+=tmp, e[p.v][p.id].f+=tmp; if(flow-now&lt;eps) return flow; } cur[u]=i; } cur[u]=0; if(!--cnt[d[u]]) d[3]=n+1; ++cnt[++d[u]]; return now;}inline void clear(){ memset(cur, 0, sizeof cur), memset(d, 0, sizeof d), memset(cnt, 0, sizeof cnt), cnt[0]=n+1; for(auto i:e[0]) i.f=inf, e[i.v][i.id].f=0; for(int i=1; i&lt;=m; ++i) e[a[i]][id1[i]].f=e[b[i]][id2[i]].f=c[i];}inline double SAP(int S, bool t=1){ if(t) clear(); double ans=0; while(d[3]!=n+1) ans+=sap(S, inf); return ans;}int main() { scanf(&quot;%d%d%lf%lf&quot;, &amp;n, &amp;m, &amp;V, &amp;A); for(int i=1; i&lt;=m; ++i){ scanf(&quot;%d%d%d&quot;, a+i, b+i, c+i); id1[i]=e[a[i]].size(), id2[i]=e[b[i]].size(), add(a[i], b[i], c[i], 1); } add(0, 1, inf), add(0, 2, inf); int f=SAP(1), w=SAP(2), s=SAP(0); double ff=max(min(A*s, (double)f), (double)s-w), ww=s-ff, ans=pow(ff/V, A)*pow(ww, 1-A); clear(), e[0][0].f=ff, e[0][1].f=ww, SAP(0, 0); for(int i=1; i&lt;=m; ++i){ if(e[a[i]][id1[i]].f&lt;c[i]) e[a[i]][id1[i]].f=c[i]-e[a[i]][id1[i]].f, e[b[i]][id2[i]].f=0; else e[a[i]][id1[i]].f=0, e[b[i]][id2[i]].f=c[i]-e[b[i]][id2[i]].f, rev[i]=1; } memset(cur, 0, sizeof cur), memset(d, 0, sizeof d), memset(cnt, 0, sizeof cnt), cnt[0]=n+1; e[0][0].f=ff, e[1][e[0][0].id].f=e[0][1].f=e[2][e[0][1].id].f=0, SAP(0, 0); for(int i=1; i&lt;=m; ++i){ if(rev[i]) printf(&quot;%.9lf %.9lf\\n&quot;, -e[a[i]][id1[i]].f/V, -e[b[i]][id2[i]].f); else printf(&quot;%.9lf %.9lf\\n&quot;, e[b[i]][id2[i]].f/V, e[a[i]][id1[i]].f); } printf(&quot;%.9lf&quot;, ans); return 0;} K. Tarot Sham Boast题意有 $s$ 个长度相同的字符集大小为 $3$ 的字符串，要求按照其在长度为 $n$ 的随机串中的出现概率排序，概率相同按照输入顺序输出。 $n\\le 10^6, s\\le 10$。 串长不超过 $10^5$。 做法计算概率可以容斥。 设串为 $X,|X|=l$，要计算 $X$ 的出现概率 $$\\sum_{I\\subseteq [n-l+1],I\\ne \\varnothing} (-1)^{|I|+1} P(\\text{$X$ 在 $I$ 中的每个位置都出现了})$$ 当 $|I|=1$ 时，概率为 $\\frac{n-l+1}{3^l}$，与 $X$ 无关 当 $|I|=2$ 且 $I$ 中的两个位置相距不小于 $l$，也与 $X$ 无关 当 $|I|=2$ 且两个串有交，概率为若干形如 $-3^k$ 的数的和，且 $k$ 两两不同 当 $|I|&gt;2$，根据题解，可以不考虑 证明在 这里 考虑相距为 $t(t&lt;l)$ 的两个位置可以同时出现，当且仅当 $X$ 有长度为 $l-t$ 的 border，也即有周期 $t$。 由于贡献为 $\\frac{n-l-t+1}{3^{l+t}}$，相差极大，可以直接用字典序来比较大小。 注意太大的 $t$ 使得 $l+t&gt;n$ 应该被忽略。 复杂度 $O(l\\cdot s\\log s)$。 代码1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1000005, M = 100005;int n, d, m, f[11], nxt[N], a[11][M];char *t, s[N], T[11][M];bool cmp(int x, int y){ for(int i=0; i&lt;m; ++i) if(a[x][i]!=a[y][i]) return a[x][i]&lt;a[y][i]; return 0;}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;d); for(int i=1; i&lt;=d; ++i){ scanf(&quot;%s&quot;, (t=T[i])+1), m=strlen(t+1), f[i]=i; for(int j=2, k=0; j&lt;=m; ++j){ while(k &amp;&amp; t[k+1]!=t[j]) k=nxt[k]; nxt[j]=k+=(t[k+1]==t[j]); } for(int j=m, cnt=0; j &amp;&amp; j&gt;=2*m-n; j=nxt[j]) a[i][cnt++]=j; } sort(f+1, f+d+1, cmp); for(int i=1; i&lt;=d; ++i) puts(T[f[i]]+1); return 0;} L. Visual Python++题意有一类点和二类点各 $n$ 个，问是否存在一种匹配方案，使得以对应的一类点为左上角，二类点为右下角，能构成矩形且矩形两两不交（包括顶点和边），如果有解需要输出方案。 $n\\le 10^5$。 做法枚举一维坐标，可行的匹配是至多只有一种的。 匹配完后离线扫描线判定即可。 复杂度 $O(n\\log n)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;set&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 200005;ll ans;int n, cnt, c[N], e[N], w[N&lt;&lt;1];pair&lt;int,int&gt; p[N&lt;&lt;1];vector&lt;int&gt; d[N&lt;&lt;1];vector&lt;pair&lt;int,int&gt;&gt; q[N&lt;&lt;1];struct point{ int x, y, id; inline bool operator &lt;(const point &amp;rhs)const{ return x&lt;rhs.x;}} a[N], b[N];set&lt;pair&lt;int,int&gt;&gt; s;inline void modify(int x, int y){ while(x&lt;=n&lt;&lt;1) w[x]+=y, x+=x&amp;-x;}inline int query(int x){ int ans=0; while(x) ans+=w[x], x^=x&amp;-x; return ans;}int main() { read(n); for(int i=1; i&lt;=n; ++i) read(a[i].x), read(a[i].y), a[i].id=i; for(int i=1; i&lt;=n; ++i) read(b[i].x), read(b[i].y), b[i].id=i; for(int i=1; i&lt;=n; ++i) p[++cnt]=make_pair(a[i].x, i), p[++cnt]=make_pair(b[i].x, i+n); sort(p+1, p+cnt+1); for(int i=1, now=0; i&lt;=cnt; ++i) (p[i].second&lt;=n?a[p[i].second].x:b[p[i].second-n].x)=(p[i].first==p[i-1].first?now:++now); cnt=0; for(int i=1; i&lt;=n; ++i) p[++cnt]=make_pair(a[i].y, i), p[++cnt]=make_pair(b[i].y, i+n); sort(p+1, p+cnt+1); for(int i=1, now=0; i&lt;=cnt; ++i) (p[i].second&lt;=n?a[p[i].second].y:b[p[i].second-n].y)=(p[i].first==p[i-1].first?now:++now); sort(a+1, a+n+1), sort(b+1, b+n+1); int j=1; for(int i=1; i&lt;=n; ++i){ while(j&lt;=n &amp;&amp; a[j].x&lt;=b[i].x) s.insert(make_pair(a[j].y, j)), ++j; auto it=s.upper_bound(make_pair(b[i].y, n)); if(it==s.begin()) return puts(&quot;syntax error&quot;), 0; c[i]=(--it)-&gt;second; s.erase(it); } for(int i=1; i&lt;=n; ++i) d[a[c[i]].x].push_back(b[i].y), d[b[i].x+1].push_back(-b[i].y), d[a[c[i]].x].push_back(a[c[i]].y), d[b[i].x+1].push_back(-a[c[i]].y), q[a[c[i]].x].push_back(make_pair(a[c[i]].y, b[i].y)), q[b[i].x].push_back(make_pair(a[c[i]].y, b[i].y)); for(int i=1; i&lt;=n&lt;&lt;1; ++i){ for(int j:d[i]) if(j&lt;0) modify(-j, -1); else modify(j, 1); for(auto j:q[i]) ans+=query(j.second)-query(j.first-1); } if(ans==n&lt;&lt;2){ for(int i=1; i&lt;=n; ++i) e[a[c[i]].id]=b[i].id; for(int i=1; i&lt;=n; ++i) print(e[i]), print('\\n'); } else puts(&quot;syntax error&quot;); return flush(), 0;}","link":"/icpc-world-finals-2017/"},{"title":"「LOJ 2014」「SCOI2016」萌萌哒","text":"LOJ #2014. 「SCOI2016」萌萌哒 题意有一个没有前导零的 $n$ 位十进制数 $S_1 S_2\\dotsc S_n$，$m$ 条限制，一条限制形如 $S_{l_1}S_{l_1+1}\\dotsc S_{r_2}$ 与 $S_{l_2}S_{l_2+1}\\dotsc S_{r_2}$ 这两个子串需要完全相同 问有多少种合法的方案 模 $10^9+7$ 做法考虑对应位连边，假设最后有 $k$ 个联通块，方案数就是 $9\\times 10^{k-1}$ 连边数量是 $\\mathcal O(n^2)$ 的，考虑使用倍增优化连边 点 $p_{i,j}$ 代表了以 $j$ 为左端点，长度为 $2^i$ 的区间，$p_{i,j}$ 和 $p_{i,k}$ 之间有边相当于对应的每个点之间有边 这样每个限制连边的数量是 $\\mathcal O(\\log n)$ 的 然后从大到小枚举 $i$，同一层的边可以用并查集去重，保留有效的至多 $n-1$ 条边 一条 $p_{i,j}\\leftrightarrow p_{i,k}$ 的边下传到第 $i-1$ 层变成 $p_{i-1,j}\\leftrightarrow p_{i-1,k}$ 和 $p_{i-1,j+2^{i-1}}\\leftrightarrow p_{i-1,k+2^{i-1}}$ 的边 因此这种实现的总复杂度是 $\\mathcal O(n\\log^2 n)$ 的 可以轻易做到 $\\mathcal O(n\\log n)$ 吧 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int N = 100005, P = 1000000007;int n, m, f[N];vector&lt;pair&lt;int,int&gt;&gt; ans, a[N];int find(int x){ return f[x]==x?x:f[x]=find(f[x]);}int main() { read(n), read(m); while(m--){ static int l1, r1, l2, r2, len; read(l1), read(r1), read(l2), read(r2), len=r1-l1+1; for(int i=16; ~i; --i) if(len&gt;&gt;i&amp;1) a[i].push_back(make_pair(l1, l2)), l1+=1&lt;&lt;i, l2+=1&lt;&lt;i; } for(int i=1; i&lt;=n; ++i) f[i]=i; for(int i=16; ~i; --i){ for(auto j:a[i]) if(find(j.first)!=find(j.second)) f[f[j.first]]=f[j.second], ans.push_back(j); if(i) for(auto j:ans) a[i-1].push_back(j), a[i-1].push_back(make_pair(j.first+(1&lt;&lt;i&gt;&gt;1), j.second+(1&lt;&lt;i&gt;&gt;1))); } int Ans=9; for(int i=1; i&lt;n-ans.size(); ++i) Ans=Ans*10ll%P; return printf(&quot;%d&quot;, Ans), 0;}","link":"/loj-2014/"},{"title":"「LOJ 2127」「HAOI2015」按位或","text":"LOJ #2127 题意你有一个数字 $0$，每秒你会以 $p_i$ 的概率选择 $i$，$i\\in[0,2^n-1]$，和自己的数进行按位或，问期望多少秒后数字变成 $2^n-1$ $n\\le20,\\sum p_i=1$ 分析参考2015候选队论文 吕凯风《集合幂级数的性质与应用及其快速算法》 把 $p$ 看成集合幂级数，用集合并卷积定义乘法。 设 $U={0,\\dotsc,n-1}$， 那么游戏在第 $k$ 秒结束的概率是 $p^k-p^{k-1}$ 的第 $U$ 项，答案等于 $$f=\\sum_{k=1}^\\infty k(p^k-p^{k-1})$$ 的第 $U$ 项 做莫比乌斯变换 $$\\begin{align}\\hat{f}S&amp;=\\sum{k=1}^\\infty k(\\hat{p}_S^k-\\hat{p}S^{k-1})\\&amp;=\\sum{k=0}^\\infty-\\hat{p}_S^k\\&amp;=\\begin{cases}-\\frac{1}{1-\\hat{p}_S}, &amp; \\hat{p}_S\\ne1\\0, &amp; \\hat{p}_S=1\\end{cases}\\end{align}$$ 再对 $\\hat{f}$ 做莫比乌斯反演得到 $f$ 注意特判无解 时间复杂度 $\\mathcal O(n\\times 2^n)$ 这里存在 $$\\sum_{i=0}^{2^n-1}f_i=0$$ 还没理解 update: $$\\because\\hat{p}U=\\sum{S\\subseteq U}p_S=1$$ $$\\therefore\\sum_{S\\subseteq U}f_S=\\hat{f}_U=0$$ 代码123456789101112#include&lt;cstdio&gt;#include&lt;math.h&gt;int n;double a[1&lt;&lt;20];int main() { scanf(&quot;%d&quot;, &amp;n); for(int i=0; i&lt;1&lt;&lt;n; ++i) scanf(&quot;%lf&quot;, a+i); for(int i=0; i&lt;n; ++i) for(int j=0; j&lt;1&lt;&lt;n; ++j) if(j&gt;&gt;i&amp;1) a[j]+=a[j^(1&lt;&lt;i)]; for(int i=0; i&lt;1&lt;&lt;n; ++i) a[i]=(fabs(a[i]-1)&lt;1e-10?0:-1/(1-a[i])); for(int i=0; i&lt;n; ++i) for(int j=0; j&lt;1&lt;&lt;n; ++j) if(j&gt;&gt;i&amp;1) a[j]-=a[j^(1&lt;&lt;i)]; return a[(1&lt;&lt;n)-1]?printf(&quot;%.9lf&quot;, a[(1&lt;&lt;n)-1]):puts(&quot;INF&quot;), 0;}","link":"/loj-2127/"},{"title":"「LOJ 2145」「SHOI2017」分手是祝愿","text":"LOJ #2145 Zeit und Raum trennen dich und mich. 时空将你我分开。 题意你有一排$n$个灯泡，有初始状态$0/1$，从$1$开始编号 一次操作可以选定一个整数$x\\in[1,n]$，把$x$的所有约数号（含$1$和$x$）灯泡状态取反。 你要把所有灯泡变成$0$，给出$0\\le k\\le n$ 若剩余最小操作次数$\\le k$，你会直接按照最小操作次数操作，并结束 否则每次你会在$[1,n]$中等概率地选择一个整数进行操作，直到满足1的条件 求期望操作次数乘$n!$对$100003$取模的结果 $1\\le n\\le 10^5$ 分析先考虑求出最小操作次数。 容易发现，如果相同操作最多执行1次，那么操作的集合是唯一的 我们可以在$\\mathcal O(n\\ ln\\ n)$的复杂度内处理出每个数的约数，从大到小枚举位置，若该位置需要复原，那么执行操作。 从这里也可以发现$2^n$个状态到$2^n$个操作集合是个双射 设求出的剩余操作次数为$x$，若$x\\le k$，输出$x*n!$。 事实上直接这么做可以获得$80$分的好成绩 考虑$x&gt;k$的情况 做法1令$f_i$表示剩余需要$i$次操作时，期望操作次数 可以发现 $$f_k=k\\tag{1}$$ $$f_n=f_{n-1}+1\\tag{2}$$ $\\forall k\\le i&lt;n,f_i=\\frac{i}{n}f_{i-1}+\\frac{n-i}{n}f_{i+1}+1\\tag{3}$ (3)只要考虑有$\\frac{i}{n}$的概率随机到需要被执行的操作上，$\\frac{n-i}{n}$的概率随机到不需要的操作上，并且消耗一步 $f_x*n!$就是答案 事实上可以解出来，保留变量$f_n$，由(3)得 $$f_i=\\frac{nf_{i+1}-(n-i-1)f_{i+2}-n}{i+1}\\tag{4}$$ 倒着可以推出$f_k$关于$f_n$的一次式，用(1)解出$f_n$，代入$f_x$即可 做法2对$f_i$差分，令$g_i=f_i-f_{i-1}$，表示从剩余$i$步到剩余$i-1$步期望的操作次数 由(3) $$\\begin{align}\\frac{i}{n}(f_i-f_{i-1})&amp;=\\frac{n-i}{n}(f_{i+1}-f_i)+1\\\\therefore\\frac{i}{n}g_i&amp;=\\frac{n-i}{n}g_{i+1}+1\\\\therefore g_i&amp;=\\frac{(n-i)g_{i+1}+n}{i}\\tag{5}\\end{align}$$ 且$g_n=1\\tag{6}$ 这样可以倒着推出$g_i$，最后$$ans=n!* \\sum_{i=k+1}^xg_i$$ 总复杂度都是$\\mathcal O(n\\ ln\\ n)$ 代码112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;vector&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) { if (c == '-') iosig = true; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x + (x &lt;&lt; 2)) &lt;&lt; 1) + (c ^ '0'); if (iosig) x = -x;}const int N = 100005, P = 100003;int n, k, x, inv[N];bool a[N];vector&lt;int&gt; s[N];struct num{ int x, y; inline num(){} inline num(int a, int b){ x=a, y=b;} inline num operator +(const num &amp;rhs)const{ return num((x+rhs.x)%P, (y+rhs.y)%P);} inline num operator -(const num &amp;rhs)const{ return num((x-rhs.x)%P, (y-rhs.y)%P);} // inline num operator +(int rhs)const{ return num(x, (y+rhs)%P);} inline num operator -(int rhs)const{ return num(x, (y-rhs)%P);} inline num operator *(int rhs)const{ return num((ll)x*rhs%P, (ll)y*rhs%P);}}f[N];inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}int main() { int nfac=1; read(n), read(k); for(int i=1; i&lt;=n; ++i) read(a[i]), nfac=(ll)nfac*i%P; for(int i=1; i&lt;=n; ++i) for(int j=i; j&lt;=n; j+=i) s[j].push_back(i); for(int i=n; i; --i) if(a[i]){ ++x; for(int j:s[i]) a[j]^=1; } if(x&lt;=k) return printf(&quot;%lld&quot;, (ll)x*nfac%P), 0; inv[1]=1; for(int i=2; i&lt;=n; ++i) inv[i]=(ll)(P-P/i)*inv[P%i]%P; f[n]=num(1, 0); f[n-1]=f[n]-1; for(int i=n-2; i&gt;=k; --i) f[i]=(f[i+1]*n-f[i+2]*(n-i-1)-n)*inv[i+1]; int x0=(ll)(k-f[k].y)*Pow(f[k].x)%P; return printf(&quot;%lld&quot;, (((ll)f[x].x*x0+f[x].y)%P+P)%P*nfac%P), 0;} 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;vector&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) { if (c == '-') iosig = true; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x + (x &lt;&lt; 2)) &lt;&lt; 1) + (c ^ '0'); if (iosig) x = -x;}const int N = 100005, P = 100003;int n, k, x, ans, inv[N], f[N];bool a[N];vector&lt;int&gt; s[N];int main() { int nfac=1; read(n), read(k); for(int i=1; i&lt;=n; ++i) read(a[i]), nfac=(ll)nfac*i%P; for(int i=1; i&lt;=n; ++i) for(int j=i; j&lt;=n; j+=i) s[j].push_back(i); for(int i=n; i; --i) if(a[i]){ ++x; for(int j:s[i]) a[j]^=1; } if(x&lt;=k) return printf(&quot;%lld&quot;, (ll)x*nfac%P), 0; inv[1]=1; for(int i=2; i&lt;=n; ++i) inv[i]=(ll)(P-P/i)*inv[P%i]%P; f[n]=1; for(int i=n-1; i&gt;k; --i) f[i]=((ll)f[i+1]*(n-i)+n)%P*inv[i]%P; for(int i=x; i&gt;k; --i) (ans+=f[i])%=P; return printf(&quot;%lld&quot;, (ll)nfac*(ans+P+k)%P), 0;}","link":"/loj-2145/"},{"title":"「LOJ 2269」「SDOI2017」切树游戏","text":"LOJ #2269 题意你有一棵$n$个点的树，点$y$有一个$[0,m)$内的整数权值$a_u$ 定义一棵树的权值是点权的异或和 有$q$次操作 Change x y，表示把第$x$个点的权值改成$y$ Query x，表示询问有多少个非空的联通子树的权值是$x$，模$10007$ $n,q\\le30000,m\\le128$ 分析一种做法好像用全局平衡二叉树并不是很快 参考基于变换合并的树上动态DP的链分治算法&amp;SDOI2017 切树游戏（cut）解题报告 没有修改的情况定义一个联通子树的根是唯一的深度最小的点 令$f_{u,x}$表示以$u$为根权值为$x$的联通子树个数 合并的时候大致是异或卷积 令$F_u(x)$表示$f_{u,* }$的生成函数，定义卷积为异或卷积，有 $$F_u(x)=x^{a_u}\\prod_{u\\to v}(F_v(x)+x^0)$$ 只需要在一开始FWT，过程中的乘法和加法都可以直接做 把每个点的$F$加起来，最后FWT回来得到答案 修改这里不维护全局的答案 令$g_{u,x}$表示$u$的子树中所有点$v$的$f_{v,x}$之和，$G_u(x)$表示$g_{u,* }$的生成函数，有 $$G_u(x)=F_u(x)+\\sum_{u\\to v}G_v(x)$$ 答案可以从$G_1(x)$中得到 树链剖分后，记$son_u$表示$u$的重儿子 令 $$LF_u(x)=\\prod_{u\\to v,v\\ne son_u}(F_v(x)+x^0)$$ 即轻儿子的合并 同理 $$LG_u(x)=\\sum_{u\\to v,v\\ne son_u}G_v(x)$$ 我们用线段树维护$F$和$G$，转移为 $$\\begin{align}F_u(x)&amp;=x^{a_u}* (F_{son_u}(x)+x^0)* LF_u(x) \\&amp;=x^{a_u}* F_{son_u}(x)* LF_u(x)+x^{a_u}* LF_u(x) \\G_u(x)&amp;=LG_u(x)+G_{son_u}(x)+F_u(x)\\end{align}$$ 就不展开了 把转移看做线性变换 $$\\begin{bmatrix}LF_u(x)* x^{a_u} &amp; 0 &amp; LF_u(x)* x^{a_u} \\LF_u(x)* x^{a_u} &amp; 1 &amp; LF_u(x)* x^{a_u}+LG_u(x) \\0 &amp; 0 &amp; 1\\end{bmatrix}\\begin{pmatrix}F_{son_u} \\G_{son_u} \\x^0\\end{pmatrix}\\begin{pmatrix}F_u \\G_u \\x^0\\end{pmatrix}$$ 这样就可以在重链上用线段树维护，轻边上暴力修改 这里维护$LF$的时候需要除法，但是由于取模，不好操作，可以对每个点开一棵线段树维护轻儿子的积 单次修改复杂度$\\mathcal O(128\\log^2n)$，查询$\\mathcal O(128(\\log n+\\log 128))$ 优化上面转移矩阵的乘法对这种形式封闭 $$\\begin{bmatrix}a_1 &amp; 0 &amp; b_1 \\c_1 &amp; 1 &amp; d_1 \\0 &amp; 0 &amp; 1 \\\\end{bmatrix}*\\begin{bmatrix}a_2 &amp; 0 &amp; b_2 \\c_2 &amp; 1 &amp; d_2 \\0 &amp; 0 &amp; 1 \\\\end{bmatrix}\\begin{bmatrix}a_1 a_2 &amp; 0 &amp; b_1+a_1 b_2 \\a_2 c_1+c_2 &amp; 1 &amp; b_2 c_1+d_1+d_2 \\0 &amp; 0 &amp; 1 \\\\end{bmatrix}$$ 只需要记四个位置就好了 另一种做法具体的我不会 维护一个全局的答案，每条重链用线段树xjb维护一下，修改的时候暴力增减 好像是不用矩阵的 复杂度一样 代码不知道为什么常数这么大.. 后天就联赛了，还是不卡了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 1000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 30005, M = 1&lt;&lt;7, P = 10007;int num, n, m, invm, id, q, p[N], idfn[N], dfn[N], last[N], a[N], b[N];int siz[N], top[N], fa[N], h[N], pre[N&lt;&lt;1], e[N&lt;&lt;1];inline void add(int x, int y){ e[++num]=y, pre[num]=h[x], h[x]=num;}inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}struct ps{ int f[M]; inline void FWT(int *f, int g){ for(int i=1; i&lt;m; i&lt;&lt;=1) for(int j=0; j&lt;m; j+=i&lt;&lt;1) for(int k=j; k&lt;j+i; ++k){ int l=f[k], r=f[k+i]; f[k]=l+r, f[k+i]=l-r; } for(int i=0; i&lt;m; ++i) f[i]%=P; if(g==-1) for(int i=0; i&lt;m; ++i) f[i]=f[i]*invm%P; } inline void tr(){ FWT(f, 1);} inline void itr(){ FWT(f, -1);} inline ps operator +(const ps &amp;rhs)const{ static ps ans; for(int i=0; i&lt;m; ++i) ans.f[i]=(f[i]+rhs.f[i]); return ans; } inline ps operator -(const ps &amp;rhs)const{ static ps ans; for(int i=0; i&lt;m; ++i) ans.f[i]=(f[i]-rhs.f[i]); return ans; } inline ps operator *(const ps &amp;rhs)const{ static ps ans; for(int i=0; i&lt;m; ++i) ans.f[i]=(ll)f[i]*rhs.f[i]%P; return ans; }}st[M], f[N], g[N], lg[N];struct matrix{ ps a, b, c, d; inline matrix(){} inline matrix(const ps &amp;x, const ps &amp;y){ a=b=c=x, d=x+y;} inline matrix(const ps &amp;A, const ps &amp;B, const ps &amp;C, const ps &amp;D){ a=A, b=B, c=C, d=D; } inline matrix operator *(const matrix &amp;rhs)const{ return (matrix){ a*rhs.a, b+a*rhs.b, rhs.a*c+rhs.c, rhs.b*c+d+rhs.d}; }}s[N&lt;&lt;2];struct LF{ int n; ps *s; void build(int l, int r, int t){ if(l==r) return (void)(s[t]=f[b[l]]+st[0]); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; build(l, mid, k), build(mid+1, r, k|1); s[t]=s[k]*s[k|1]; } inline void init(int cnt){ s=new ps[(cnt+1)&lt;&lt;2]; if(!cnt) s[1]=st[0]; else build(1, n=cnt, 1); } void modify(int l, int r, int t, int x, const ps &amp;y){ if(l==r) return (void)(s[t]=y); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; if(x&lt;=mid) modify(l, mid, k, x, y); else modify(mid+1, r, k|1, x, y); s[t]=s[k]*s[k|1]; } inline void modify(int x, const ps &amp;y){ modify(1, n, 1, x, y);}}lf[N];void dfs1(int u){ siz[u]=1; f[u]=st[a[u]]; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa[u]){ fa[e[i]]=u, dfs1(e[i]), siz[u]+=siz[e[i]], f[u]=f[u]*(f[e[i]]+st[0]); g[u]=g[u]+g[e[i]]; } g[u]=g[u]+f[u];}void dfs2(int u){ idfn[dfn[u]=++id]=u; int son=0; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa[u] &amp;&amp; siz[e[i]]&gt;siz[son]) son=e[i]; if(son) top[son]=top[u], dfs2(son), last[u]=last[son]; else last[u]=id; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa[u] &amp;&amp; e[i]!=son) top[e[i]]=e[i], dfs2(e[i]), lg[u]=lg[u]+g[e[i]]; int cnt=0; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa[u] &amp;&amp; e[i]!=son) b[++cnt]=e[i], p[e[i]]=cnt; lf[u].init(cnt);}void build(int l, int r, int t){ if(l==r){ int u=idfn[l]; s[t]=matrix(lf[u].s[1]*st[a[u]], lg[u]); return; } int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; build(l, mid, k), build(mid+1, r, k|1); s[t]=s[k]*s[k|1];}void modify(int l, int r, int t, int x, const matrix &amp;y){ if(l==r) return (void)(s[t]=y); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; if(x&lt;=mid) modify(l, mid, k, x, y); else modify(mid+1, r, k|1, x, y); s[t]=s[k]*s[k|1];}matrix query(int l, int r, int t, int L, int R){ if(L&lt;=l &amp;&amp; r&lt;=R) return s[t]; int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; if(R&lt;=mid) return query(l, mid, k, L, R); if(L&gt;mid) return query(mid+1, r, k|1, L, R); return query(l, mid, k, L, R)*query(mid+1, r, k|1, L, R);}int main() { read(n), read(m); invm=Pow(m); for(int i=1; i&lt;=n; ++i) read(a[i]); for(int i=1; i&lt;n; ++i){ static int x, y; read(x), read(y), add(x, y), add(y, x); } for(int i=0; i&lt;m; ++i) st[i].f[i]=1, st[i].tr(); dfs1(1), top[1]=1, dfs2(1); build(1, n, 1); read(q); while(q--){ static char opt; static int x; while(isspace(opt=read())); read(x); if(opt=='Q'){ ps ans=query(1, n, 1, dfn[1], last[1]).d; ans.itr(); print((ans.f[x]+P)%P), print('\\n'); } else{ read(a[x]); while(x){ modify(1, n, 1, dfn[x], matrix(lf[x].s[1]*st[a[x]], lg[x])); x=top[x]; if(fa[x]){ static matrix tmp; tmp=query(1, n, 1, dfn[x], last[x]); lf[fa[x]].modify(p[x], tmp.b+st[0]); lg[fa[x]]=lg[fa[x]]-g[x]; lg[fa[x]]=lg[fa[x]]+(g[x]=tmp.d); } x=fa[x]; } } } return flush(), 0;}","link":"/loj-2269/"},{"title":"「LOJ 2340」「WC2018」州区划分","text":"LOJ #2340 题意有 $n$ 座城市，第 $i$ 座城市的人口是 $w_i$，有一些无向边。 现在城市被划分为了若干个州，每个州至少包含一个城市，每个城市恰好在一个州内。 设 $V_i$ 是第 $i$ 个州的城市集合。 定义一条道路是一个州的内部道路，当且仅当这条道路的两个端点城市都在这个州内。如果一个州内部存在一条起点终点相同，不经过任何不属于这个州的城市，且经过这个州的所有内部道路都恰好一次并且经过这个州的所有城市至少一次的路径（路径长度可以为 $0$），则称这个州是不合法的。 定义第 $i$ 个州的满意度为：第 $i$ 个州的人口在前 $i$ 个州的人口中所占比例的 $p$ 次幂，即： $$\\left(\\frac{\\sum_{x\\in V_i}w_x}{\\sum_{j=1}^i\\sum_{x\\in V_j}w_x}\\right)^p$$ 定义一个划分的满意度为所有州的满意度的乘积。 求所有合法的划分方案的满意度之和。 答案对 $998244353$ 取模。 $n\\le 21,0\\le p\\le 2$ 时限 $10s$ 做法首先可以 $\\mathcal O(2^nn^2)$ 地处理出一个州是否合法 考虑 $dp$，令 $f_S$ 表示集合 $S$ 的所有合法划分的满意度之和，$sum_S$ 表示集合 $S$ 中所有城市的人口之和。 若一个州合法，令$g_S=sum_S$，否则 $g_S=0$ 显然有 $$f_S=\\sum_{T\\subseteq S,T\\ne\\varnothing}f_{S\\backslash T}\\left(\\frac{g_T}{sum_S}\\right)^p$$ 直接枚举是 $\\mathcal O(3^n)$ 的，可以获得 $50$ 分的好成绩 现场没看懂题意，要是写出来就卡线Au了 转换成 $$f_S*sum_S^p=\\sum_{T\\subseteq S,T\\ne\\varnothing}f_{S\\backslash T}*g_T^p$$ 这个东西很像子集卷积 考虑增加一维集合大小，$f’{i,S}=[|S|=i]f_S$，$g’{i,S}$同理 $dp$ 的时候第一维是从小转移到大的，于是对每一个 $g’_j$ 和当前的 $f’_i$ 做FWT，暴力枚举一个 $j$，用 $g’_j$ 和 $f’i$ 去更新 $f’{i+j}$ 注意这里都用FWT之后的数组运算，但是除了 $f’_{|S|,S}$ 都是不合法的信息，需要IFWT回来后清除，再FWT回去 复杂度 $\\mathcal O(2^nn^2)$ 所以这里 $p$ 放那么小没什么用 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longconst int N = 23, M = 220, S = 1&lt;&lt;21, P = 998244353;int n, m, num, p, w[N], fa[N], d[N], h[N], pre[M], e[M], s[S], cnt[S], W[N][S], f[N][S];inline void add(int x, int y){ e[++num]=y, pre[num]=h[x], h[x]=num;}inline int find(int x){ return fa[x]==x?x:fa[x]=find(fa[x]);}inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}inline bool check(int x){ for(int i=0; i&lt;n; ++i) fa[i]=i, d[i]=0; for(int i=0; i&lt;n; ++i) if(x&gt;&gt;i&amp;1) for(int j=h[i]; j; j=pre[j]) if(x&gt;&gt;e[j]&amp;1) fa[find(i)]=find(e[j]), ++d[i], ++d[e[j]]; int cnt=0; for(int i=0; i&lt;n; ++i) if(x&gt;&gt;i&amp;1){ cnt+=find(i)==i; if(d[i]&amp;1) return 0; } if(cnt&gt;1) return 0; return 1;}inline void FWT(int *f, int g){ for(int i=1; i&lt;1&lt;&lt;n; i&lt;&lt;=1) for(int j=0; j&lt;1&lt;&lt;n; j+=i&lt;&lt;1) for(int k=j; k&lt;j+i; ++k){ int x=f[k], y=f[k+i]; f[k]=(x+y)%P, f[k+i]=(x-y+P)%P; } if(g==-1) for(int i=0, I=Pow(1&lt;&lt;n); i&lt;1&lt;&lt;n; ++i) f[i]=(ll)f[i]*I%P;}int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;p); for(int i=0, x, y; i&lt;m; ++i) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), add(x-1, y-1); for(int i=0; i&lt;n; ++i) scanf(&quot;%d&quot;, w+i); for(int i=1; i&lt;1&lt;&lt;n; ++i){ cnt[i]=cnt[i^(i&amp;-i)]+1; for(int j=0; j&lt;n; ++j) if(i&gt;&gt;j&amp;1) s[i]+=w[j]; if(p==0) s[i]=1; if(p==2) s[i]=s[i]*s[i]; } s[0]=1; for(int i=1; i&lt;1&lt;&lt;n; ++i) W[cnt[i]][i]=s[i]*!check(i), s[i]=Pow(s[i]); for(int i=1; i&lt;=n; ++i) FWT(W[i], 1); f[0][0]=1; for(int i=0; i&lt;=n; ++i){ if(i) FWT(f[i], -1); for(int j=0; j&lt;1&lt;&lt;n; ++j) if(cnt[j]==i) f[i][j]=(ll)f[i][j]*s[j]%P; else f[i][j]=0; if(i!=n) FWT(f[i], 1); for(int j=1; i+j&lt;=n; ++j) for(int k=0; k&lt;1&lt;&lt;n; ++k) f[i+j][k]=(f[i+j][k]+(ll)f[i][k]*W[j][k])%P; } return printf(&quot;%d&quot;, f[n][(1&lt;&lt;n)-1]), 0;}","link":"/loj-2340/"},{"title":"「LOJ 2585」「APIO2018」新家","text":"LOJ #2585 题意在数轴上有$n$家商店，第$i$个商店有坐标$x_i$，种类$t_i\\in[1..k]$，出现时间$[a_i,b_i]$ 有$q$组询问$l_i,y_i$，表示询问在时间$y_i$，离坐标$l_i$最远的商店类型到$l_i$的距离 类型$t$的商店到一个点的距离定义为所有存在的$t$类商店到这个点的距离的最大值 $1\\le n,q\\le 3*10^5,1\\le k\\le n$ $1\\le x_i,a_i,b_i\\le 10^9$ $1\\le l_i,y_i\\le 10^8$ 分析参考kczno1的这题的一个log做法 感觉说得不能再清楚了.. 每种店开一个$multiset$维护前驱，每个坐标开一个支持删除的堆维护这个位置的最小前驱 新开一个坐标$inf$的点把所有店放上面 全部值都可以离散化 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;set&gt;#include&lt;queue&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) { if (c == '-') iosig = true; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x + (x &lt;&lt; 2)) &lt;&lt; 1) + (c ^ '0'); if (iosig) x = -x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh = obuf;inline void print(char c) { if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf; *ooh++ = c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x == 0) print('0'); else { if (x &lt; 0) print('-'), x = -x; for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48; while (cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 300005;int k, n, m, cnt, Id, tot, ori[N], Ans[N], f[N], mn[N&lt;&lt;2];pair&lt;int,int*&gt; disc[N&lt;&lt;1];multiset&lt;int&gt; s[N];struct opt{ int x, t, ti; inline bool operator &lt;(const opt &amp;rhs)const{ return ti&lt;rhs.ti;}}a[N&lt;&lt;1];struct que{ int ti, x, id; inline bool operator &lt;(const que &amp;rhs)const{ return ti&lt;rhs.ti;}}q[N];struct heap{ priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; a, b; inline void ins(int x){ a.push(x);} inline void del(int x){ if(x!=a.top()) b.push(x); else{ a.pop(); while(b.size() &amp;&amp; a.top()==b.top()) a.pop(), b.pop(); } }}h[N];void build(int l, int r, int t){ if(l==r){ h[l].ins(Id); if(l==Id) for(int i=1; i&lt;=k; ++i) h[l].ins(0); mn[t]=h[l].a.top(); return; } int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; build(l, mid, k), build(mid+1, r, k|1); mn[t]=min(mn[k], mn[k|1]);}void modify(int l, int r, int t, int x){ if(l==r) return (void)(mn[t]=h[l].a.top()); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; if(x&lt;=mid) modify(l, mid, k, x); else modify(mid+1, r, k|1, x); mn[t]=min(mn[k], mn[k|1]);}int query(int l, int r, int t, int x, int now=1e9){ if(l==r) return min(ori[l]-x, x-min(now, ori[mn[t]])); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; if(x&gt;ori[mid]) return query(mid+1, r, k|1, x, now); if(ori[mid]+1+min(now, ori[mn[k|1]])&lt;=x*2) return query(mid+1, r, k|1, x, now); else return query(l, mid, k, x, min(now, ori[mn[k|1]]));}inline void work(int x, int t){ if(t&gt;0){ tot+=!f[t]++; auto it=s[t].lower_bound(x); h[x].ins(it==s[t].begin()?0:(--it, *it++)), modify(1, Id, 1, x); if(it!=s[t].end()){ int y=*it; h[y].del(it==s[t].begin()?0:(--it, *it++)), h[y].ins(x); modify(1, Id, 1, y); } s[t].insert(x); } else{ t=-t; tot-=!--f[t]; auto it=s[t].find(x); h[x].del(it==s[t].begin()?0:(--it, *it++)), modify(1, Id, 1, x); s[t].erase(it++); if(it!=s[t].end()){ int y=*it; h[y].del(x), h[y].ins(it==s[t].begin()?0:*--it); modify(1, Id, 1, y); } }}int main() { read(n), read(k), read(m); for(int i=0; i&lt;n; ++i){ static int x, t, l, r; read(x), read(t), read(l), read(r); a[cnt++]=(opt){x, t, l}, a[cnt++]=(opt){x, t, r+1}; } for(int i=0; i&lt;cnt; ++i) disc[i]=make_pair(a[i].t, &amp;a[i].t); sort(disc, disc+cnt); for(int i=0, id=1; i&lt;cnt; ++i) *(disc[i].second)=(i &amp;&amp; disc[i].first!=disc[i-1].first?++id:id); for(int i=0; i&lt;cnt; ++i) disc[i]=make_pair(a[i].x, &amp;a[i].x); sort(disc, disc+cnt); Id=1; for(int i=0; i&lt;cnt; ++i) ori[*(disc[i].second)=(i &amp;&amp; disc[i].first!=disc[i-1].first?++Id:Id)]=disc[i].first; ori[0]=-1e9, ori[++Id]=1e9; for(int i=1; i&lt;cnt; i+=2) a[i].t=-a[i].t; build(1, Id, 1); for(int i=1; i&lt;=k; ++i) s[i].insert(Id); sort(a, a+cnt); for(int i=0; i&lt;m; ++i) read(q[i].x), read(q[i].ti), q[i].id=i; sort(q, q+m); int j=0; for(int i=0; i&lt;m; ++i){ while(a[j].ti&lt;=q[i].ti &amp;&amp; j&lt;cnt) work(a[j].x, a[j].t), ++j; Ans[q[i].id]=(tot==k?query(1, Id, 1, q[i].x):-1); } for(int i=0; i&lt;m; ++i) print(Ans[i]), print('\\n'); return flush(), 0;}","link":"/loj-2585/"},{"title":"「LOJ 2586」「APIO2018」选圆圈","text":"LOJ #2586 题意平面上有$n$个圆，编号$1..n$ 重复如下操作直到不存在圆 选择一个半径最大的圆，如果有多个，选择编号最小的 把所有与第1步选出的圆有交的圆删除 其中两个圆有交当且仅当存在一个点，这个点同时被两个圆包含，包含定义为点在圆内或者圆上 $n\\le 3*10^5$ 做法现场在划水，现在补题不知道正解了也找不到，应该也不会。 直接按照圆心坐标建k-d tree 一个点维护子树中圆的四个方向的坐标极值，也就是一个矩形 每次挑一个优先的圆去遍历树 如果圆与当前的矩形无交就可以退出了 这样可以获得 $87$ 分的好成绩 然后把所有坐标旋转一个角度就能过了 $eps$ 不能设到 $10^{-5}$ 那么小.. 逆时针旋转角 $\\alpha$ 可以理解为一个线性变换 $$\\begin{bmatrix}\\cos \\alpha &amp; -\\sin \\alpha \\\\sin \\alpha &amp; \\cos \\alpha\\end{bmatrix}\\begin{pmatrix}x \\y\\end{pmatrix}\\begin{pmatrix}x’ \\y’\\end{pmatrix}$$ 最坏时间复杂度$\\mathcal O(n^2)$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 300005;const double sina=sqrt(2)/2, cosa=sina, eps=1e-3;int n, D, now, root, ans[N], b[N], f[N], ch[N][2];double mn[N][2], mx[N][2];bool del[N];struct circle{ int r, id; double s[2]; inline bool operator &lt;(const circle &amp;rhs)const{ return r&gt;rhs.r;}}anow, a[N];inline void update(int t){ mn[t][0]=a[t].s[0]-a[t].r, mn[t][1]=a[t].s[1]-a[t].r; mx[t][0]=a[t].s[0]+a[t].r, mx[t][1]=a[t].s[1]+a[t].r; for(int i=0; i&lt;2; ++i) if(ch[t][i]) for(int j=0; j&lt;2; ++j) mx[t][j]=max(mx[t][j], mx[ch[t][i]][j]), mn[t][j]=min(mn[t][j], mn[ch[t][i]][j]);}inline bool cmp(const circle &amp;x, const circle &amp;y){ return x.s[D]&lt;y.s[D];}void build(int &amp;t, int l, int r, int k){ if(l&gt;r) return; int mid=l+r&gt;&gt;1; t=mid, D=k, nth_element(a+l, a+mid, a+r+1, cmp); build(ch[t][0], l, mid-1, k^1), build(ch[t][1], mid+1, r, k^1), update(t);}inline double sqr(double x){ return x*x;}void erase(int t, int k){ if(!t || anow.s[0]-anow.r&gt;mx[t][0] || anow.s[1]-anow.r&gt;mx[t][1] || anow.s[0]+anow.r&lt;mn[t][0] || anow.s[1]+anow.r&lt;mn[t][1]) return; if(!del[t]) if(sqr(a[t].s[0]-anow.s[0])+sqr(a[t].s[1]-anow.s[1])&lt;=sqr(a[t].r+anow.r)+eps) del[t]=1, ans[a[t].id]=anow.id, a[t].s[0]=a[t].s[1]=0, a[t].r=-2e9; erase(ch[t][0], k^1), erase(ch[t][1], k^1), update(t);}int main() { read(n); for(int i=1; i&lt;=n; ++i){ int x, y; read(x), read(y), read(a[i].r), a[i].id=i; a[i].s[0]=x*cosa-y*sina, a[i].s[1]=x*sina+y*cosa; } stable_sort(a+1, a+n+1); for(int i=1; i&lt;=n; ++i) b[a[i].id]=i; build(root, 1, n, 0); for(int i=1; i&lt;=n; ++i) f[b[a[i].id]]=i; for(int i=1; i&lt;=n; ++i) if(!del[now=f[i]]) anow=a[now], erase(root, 0); for(int i=1; i&lt;=n; ++i) print(ans[i]), print(' '); return flush(), 0;}","link":"/loj-2586/"},{"title":"「LOJ 2587」「APIO2018」铁人两项","text":"LOJ #2587 题意你有一张 $n$ 个点 $m$ 条边的无向图，你需要选择三个互不相同的点 $s,c,f$ 询问有多少种选择的方案使得存在至少一条从 $s$ 出发经过 $c$ 到达 $f$ 的简单路径（不经过重复点） $n\\le 10^5,m\\le 2*10^5$ 做法建圆方树，对每个点双建一个方点 把两个相邻的点也看做一个点双，这会使得圆方树上圆点和方点都是交替出现的 考虑怎么统计答案 枚举起点和终点 $s,f$ ，并随便找出一条 $s\\to f$ 的路径，可行的中间点 $c$ 的集合就是路径经过的所有点双包含的点 那么在圆方树上这两个点的路径包含的所有方点都会有一个 点双大小 $-1$ 的贡献 给每个方点赋一个上述的权值，圆点权值为 $0$ 一对起点和终点的贡献就是 带点权的路径长度 $-1$ 在每个方点上计算对答案的贡献，最后减掉选两个点的方案数就是答案了 复杂度 $\\mathcal O(n+m)$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;vector&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int N = 100005;ll ans;int num=1, n, m, cnt, top, p, tot, h[N], dfn[N], low[N], stk[N], g[N&lt;&lt;1], siz[N&lt;&lt;1], e[N&lt;&lt;2], pre[N&lt;&lt;2];vector&lt;int&gt; f[N&lt;&lt;1];inline void add(int x, int y){ e[++num]=y, pre[num]=h[x], h[x]=num;}void tarjan(int u, int fa=0){ ++tot; dfn[u]=low[u]=++cnt; stk[++top]=u; int son=0; for(int i=h[u]; i; i=pre[i]) if(i!=fa){ if(!dfn[e[i]]){ tarjan(e[i], i^1), low[u]=min(low[u], low[e[i]]); ++son; if(low[e[i]]&gt;=dfn[u]){ ++p; f[u].push_back(p); do f[p].push_back(stk[top]), ++g[p]; while(stk[top--]!=e[i]); } } else low[u]=min(low[u], dfn[e[i]]); }}void dfs(int u){ siz[u]=(u&lt;=n); for(int i:f[u]) dfs(i), ans+=(ll)g[u]*siz[i]*(tot-siz[i]), siz[u]+=siz[i]; ans+=(ll)g[u]*siz[u]*(tot-siz[u]);}int main() { read(n), read(m), p=n; for(int i=1; i&lt;=m; ++i){ static int x, y; read(x), read(y), add(x, y), add(y, x); } for(int i=1; i&lt;=n; ++i) if(!dfn[i]) tot=0, tarjan(i), dfs(i), ans-=(ll)tot*(tot-1); return printf(&quot;%lld&quot;, ans), 0;}","link":"/loj-2587/"},{"title":"「LOJ 3059」「HNOI 2019」序列","text":"LOJ #3059. 「HNOI 2019」序列 题意给定一个长为 $n$ 的序列 $A_1,\\dotsc,A_n$，求一个长为 $n$ 的不下降序列 $B_1,\\dotsc,B_n$，使得 $\\sum_{i=1}^n (A_i-B_i)^2$ 最小，只需要输出最小值 以及 $m$ 次互相独立的修改，每次会更改一个位置的值，要求输出修改后的答案 模 $998244353$ $n,m\\le 10^5$ 做法考虑没有修改的情况 显然如果一个 $A_i&gt;A_{i+1}$，那么必然有 $B_i=B_{i+1}$，于是我们可以把这两个位置缩起来 容易发现缩起来的块中的 $B$ 全部取 $A$ 的平均值最优 用单调栈维护缩起来的块，块的平均值保持不下降，每次新加入一个元素，不断弹出栈顶和新元素合并直到满足不下降的性质 时间复杂度 $\\mathcal O(n)$ 容易发现上面缩的过程不受顺序影响 把询问离线，对于一个位置 $i$，维护出 $1,\\dotsc,i-1$ 和 $i+1,\\dotsc,n$ 的单调栈（栈顶朝向位置 $i$） 改变 $i$ 处的值，压入左侧的栈中，可以用二分计算弹栈的次数，考虑如果弹出 $k$ 个元素后满足了不下降，弹出 $k+1$ 个也可以满足，因此可以二分 如果此时所有块满足不下降，那么已经得到了答案（左侧的栈压入后必然满足不下降，唯一可能出现问题的位置是两个栈顶之间） 否则，考虑不断把右侧的栈顶取出压入左侧，直到满足不下降，正确性显然 同理我们也可以用二分优化这个过程，考虑如果右侧取出前 $k$ 个元素压入左侧后，满足了不下降，那么取出 $k+1$ 个元素也可以满足，因为，在左侧不断弹栈的过程中间块的平均值只会不断增加，并且始终没有超过右侧栈中第 $k+1$ 个元素的平均值，因此加入右侧栈中第 $k+1$ 个元素后，弹栈过程也不会超过第 $k+1$ 个的平均值，更不会超过第 $k+2$ 个，因此可以二分 维护栈可以记忆一下操作然后撤销 时间复杂度 $\\mathcal O(n+m\\log^2 n)$，空间复杂度 $\\mathcal O(n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 100005, P = 998244353;int n, m, sum, top, top2, a[N], f[N], g[N], inv[N], ans[N], stk[N], stk2[N];ll s[N];vector&lt;int&gt; b[N];vector&lt;pair&lt;int,int&gt;&gt; q[N];inline bool cmp(int l1, int r1, int l2, int r2, int x=0, int y=0){ return (s[r1]-s[l1-1]+x)*(r2-l2+1)&gt;(s[r2]-s[l2-1]+y)*(r1-l1+1);}inline int calc(int l, int r, int x=0){ return P-(s[r]-s[l-1]+x)%P*((s[r]-s[l-1]+x)%P)%P*inv[r-l+1]%P;}int main() { freopen(&quot;sequence.in&quot;, &quot;r&quot;, stdin); freopen(&quot;sequence.out&quot;, &quot;w&quot;, stdout); read(n), read(m); for(int i=1; i&lt;=n; ++i) read(a[i]), s[i]=s[i-1]+a[i], sum=(sum+(ll)a[i]*a[i])%P; q[1].push_back(make_pair(a[1], 0)), ans[0]=sum; for(int i=1, x=0, y=0; i&lt;=m; ++i) read(x), read(y), q[x].push_back(make_pair(y, i)), ans[i]=(sum+(ll)(P-a[x])*a[x]+(ll)y*y)%P; inv[1]=1; for(int i=2; i&lt;=n; ++i) inv[i]=(ll)(P-P/i)*inv[P%i]%P; for(int i=1; i&lt;=n; ++i){ while(top &amp;&amp; cmp(stk[top-1]+1, stk[top], stk[top]+1, i)) b[i].push_back(stk[top--]); stk[++top]=i, f[top]=(f[top-1]+calc(stk[top-1]+1, i))%P; } stk2[0]=n+1; for(int i=n; i; --i){ --top; reverse(b[i].begin(), b[i].end()); for(int j:b[i]) stk[++top]=j, f[top]=(f[top-1]+calc(stk[top-1]+1, j))%P; if(i&lt;n){ while(top2 &amp;&amp; cmp(i+1, stk2[top2]-1, stk2[top2], stk2[top2-1]-1)) --top2; stk2[++top2]=i+1, g[top2]=(g[top2-1]+calc(i+1, stk2[top2-1]-1))%P; } for(auto j:q[i]){ int l=1, r=top, now=0, d=j.first-a[i]; while(l&lt;=r){ int mid=(l+r)&gt;&gt;1; if(cmp(stk[mid-1]+1, stk[mid], stk[mid]+1, i, 0, d)) r=mid-1; else now=mid, l=mid+1; } if(!top2 || !cmp(stk[now]+1, i, i+1, stk2[top2-1]-1, d)) ans[j.second]=(ans[j.second]+(ll)calc(stk[now]+1, i, d)+f[now]+g[top2])%P; else{ l=0, r=top2-1; int res=0, lans=0; while(l&lt;=r){ int mid=(l+r)&gt;&gt;1, L=1, R=now, Ans=0; while(L&lt;=R){ int Mid=(L+R)&gt;&gt;1; if(cmp(stk[Mid-1]+1, stk[Mid], stk[Mid]+1, stk2[mid]-1, 0, d)) R=Mid-1; else L=Mid+1, Ans=Mid; } if(mid &amp;&amp; cmp(stk[Ans]+1, stk2[mid]-1, stk2[mid], stk2[mid-1]-1, d)) r=mid-1; else l=mid+1, res=mid, lans=Ans; } ans[j.second]=(ans[j.second]+(ll)calc(stk[lans]+1, stk2[res]-1, d)+f[lans]+g[res])%P; } } } for(int i=0; i&lt;=m; ++i) print(ans[i]), print('\\n'); return flush(), 0;}","link":"/loj-3059/"},{"title":"「LOJ 2983」「WC2019」数树","text":"LOJ #2983. 「WC2019」数树 题意本题包含三个问题： 问题 0：已知两棵 $n$ 个节点的树的形态。要给予每个节点一个 $[1, y]$ 中的整数，使得对于任意两个节点 $p, q$，如果存在边 $(p, q)$ 同时属于这两棵树，则 $p, q$ 必须被给予相同的数。求给予数的方案数。 问题 1：已知第一棵树，对于第二棵树的所有 $n^{n−2}$ 种选择方案，求问题 0 的答案之和。 问题 2：对于第一棵树的所有 $n^{n−2}$ 种选择方案，求问题 1 的答案之和。 对 $998244353$ 取模 做法问题 0答案是 $y^{n-\\text{公共边数}}$ 问题 1令 $z=y^{-1}$ 在最后乘上 $y^n$，一种方案对答案的贡献是 $z^{\\text{公共边数}}$ 根据 $$z^k=(z-1+1)^k=\\sum_{i=0}^k \\binom{k}{i}(z-1)^k$$ 问题可以转化为：对于每个第一棵树边集的子集 $S$，和至少包含这个集合的第二棵树的每个方案，有 $(z-1)^{|S|}$ 的贡献 假设 $S$ 形成的 $m=n-|S|$ 个联通块大小分别为 $a_1,a_2,\\dotsc,a_m$ 覆盖 $S$ 的树的数量即把 $m$ 个联通块按照树的结构连接起来的方案数，等于 $$\\begin{align}&amp;\\sum_{\\substack{(\\sum_{i=1}^m d_i)=2(m-1) \\ d_i\\ge 1}} \\frac{(m-2)!}{\\prod_{i=1}^m (d_i-1)!} \\times \\prod_{i=1}^m a_i^{d_i} \\&amp;\\left(\\prod_{i=1}^m a_i \\right)\\sum_{\\substack{(\\sum_{i=1}^m d_i)=2(m-1) \\ d_i\\ge 1}} \\frac{(m-2)!}{\\prod_{i=1}^m (d_i-1)!} \\times \\prod_{i=1}^m a_i^{d_i-1}\\end{align}$$ 其中 $d_i$ 表示第 $i$ 个联通块的度数 而第 $i$ 个联通块在 Prufer 序列中出现了 $d_i-1$ 次，一种连边方案唯一对应了一种数量分别为 $d_1-1,d_2-1,\\dotsc,d_m-1$ 的 $m$ 种元素的排列，于是这部分方案数为 $\\frac{(m-2)!}{\\prod_{i=1}^m (d_i-1)!}$，每个端点可以在 $a_i$ 个点中任意选择，于是有 $\\prod_{i=1}^m a_i^{d_i}$ 的贡献。 上式可以转化为枚举 Prufer 序列的第 $i$ 位，假设是 $p_i$，有 $a_{p_i}$ 的贡献，每位的方案数就是 $(\\sum_{i=1}^m a_i)=n$，位之间独立，于是 $m-2$ 位共 $n^{m-2}$ 上式等于 $$n^{m-2} \\prod_{i=1}^m a_i$$ 其中 $\\prod_{i=1}^m a_i$ 可以理解为在每个联通块中选择一个点的方案数 答案即为 $$\\begin{align}&amp;\\sum_{S\\subseteq E} (z-1)^{n-m} n^{m-2} \\prod_{i=1}^m a_i \\=&amp;n^{-2} (z-1)^n \\sum_{S\\subseteq E} (z-1)^{-m} n^m \\prod_{i=1}^m a_i\\end{align}$$ 其中 $E$ 表示第一棵树的边集 考虑 DP，令 $f_{i,1/0}$ 表示以 $i$ 为根的子树，$i$ 所在的联通块中是否已经选出一个点的方案数，枚举一条边选和不选分别有一个系数，最终答案为 $f_{1,1}$ 复杂度 $\\mathcal O(n)$ 问题 2同样枚举一个边集 $S$ 需要被覆盖 根据上面，方案数是 $$\\left(n^{m-2} \\prod_{i=1}^m a_i\\right)^2$$ 所有联通块数量为 $m$ 的总方案数为 $$\\sum_{\\substack{(\\sum_{i=1}^m a_i)=n \\ a_i\\ge 1}} \\frac{n!}{m!\\prod_{i=1}^m a_i!} \\times \\prod_{i=1}^m a_i^{a_i-2} \\times \\left(n^{m-2} \\prod_{i=1}^m a_i\\right)^2$$ 乘上 $(z-1)^{n-m}$ 后总答案为 $$\\begin{align}&amp;\\sum_{m=1}^n (z-1)^{n-m} \\sum_{\\substack{(\\sum_{i=1}^m a_i)=n \\ a_i\\ge 1}} \\frac{n!}{m!\\prod_{i=1}^m a_i!} \\times \\prod_{i=1}^m a_i^{a_i-2} \\times \\left(n^{m-2} \\prod_{i=1}^m a_i\\right)^2 \\=&amp; (z-1)^n n^{-4} n! \\sum_{m=1}^n \\frac{(z-1)^{-m} n^{2m}}{m!} \\sum_{\\substack{(\\sum_{i=1}^m a_i)=n \\ a_i\\ge 1}} \\prod_{i=1}^m \\frac{a_i^{a_i}}{a_i!} \\=&amp; (z-1)^n n^{-4} n! [x^n] \\exp\\left(\\frac{n^2}{z-1} \\sum_{i=1}^\\infty \\frac{i^i}{i!} x^i\\right)\\end{align}$$ 最后一行的 $\\exp$ 感受一下就好了 反推还是能看出来的 复杂度 $\\mathcal O(n\\log n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;set&gt;#include&lt;vector&gt;using namespace std;#define ll long long#define ull unsigned long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int N = 100005, P = 998244353;int n, y, op;namespace subtask1{ int num, h[N], e[N&lt;&lt;1], pre[N&lt;&lt;1], f[N][2]; inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans; } inline void add(int x, int y){ e[++num]=y, pre[num]=h[x], h[x]=num;} void dfs(int u, int fa=0){ f[u][0]=1, f[u][1]=n; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa){ dfs(e[i], u); f[u][1]=((ll)f[u][1]*f[e[i]][1]+((ll)f[u][1]*f[e[i]][0]+(ll)f[u][0]*f[e[i]][1])%P*(y-1))%P; f[u][0]=((ll)f[u][0]*f[e[i]][1]+(ll)f[u][0]*f[e[i]][0]%P*(y-1))%P; } } void main(){ y=Pow(y); for(int i=1, x, y; i&lt;n; ++i) read(x), read(y), add(x, y), add(y, x); dfs(1); printf(&quot;%lld&quot;, (ll)f[1][1]*Pow(n, P-3)%P*Pow(y, P-n-1)%P); }}namespace subtask2{ const int M = 1&lt;&lt;18; struct Z{ unsigned x; Z(const unsigned _x=0):x(_x){} inline Z operator +(const Z &amp;rhs)const{ return x+rhs.x&lt;P?x+rhs.x:x+rhs.x-P;} inline Z operator -(const Z &amp;rhs)const{ return x&lt;rhs.x?x-rhs.x+P:x-rhs.x;} inline Z operator -()const{ return x?P-x:0;} inline Z operator *(const Z &amp;rhs)const{ return static_cast&lt;ull&gt;(x)*rhs.x%P;} inline Z operator +=(const Z &amp;rhs){ return x=x+rhs.x&lt;P?x+rhs.x:x+rhs.x-P, *this;} inline Z operator -=(const Z &amp;rhs){ return x=x&lt;rhs.x?x-rhs.x+P:x-rhs.x, *this;} inline Z operator *=(const Z &amp;rhs){ return x=static_cast&lt;ull&gt;(x)*rhs.x%P, *this;} } w[M], Inv[M], fac[M]; vector&lt;Z&gt; f; inline Z Pow(Z x, int y=P-2){ Z ans=1; for(; y; y&gt;&gt;=1, x=x*x) if(y&amp;1) ans=ans*x; return ans; } inline void Init(){ for(unsigned i=1; i&lt;M; i&lt;&lt;=1){ w[i]=1; Z t=Pow(3, (P-1)/i/2); for(unsigned j=1; j&lt;i; ++j) w[i+j]=w[i+j-1]*t; } Inv[1]=1; for(unsigned i=2; i&lt;M; ++i) Inv[i]=Inv[P%i]*(P-P/i); } inline int Get(int x){ int n=1; while(n&lt;=x) n&lt;&lt;=1; return n;} inline void DFT(vector&lt;Z&gt; &amp;f, int n){ static ull F[M]; if((int)f.size()!=n) f.resize(n); for(int i=0, j=0; i&lt;n; ++i){ F[i]=f[j].x; for(int k=n&gt;&gt;1; (j^=k)&lt;k; k&gt;&gt;=1); } for(int i=1; i&lt;n; i&lt;&lt;=1) for(int j=0; j&lt;n; j+=i&lt;&lt;1){ Z *W=w+i; ull *F0=F+j, *F1=F+j+i; for(int k=j; k&lt;j+i; ++k, ++W, ++F0, ++F1){ ull t=(*F1)*(W-&gt;x)%P; (*F1)=*F0+P-t, (*F0)+=t; } } for(int i=0; i&lt;n; ++i) f[i]=F[i]%P; } inline void IDFT(vector&lt;Z&gt; &amp;f, int n){ f.resize(n), reverse(f.begin()+1, f.end()); DFT(f, n); Z I=Pow(n); for(int i=0; i&lt;n; ++i) f[i]=f[i]*I; } inline vector&lt;Z&gt; operator +(const vector&lt;Z&gt; &amp;f, const vector&lt;Z&gt; &amp;g){ vector&lt;Z&gt; ans=f; for(unsigned i=0; i&lt;f.size(); ++i) ans[i]+=g[i]; return ans; } inline vector&lt;Z&gt; operator *(const vector&lt;Z&gt; &amp;f, const vector&lt;Z&gt; &amp;g){ if((ull)f.size()*g.size()&lt;=1000){ vector&lt;Z&gt; ans; ans.resize(f.size()+g.size()-1); for(unsigned i=0; i&lt;f.size(); ++i) for(unsigned j=0; j&lt;g.size(); ++j) ans[i+j]+=f[i]*g[j]; return ans; } static vector&lt;Z&gt; F, G; F=f, G=g; int p=Get(f.size()+g.size()-2); DFT(F, p), DFT(G, p); for(int i=0; i&lt;p; ++i) F[i]*=G[i]; IDFT(F, p); return F.resize(f.size()+g.size()-1), F; } vector&lt;Z&gt; &amp;PolyInv(const vector&lt;Z&gt; &amp;f, int n=-1){ if(n==-1) n=f.size(); if(n==1){ static vector&lt;Z&gt; ans; return ans.clear(), ans.push_back(Pow(f[0])), ans; } vector&lt;Z&gt; &amp;ans=PolyInv(f, (n+1)/2); vector&lt;Z&gt; tmp(&amp;f[0], &amp;f[0]+n); int p=Get(n*2-2); DFT(tmp, p), DFT(ans, p); for(int i=0; i&lt;p; ++i) ans[i]=((Z)2-ans[i]*tmp[i])*ans[i]; IDFT(ans, p); return ans.resize(n), ans; } inline vector&lt;Z&gt; Derivative(const vector&lt;Z&gt; &amp;a){ vector&lt;Z&gt; ans(a.size()-1); for(unsigned i=1; i&lt;a.size(); ++i) ans[i-1]=a[i]*i; return ans; } inline vector&lt;Z&gt; Integral(const vector&lt;Z&gt; &amp;a){ vector&lt;Z&gt; ans(a.size()+1); for(unsigned i=0; i&lt;a.size(); ++i) ans[i+1]=a[i]*Inv[i+1]; return ans; } inline vector&lt;Z&gt; PolyLn(const vector&lt;Z&gt; &amp;f){ vector&lt;Z&gt; ans=Derivative(f)*PolyInv(f); ans.resize(f.size()-1); return Integral(ans); } vector&lt;Z&gt; PolyExp(const vector&lt;Z&gt; &amp;f, int n=-1){ if(n==-1) n=f.size(); if(n==1) return {1}; vector&lt;Z&gt; ans=PolyExp(f, (n+1)/2), tmp; ans.resize(n), tmp=PolyLn(ans); for(Z &amp;i:tmp) i=-i; ++tmp[0].x; ans=ans*(tmp+f); return ans.resize(n), ans; } void main(){ if(y==1) { printf(&quot;%u&quot;, Pow(n, (n-2)*2).x); return;} Init(); y=Pow(y).x, fac[0]=1, f.resize(n+1); Z k=Pow(y-1)*n*n; for(int i=1; i&lt;=n; ++i) f[i]=k*Pow(i, i)*Pow(fac[i]=fac[i-1]*i); f=PolyExp(f); printf(&quot;%u&quot;, (f[n]*Pow(y-1, n)*Pow(n, P-5)*fac[n]*Pow(y, P-n-1)).x); }}int main() { freopen(&quot;tree.in&quot;, &quot;r&quot;, stdin); freopen(&quot;tree.out&quot;, &quot;w&quot;, stdout); read(n), read(y), read(op); if(op==0){ static set&lt;pair&lt;int,int&gt;&gt; _; static pair&lt;int,int&gt; __; for(int i=1; i&lt;n; ++i) read(__.first), read(__.second), _.insert(__); int cnt=0; for(int i=1; i&lt;n; ++i) read(__.first), read(__.second), cnt+=_.count(__); printf(&quot;%d&quot;, subtask1::Pow(y, n-cnt)); } else if(op==1) subtask1::main(); else subtask2::main(); return 0;}","link":"/loj-2983/"},{"title":"「LOJ 6201」「YNOI2016」掉进兔子洞","text":"LOJ #6201 题意您正在打galgame，然后突然发现您今天太颓了，于是想写个数据结构题练练手： 给出一个长为$n$的序列$a$。 有$m$个询问，每次询问三个区间，把三个区间中同时出现的数一个一个删掉，问最后三个区间剩下的数的个数和，询问独立。 注意这里删掉指的是一个一个删，不是把等于这个值的数直接删完，比如三个区间是$[1,2,2,3,3,3,3]$,$[1,2,2,3,3,3,3]$与$[1,1,2,3,3]$，就一起扔掉了$1$个$1$，$1$个 $2$，$2$个$3$。 $n,m\\le 10^5,a_i\\le 10^9$ 分析询问可以转化为$3$个区间的总长度-每个数在三个区间中出现的最小次数的三倍的和。 数字可以离散化 考虑数字至多出现一次的情况 用bitset表示一个区间中每个数是否出现 三个区间的bitset的AND和中$1$的个数就是所有数的最小出现次数和。 我们使用莫队来求一个区间的bitset 然后如果有重复数字，我们预留出空位，当数字$x$出现了不少于$y$次，把bitset的第$x+y$位赋成$1$ 最后统计答案不需要改变 这样bitset的长度恰好是$n$，可以接受 开不下$m$个bitset，那分成若干次处理就好了 复杂度 $\\mathcal O(m\\sqrt{n}+\\frac{nm}{32})$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;bitset&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 100005, M = 40005;int n, m, len, Ans[M], g[N], a[N], bl[N];pair&lt;int,int&gt; p[N];bitset&lt;N&gt; f, ans[M];struct query{ int l, r, id; inline bool operator &lt;(const query &amp;rhs)const{ return bl[l]==bl[rhs.l]?r&lt;rhs.r:l&lt;rhs.l; }} q[M*3];inline void ins(int x){ f[++g[x]+x]=1;}inline void del(int x){ f[g[x]--+x]=0;}inline void solve(int m){ int cnt=0; for(int i=0; i&lt;m; ++i){ Ans[i]=0; read(q[cnt].l), read(q[cnt].r), Ans[i]+=q[cnt].r-q[cnt].l+1; q[cnt++].id=i; read(q[cnt].l), read(q[cnt].r), Ans[i]+=q[cnt].r-q[cnt].l+1; q[cnt++].id=i; read(q[cnt].l), read(q[cnt].r), Ans[i]+=q[cnt].r-q[cnt].l+1; q[cnt++].id=i; ans[i].set(); } sort(q, q+cnt); int l=1, r=0; f.reset(), memset(g, 0, sizeof g); for(int i=0; i&lt;cnt; ++i){ while(l&gt;q[i].l) ins(a[--l]); while(r&lt;q[i].r) ins(a[++r]); while(l&lt;q[i].l) del(a[l++]); while(r&gt;q[i].r) del(a[r--]); ans[q[i].id]&amp;=f; } for(int i=0; i&lt;m; ++i) print(Ans[i]-ans[i].count()*3), print('\\n');}int main() { read(n), read(m); len=sqrt(n); for(int i=1; i&lt;=n; ++i) read(a[i]), p[i]=make_pair(a[i], i), bl[i]=(i+len-1)/len; sort(p+1, p+n+1); for(int i=1; i&lt;=n; ++i) a[p[i].second]=(p[i].first==p[i-1].first?a[p[i-1].second]:i-1); while(m&gt;0) solve(min(M, m)), m-=M; return flush(), 0;}","link":"/loj-6201/"},{"title":"「LOJ 2430」「POI2014」沙拉餐厅 Salad Baralad Bar","text":"LOJ #2430 题意一排$n$个水果$a_1..a_n$，分别是苹果$(j)$和橘子$(p)$，求最长的区间满足从左向右和从右向左取水果，任意时刻都有橘子数$\\ge$苹果数，输出最长的区间长度 $n\\le 10^6$ 分析记$d_i=\\sum_{x=1}^i[a_x=p]-\\sum_{x=1}^i[a_x=j]$ 一个区间$[l,r]$满足条件当且仅当$\\forall l\\le i\\le r，d_l\\le d_i\\le d_r$ 可以用单调栈处理出最近的$l$满足$d_l&gt;d_i$，于是以$i$为右端点的区间，最小的合法左端点是$[l+1,i]$中的最小值（如果存在）。 这个区间最小值位置可以在单调栈里顺便维护一下 复杂度 $\\mathcal O(n)$ 代码123456789101112131415#include&lt;cstdio&gt;#include&lt;algorithm&gt;const int N = 1000005;int n, top, ans, stk[N], a[N], f[N];char s[N];int main() { scanf(&quot;%d%s&quot;, &amp;n, s+1); for(int i=1; i&lt;=n; ++i){ a[i]=a[i-1]+(s[i]=='j'?-1:1); while(top &amp;&amp; stk[top]&lt;=a[i]) (a[f[top-1]]&gt;a[f[top]]?f[top-1]=f[top]:0), --top; if(a[f[top]]&lt;=a[i]) ans=std::max(ans, i-f[top]); ++top, stk[top]=a[i], f[top]=i; } return printf(&quot;%d&quot;, ans), 0;}","link":"/loj-2430/"},{"title":"「LOJ 6391」「THUPC2018」淘米神的树 &#x2F; Tommy","text":"LOJ #6391. 「THUPC2018」淘米神的树 / Tommy 题意有一棵 $n$ 个点的树，你要以一个顺序选择每个点恰好一次。 初始只有两个钦定点 $a,b$ 可以被选，一个点被选后所有的相邻点就可以被选择。 求方案数，模 $998244353$ 做法考虑只有一个初始点怎么做，以这个点为根，计算每个子树的方案数，合并的时候就考虑不改变顺序的方式。 记 $size_u$ 表示以 $u$ 为根的子树的大小，$son_u$ 表示 $u$ 的儿子集合。 可以发现一个点 $u$ 对答案的贡献是 $\\frac{(size_u-1)!}{\\prod\\limits_{v\\in son_u} size_v!}$ 因此答案就是 $$\\prod_{u=1}^n\\frac{(size_u-1)!}{\\prod\\limits_{v\\in son_u} size_v!}\\frac{n!}{\\prod\\limits_{u=1}^n size_u}$$ 然后考虑两个点的情况 新建一个点 $s$，与 $a,b$ 分别连边，因此问题可以等价转化到环套树上只有一个初始点 $s$ 的情况 考虑枚举环上一个最后被选到的点 $u$，我们可以分别断开与 $u$ 相连的两条环边并按照树的情况计算答案，这两种各会恰好计算 $u$ 是环上最后被选到的点的方案一次（包括 $s=u$ 的情况方案数是 $0$）。 因此我们只需要枚举每条环边断开后计算贡献，最后乘 $\\frac{1}{2}$ 即可。 首先断开环边时不会影响不在环上点对答案的贡献，可以预处理。 记断开所有环边后一个环点 $u$ 所在树的点数为 $f_u$，环依次是 $a_0,a_1,\\dotsc,a_m$，其中 $a_0=s$ 如果断开了 $a_i$ 和 $a_{i+1}$ 之间的边 对于 $j\\le i$，贡献是 $\\sum_{x=j}^i f_{a_x}$ 对于 $j&gt;i$ 贡献是 $\\sum_{x=i+1}^j f_{a_x}$ 记 $f$ 的前缀和为 $s$ 可以发现 $a_j$ 的贡献即 $|s_i-s_j|$，并且这对于 $i=m$ （断开 $a_m$ 和 $s$ 之间的边）仍然成立 于是我们需要对于每个 $i$ 求出 $\\prod_{j\\ne i} |s_i-s_j|$ 可以讨论负号会出现多少次去掉绝对值，只需要求每个 $\\prod_{j\\ne i} (s_i-s_j)$ 记 $g(x)=\\prod_{j=0}^m (x-s_j)$，也就是求 $x\\to s_i$ 时 $f_i(x)=\\frac{g(x)}{x-s_i}$ 的值 根据 洛必达法则 我们有 $f_i(s_i)=g’(s_i)$ 于是分治求出 $g(x)$ 后多点求值即可 复杂度 $\\mathcal O(n \\log^2 n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ull unsigned long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 234570, P = 998244353, inv2 = (P+1)/2, M = 1&lt;&lt;19;int n, a, b, cnt, q[N], siz[N];vector&lt;int&gt; e[N];struct Z{ unsigned x; Z(const unsigned _x=0):x(_x){} inline Z operator +(const Z &amp;rhs)const{ return x+rhs.x&lt;P?x+rhs.x:x+rhs.x-P;} inline Z operator -(const Z &amp;rhs)const{ return x&lt;rhs.x?x-rhs.x+P:x-rhs.x;} inline Z operator -()const{ return x?P-x:0;} inline Z operator *(const Z &amp;rhs)const{ return static_cast&lt;ull&gt;(x)*rhs.x%P;} inline Z operator +=(const Z &amp;rhs){ return x=x+rhs.x&lt;P?x+rhs.x:x+rhs.x-P, *this;} inline Z operator -=(const Z &amp;rhs){ return x=x&lt;rhs.x?x-rhs.x+P:x-rhs.x, *this;} inline Z operator *=(const Z &amp;rhs){ return x=static_cast&lt;ull&gt;(x)*rhs.x%P, *this;}} ans, ans0;vector&lt;Z&gt; f, g;namespace Poly{ Z w[M];// for DFT vector&lt;Z&gt; ans;// for Evaluate() vector&lt;vector&lt;Z&gt;&gt; p;// for Evaluate() &amp; Interpolate() inline Z Pow(Z x, int y=P-2){ Z ans=1; for(; y; y&gt;&gt;=1, x=x*x) if(y&amp;1) ans=ans*x; return ans; } inline void Init(){ for(unsigned i=1; i&lt;M; i&lt;&lt;=1){ w[i]=1; Z t=Pow(3, (P-1)/i/2); for(unsigned j=1; j&lt;i; ++j) w[i+j]=w[i+j-1]*t; } } inline int Get(int x){ int n=1; while(n&lt;=x) n&lt;&lt;=1; return n;} inline void DFT(vector&lt;Z&gt; &amp;f, int n){ static ull F[M]; if((int)f.size()!=n) f.resize(n); for(int i=0, j=0; i&lt;n; ++i){ F[i]=f[j].x; for(int k=n&gt;&gt;1; (j^=k)&lt;k; k&gt;&gt;=1); } for(int i=1; i&lt;n; i&lt;&lt;=1) for(int j=0; j&lt;n; j+=i&lt;&lt;1){ Z *W=w+i; ull *F0=F+j, *F1=F+j+i; for(int k=j; k&lt;j+i; ++k, ++W, ++F0, ++F1){ ull t=(*F1)*(W-&gt;x)%P; (*F1)=*F0+P-t, (*F0)+=t; } } for(int i=0; i&lt;n; ++i) f[i]=F[i]%P; } inline void IDFT(vector&lt;Z&gt; &amp;f, int n){ f.resize(n), reverse(f.begin()+1, f.end()); DFT(f, n); Z I=Pow(n); for(int i=0; i&lt;n; ++i) f[i]=f[i]*I; } inline vector&lt;Z&gt; operator +(const vector&lt;Z&gt; &amp;f, const vector&lt;Z&gt; &amp;g){ vector&lt;Z&gt; ans=f; for(unsigned i=0; i&lt;f.size(); ++i) ans[i]+=g[i]; return ans; } inline vector&lt;Z&gt; operator *(const vector&lt;Z&gt; &amp;f, const vector&lt;Z&gt; &amp;g){ if((ull)f.size()*g.size()&lt;=1000){ vector&lt;Z&gt; ans; ans.resize(f.size()+g.size()-1); for(unsigned i=0; i&lt;f.size(); ++i) for(unsigned j=0; j&lt;g.size(); ++j) ans[i+j]+=f[i]*g[j]; return ans; } static vector&lt;Z&gt; F, G; F=f, G=g; int p=Get(f.size()+g.size()-2); DFT(F, p), DFT(G, p); for(int i=0; i&lt;p; ++i) F[i]*=G[i]; IDFT(F, p); return F.resize(f.size()+g.size()-1), F; } vector&lt;Z&gt; &amp;PolyInv(const vector&lt;Z&gt; &amp;f, int n=-1){ if(n==-1) n=f.size(); if(n==1){ static vector&lt;Z&gt; ans; return ans.clear(), ans.push_back(Pow(f[0])), ans; } vector&lt;Z&gt; &amp;ans=PolyInv(f, (n+1)/2); vector&lt;Z&gt; tmp(&amp;f[0], &amp;f[0]+n); int p=Get(n*2-2); DFT(tmp, p), DFT(ans, p); for(int i=0; i&lt;p; ++i) ans[i]=((Z)2-ans[i]*tmp[i])*ans[i]; IDFT(ans, p); return ans.resize(n), ans; } // a=d*b+r inline void PolyDiv(const vector&lt;Z&gt; &amp;a, const vector&lt;Z&gt; &amp;b, vector&lt;Z&gt; &amp;d, vector&lt;Z&gt; &amp;r){ if(b.size()&gt;a.size()) return d.clear(), (void)(r=a); vector&lt;Z&gt; A=a, B=b, iB; int n=a.size(), m=b.size(); reverse(A.begin(), A.end()), reverse(B.begin(), B.end()); B.resize(n-m+1), iB=PolyInv(B, n-m+1); d=A*iB; d.resize(n-m+1), reverse(d.begin(), d.end()); r=b*d, r.resize(m-1); for(int i=0; i&lt;m-1; ++i) r[i]=a[i]-r[i]; } inline vector&lt;Z&gt; Derivative(const vector&lt;Z&gt; &amp;a){ vector&lt;Z&gt; ans(a.size()-1); for(unsigned i=1; i&lt;a.size(); ++i) ans[i-1]=a[i]*i; return ans; } void Evaluate_Interpolate_Init(int l, int r, int t, const vector&lt;Z&gt; &amp;a){ if(l==r) return p[t].clear(), p[t].push_back(-a[l]), p[t].push_back(1); int mid=(l+r)/2, k=t&lt;&lt;1; Evaluate_Interpolate_Init(l, mid, k, a), Evaluate_Interpolate_Init(mid+1, r, k|1, a); p[t]=p[k]*p[k|1]; } void Evaluate(int l, int r, int t, const vector&lt;Z&gt; &amp;f, const vector&lt;Z&gt; &amp;a){ if(r-l+1&lt;=512){ for(int i=l; i&lt;=r; ++i){ Z x=0, a1=a[i], a2=a[i]*a[i], a3=a[i]*a2, a4=a[i]*a3, a5=a[i]*a4, a6=a[i]*a5, a7=a[i]*a6, a8=a[i]*a7; int j=f.size(); while(j&gt;=8) x=x*a8+f[j-1]*a7+f[j-2]*a6+f[j-3]*a5+f[j-4]*a4+f[j-5]*a3+f[j-6]*a2+f[j-7]*a1+f[j-8], j-=8; while(j--) x=x*a[i]+f[j]; ans.push_back(x); } return; } vector&lt;Z&gt; tmp; PolyDiv(f, p[t], tmp, tmp); Evaluate(l, (l+r)/2, t&lt;&lt;1, tmp, a), Evaluate((l+r)/2+1, r, t&lt;&lt;1|1, tmp, a); } inline vector&lt;Z&gt; Evaluate(const vector&lt;Z&gt; &amp;f, const vector&lt;Z&gt; &amp;a, int flag=-1){ if(flag==-1) p.resize(a.size()&lt;&lt;2), Evaluate_Interpolate_Init(0, a.size()-1, 1, a); return ans.clear(), Evaluate(0, a.size()-1, 1, f, a), ans; } inline vector&lt;Z&gt; Divide(int l, int r){ if(l==r) return {P-g[l].x, 1}; int mid=(l+r)&gt;&gt;1; return Divide(l, mid)*Divide(mid+1, r); }}inline bool find(int u, int fa=0){ siz[u]=1; bool t=(u==b); for(int i:e[u]) if(i!=fa) t|=find(i, u), siz[u]+=siz[i]; if(t) q[cnt++]=u; else ans0*=siz[u]; return t;}int main() { Poly::Init(); read(n), read(a), read(b); for(int i=1, x, y; i&lt;n; ++i) read(x), read(y), e[x].push_back(y), e[y].push_back(x); ans0=1, find(a); g.push_back(1); for(int i=0; i&lt;cnt; ++i) g.push_back(siz[q[i]]+1); f=Poly::Evaluate(Poly::Derivative(Poly::Divide(0, cnt)), g); for(int i=0; i&lt;=cnt; ++i) ans+=Poly::Pow(f[i]*((cnt^i)&amp;1?P-1:1)); for(int i=1; i&lt;=n; ++i) ans*=i; return printf(&quot;%d&quot;, (ans*Poly::Pow(ans0)*inv2).x), 0;}","link":"/loj-6391/"},{"title":"「LOJ 6509」「雅礼集训 2018 Day7」C","text":"LOJ #6509. 「雅礼集训 2018 Day7」C 题意给定一棵 $n$ 个点的树，树上每个点初始有一个 $0$ 或 $1$ 的数字。 考虑这样一个过程： 等概率随机选择一个点作为起点 等概率随机选择一个新点并沿着树上的路径移动过去，最后反转这个新点上的数字（注意只反转这个新点上的数字而非经过的所有点的数字） 如果此时整棵树上的所有数字相同，则过程结束；否则回到步骤 $2$ 求出期望的移动距离，对 $10^9 + 7$ 取模。 $n\\le 10^5$ 做法考虑每次选出的点构成的序列 一个点只要不是在最后出现，由于下一步是等概率随机的，所以产生的贡献是固定的，是该点与树上所有点的平均距离 那么我们只要计算每个数不在最后一个位置出现的期望次数就可以计算答案 可以发现期望出现次数只与 $0$ 和 $1$ 的数量有关 记 $f_{i,0/1}$ 表示有 $i$ 个 $1$ 时，一个位置 的 $0/1$ 期望的出现次数 显然有 $f_{0, * } = 0$ 和 $f_{n, * } = 0$ 考虑方程 $$\\begin{align}f_{i,0} &amp;= \\frac{i}{n} f_{i-1, 0} + \\frac{n-i-1}{n} f_{i+1, 0} + \\frac{1}{n} f_{i+1,1} + \\frac{1}{n} \\f_{i,1} &amp;= \\frac{n-i}{n} f_{i+1, 1} + \\frac{i-1}{n} f_{i-1, 1} + \\frac{1}{n} f_{i-1,0} + \\frac{1}{n}\\end{align}$$ 即在这一次选择了 与钦定位置不同色 钦定位置 同色的非钦定位置 以及每次在 $n$ 个点中选到的概率 $\\frac{1}{n}$ 注意这里的 $\\frac{1}{n}$ 要保证这不是最后一个位置才能存在，于是在 $f_{1,1}$ 和 $f_{n-1,0}$ 处的式子不能加 直接高斯消元是 $\\mathcal O(n^3)$ 考虑到上面的式子很优美 保留 $f_{1,0},f_{1,1}$ 两个未知数计算，从小到大推 假设已经知道了对于 $0\\le i\\le k$ 的 $f_{i, * }$，我们可以用 $f_{k,1}$ 的式子直接计算 $f_{k+1,1}$，再用 $f_{k,0}$ 的式子和 $f_{k+1,1}$ 算出 $f_{k+1,0}$ 这样可以推出所有 $i&lt;n$ 的 $f_{i, * }$ 利用 $f_{n-1,* }$ 的两个式子解出两个未知数，代入可以求得我们需要的 $f_{s, * }$ 其中 $s$ 是初始 $1$ 的个数 注意这里的 $f$ 没有计算到随机选择的起点，每个点的期望次数要加另外的 $\\frac{1}{n}$ 复杂度 $\\mathcal O(n)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 100005, P = 1000000007;int n, num, ans, b, w, tot, x, y, inv[N], siz[N], h[N], e[N], pre[N];ll f[N];char s[N];struct p{ int a, b, c; inline p(){ a=b=c=0;} inline p(int x){ a=b=0, c=x;} template&lt;class T&gt; inline p(T x, T y, T z){ a=x, b=y, c=z;} inline p operator +(const p &amp;rhs)const{ return {(a+rhs.a)%P, (b+rhs.b)%P, (c+rhs.c)%P};} inline p operator -(const p &amp;rhs)const{ return {(a-rhs.a+P)%P, (b-rhs.b+P)%P, (c-rhs.c+P)%P};} inline p operator *(int rhs)const{ return {(ll)a*rhs%P, (ll)b*rhs%P, (ll)c*rhs%P};}} A, B, a[N][2];inline void add(int x, int y){ e[++num]=y, pre[num]=h[x], h[x]=num;}void dfs1(int u){ siz[u]=1; for(int i=h[u]; i; i=pre[i]) dfs1(e[i]), siz[u]+=siz[e[i]], f[u]+=f[e[i]]+siz[e[i]];}void dfs2(int u){ for(int i=h[u]; i; i=pre[i]) f[e[i]]=f[u]+n-siz[e[i]]*2, dfs2(e[i]);}inline int Pow(ll x, int y=P-2){ int ans=1; for(x%=P; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}int main() { read(n); inv[0]=inv[1]=1; for(int i=2; i&lt;=n; ++i) inv[i]=(ll)(P-P/i)*inv[P%i]%P; while(isspace(s[1]=read())); for(int i=2; i&lt;=n; ++i) s[i]=read(); for(int i=1; i&lt;=n; ++i) tot+=(s[i]=='1'); for(int i=2, x; i&lt;=n; ++i) read(x), add(x, i); dfs1(1), dfs2(1); a[1][0].a=a[1][1].b=1; for(int i=1; i&lt;n-1; ++i){ a[i+1][1]=(a[i][1]*n-a[i-1][1]*(i-1)-a[i-1][0]-(i!=1))*inv[n-i]; a[i+1][0]=(a[i][0]*n-a[i-1][0]*i-a[i+1][1]-1)*inv[n-i-1]; } A=a[n-2][0]*(n-1)-a[n-1][0]*n; B=a[n-2][1]*(n-2)-a[n-1][1]*n+a[n-2][0]+1; x=((ll)A.c*B.b-(ll)A.b*B.c)%P*Pow((ll)A.b*B.a-(ll)A.a*B.b)%P; swap(A.a, A.b), swap(B.a, B.b); y=((ll)A.c*B.b-(ll)A.b*B.c)%P*Pow((ll)A.b*B.a-(ll)A.a*B.b)%P; b=((ll)a[tot][1].a*x+(ll)a[tot][1].b*y+a[tot][1].c)%P+inv[n]; w=((ll)a[tot][0].a*x+(ll)a[tot][0].b*y+a[tot][0].c)%P+inv[n]; for(int i=1; i&lt;=n; ++i) ans=(ans+f[i]%P*(s[i]=='1'?b:w))%P; return printf(&quot;%lld&quot;, (ll)(ans+P)*inv[n]%P), 0;}","link":"/loj-6509/"},{"title":"旅途的开始","text":"4月29日我们在一起啦！","link":"/love/"},{"title":"「Luogu P4705」玩游戏","text":"Luogu P4705 玩游戏 题意有长度为 $n$ 的序列 $a$ 和长度为 $m$ 的序列 $b$ 对于 $k=1,2,\\dotsc,t$ 求随机两个元素 $a_i$ 和 $b_j$，$(a_i+b_j)^k$ 的期望 模 $998244353$ $n,m,t\\le 10^5$ 做法有点神 首先二项式展开 $$\\begin{align}&amp; \\sum_{i=1}^n \\sum_{j=1}^m (a_i+b_j)^k \\= &amp; \\sum_{i=1}^n \\sum_{j=1}^m \\sum_{x=0}^k a_i^xb_j^{k-x} \\binom{k}{x} \\= &amp; k!\\sum_{i=1}^n \\sum_{j=1}^m \\sum_{x=0}^k \\frac{a_i^x}{x!} \\times \\frac{b_j^{k-x}}{(k-x)!} \\= &amp; k!\\sum_{x=0}^k \\left(\\sum_{i=1}^n \\frac{a_i^x}{x!} \\right) \\left(\\sum_{i=1}^m \\frac{b_i^{k-x}}{(k-x)!}\\right)\\end{align}$$ 可以发现右边是卷积的形式，我们只要对于每一个 $x$ 求出 $\\sum\\limits_{i=1}^n a_i^x$ 和 $\\sum\\limits_{i=1}^m b_i^x$ 即可 构造多项式 $f(x)=\\prod\\limits_{i=1}^n (a_ix+1)$，这可以用分治 NTT 在 $\\mathcal O(n\\log^2n)$ 的复杂度内求出来 由于 $\\ln (ax+1) = -\\sum\\limits_{i=1}^\\infty \\frac{(-1)^i}{i}a^ix^i$ 证明如下 首先有 $$\\frac{1}{1-x}=\\sum_{i=0}^\\infty x^i$$ 所以 $$\\begin{align}(\\ln(1-x))’ &amp;= -\\frac{1}{1-x} = -\\sum_{i=0}^\\infty x^i \\\\ln(1-x) &amp;= -\\sum_{i=1}^\\infty \\frac{x^i}{i}\\end{align}$$ 用 $-ax$ 代入即可 所以 $\\ln(f(x)) = -\\sum\\limits_{j=1}^n \\sum\\limits_{i=1}^\\infty \\frac{(-1)^i}{i}a_j^ix^i$ 多余的系数去掉可以得到我们需要的每个 $\\sum\\limits_{i=1}^n a_i^x$ 求这个的另一种方法是从 牛顿恒等式 推，本质似乎是一样的 总复杂度 $\\mathcal O(n\\log^2n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ull unsigned long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const unsigned P = 998244353;struct Z{ unsigned x; Z(const unsigned _x=0):x(_x){} inline Z operator +(const Z &amp;rhs)const{ return x+rhs.x&lt;P?x+rhs.x:x+rhs.x-P;} inline Z operator -(const Z &amp;rhs)const{ return x&lt;rhs.x?x-rhs.x+P:x-rhs.x;} inline Z operator -()const{ return x?P-x:0;} inline Z operator *(const Z &amp;rhs)const{ return static_cast&lt;ull&gt;(x)*rhs.x%P;} inline Z operator +=(const Z &amp;rhs){ return x=x+rhs.x&lt;P?x+rhs.x:x+rhs.x-P, *this;} inline Z operator -=(const Z &amp;rhs){ return x=x&lt;rhs.x?x-rhs.x+P:x-rhs.x, *this;} inline Z operator *=(const Z &amp;rhs){ return x=static_cast&lt;ull&gt;(x)*rhs.x%P, *this;}};int n, m, t;vector&lt;Z&gt; a, b;namespace Poly{ const int MAX_LEN = 1&lt;&lt;18; Z w[MAX_LEN], Inv[MAX_LEN];// for DFT inline Z Pow(Z x, int y=P-2){ Z ans=1; for(; y; y&gt;&gt;=1, x=x*x) if(y&amp;1) ans=ans*x; return ans; } inline void Init(){ for(int i=1; i&lt;MAX_LEN; i&lt;&lt;=1){ w[i]=1; Z t=Pow(3, (P-1)/i/2); for(int j=1; j&lt;i; ++j) w[i+j]=w[i+j-1]*t; } Inv[1]=1; for(int i=2; i&lt;MAX_LEN; ++i) Inv[i]=Inv[P%i]*(P-P/i); } inline int Get(int x){ int n=1; while(n&lt;=x) n&lt;&lt;=1; return n;} inline void DFT(vector&lt;Z&gt; &amp;f, int n){ static ull F[MAX_LEN]; if((int)f.size()!=n) f.resize(n); for(int i=0, j=0; i&lt;n; ++i){ F[i]=f[j].x; for(int k=n&gt;&gt;1; (j^=k)&lt;k; k&gt;&gt;=1); } for(int i=1; i&lt;n; i&lt;&lt;=1) for(int j=0; j&lt;n; j+=i&lt;&lt;1){ Z *W=w+i; ull *F0=F+j, *F1=F+j+i; for(int k=j; k&lt;j+i; ++k, ++W, ++F0, ++F1){ ull t=(*F1)*(W-&gt;x)%P; (*F1)=*F0+P-t, (*F0)+=t; } } for(int i=0; i&lt;n; ++i) f[i]=F[i]%P; } inline void IDFT(vector&lt;Z&gt; &amp;f, int n){ f.resize(n), reverse(f.begin()+1, f.end()); DFT(f, n); Z I=Pow(n); for(int i=0; i&lt;n; ++i) f[i]=f[i]*I; } inline vector&lt;Z&gt; Add(const vector&lt;Z&gt; &amp;f, const vector&lt;Z&gt; &amp;g){ vector&lt;Z&gt; ans=f; for(unsigned i=0; i&lt;f.size(); ++i) ans[i]+=g[i]; return ans; } inline vector&lt;Z&gt; Mul(const vector&lt;Z&gt; &amp;f, const vector&lt;Z&gt; &amp;g){ if(f.size()*g.size()&lt;=1000){ vector&lt;Z&gt; ans; ans.resize(f.size()+g.size()-1); for(unsigned i=0; i&lt;f.size(); ++i) for(unsigned j=0; j&lt;g.size(); ++j) ans[i+j]+=f[i]*g[j]; return ans; } static vector&lt;Z&gt; F, G; F=f, G=g; int p=Get(f.size()+g.size()-2); DFT(F, p), DFT(G, p); for(int i=0; i&lt;p; ++i) F[i]*=G[i]; IDFT(F, p); return F.resize(f.size()+g.size()-1), F; } vector&lt;Z&gt; &amp;PolyInv(const vector&lt;Z&gt; &amp;f, int n=-1){ if(n==-1) n=f.size(); if(n==1){ static vector&lt;Z&gt; ans; return ans.clear(), ans.push_back(Pow(f[0])), ans; } vector&lt;Z&gt; &amp;ans=PolyInv(f, (n+1)/2); vector&lt;Z&gt; tmp(&amp;f[0], &amp;f[0]+n); int p=Get(n*2-2); DFT(tmp, p), DFT(ans, p); for(int i=0; i&lt;p; ++i) ans[i]=((Z)2-ans[i]*tmp[i])*ans[i]; IDFT(ans, p); return ans.resize(n), ans; } inline vector&lt;Z&gt; Derivative(const vector&lt;Z&gt; &amp;a){ vector&lt;Z&gt; ans(a.size()-1); for(unsigned i=1; i&lt;a.size(); ++i) ans[i-1]=a[i]*i; return ans; } inline vector&lt;Z&gt; Integral(const vector&lt;Z&gt; &amp;a){ vector&lt;Z&gt; ans(a.size()+1); for(unsigned i=0; i&lt;a.size(); ++i) ans[i+1]=a[i]*Inv[i+1]; return ans; } inline vector&lt;Z&gt; PolyLn(const vector&lt;Z&gt; &amp;f){ vector&lt;Z&gt; ans=Mul(Derivative(f), PolyInv(f)); ans.resize(f.size()-1); return Integral(ans); } vector&lt;Z&gt; divide(int l, int r, const vector&lt;Z&gt; &amp;f){ if(l==r) return vector&lt;Z&gt;{1, f[l]}; int mid=(l+r)&gt;&gt;1; return Mul(divide(l, mid, f), divide(mid+1, r, f)); } inline vector&lt;Z&gt; solve(const vector&lt;Z&gt; &amp;f, int t){ vector&lt;Z&gt; ans=divide(0, f.size()-1, f); ans.resize(t+1), ans=PolyLn(ans); for(int i=1; i&lt;=t; ++i) ans[i]*=(i&amp;1?i:P-i); return ans[0]=f.size(), ans; }}int main() { Poly::Init(); read(n), read(m), a.resize(n), b.resize(m); for(int i=0; i&lt;n; ++i) read(a[i].x); for(int i=0; i&lt;m; ++i) read(b[i].x); read(t); a=Poly::solve(a, t); b=Poly::solve(b, t); for(int i=1, k=1; i&lt;=t; k=(ull)k*Poly::Inv[++i].x%P) a[i]=a[i]*k; for(int i=1, k=1; i&lt;=t; k=(ull)k*Poly::Inv[++i].x%P) b[i]=b[i]*k; a=Poly::Mul(a, b), a.resize(t+1); for(int i=1, k=Poly::Pow((ull)n*m%P).x; i&lt;=t; k=(ull)k*++i%P) print((a[i]*k).x), print('\\n'); return flush(), 0;}","link":"/luogu-4705/"},{"title":"「Luogu P5023」填数游戏","text":"NOIP2018 唯一没做出来的题 要是写完两题后直接去打暴力大概也不止50分吧 反正确实跪在这题了 Luogu P5023 题意你有一个 $n$ 行 $m$ 列的矩阵，左上角为 $(0,0)$ 每一个位置有一个数字 $0/1$ 你需要从 $(0,0)$ 走到 $(n-1,m-1)$，只能向右或向下走 $(R/D)$，一共 $n+m-2$ 步，这会形成一条路径 把方向记下来可以得到同样长度的只包含 $R/D$ 的字符串 $w(P)$ 并且经过的 $n+m-1$ 个位置的数字连起来可以得到一个 $01$ 串 $s(P)$ 你需要求出有多少种填数的方案，使得对于任意两条路径 $P_1,P_2$，若 $w(P_1)&gt;w(P_2)$，那么 $s(P_1)\\le s(P_2)$ 模 $10^9+7$ $n\\le 8,m\\le 10^6$ 做法转化限制可以等价转化为下面两个条件 对于 $x+y$ 为定值的所有点 $(x,y)$，构成一条斜线，自左向右是连续的一段$0$加上连续的一段$1$，可以全部相同 这是因为一条到 $(x,y)$ 的路径向两个方向走的时候必须要有 $(x+1,y)$ 上的数字不大于 $(x,y+1)$ 即任意 $(x,y)$ 不大于 $(x-1,y+1)$ 若 $(x-1,y)$ 和 $(x,y-1)$ 上的数字相同，那么以 $(x,y)$ 为左上角的极大的子矩阵在一个斜行上的数字都相同，即对于 $a\\ge x,b\\ge y$的 $(a,b)$ 有约束 这是因为当 $(x-1,y)$ 和 $(x,y-1)$ 上的数字相同，从 $(x-1,y-1)$ 经过这两个位置再到 $(x,y)$ 的路径的 $01$ 串相同 也就是说到 $(x,y)$ 有至少两条 $01$ 串相同的路径 那么接下来的每一步必须相同，否则会存在不满足限制的路径 观察显然 $n,m$ 交换并不会影响答案 下面只考虑$3\\le n\\le m$的情况，其余情况都可以简单计算 分类讨论1. $(0,1)$ 和 $(1,0)$ 相同以 $(1,1)$ 为左上角的矩形的斜线上数字都相同，只剩下 $(0,x)$ 和 $(x,0)$ 需要再判一下 2. $(0,2),(1,1)$ 和 $(2,0)$ 相同和情况1差不多，多特判一条斜线就好了 3 &amp; 4. $(1,1)$ 和 $(0,2),(2,0)$ 中的恰好一个相同容易发现两种是对称的，下面只考虑有 $(2,0)$ 和 $(1,1)$ 是 $0$ 的情况 这时以 $(2,1)$ 为左上角的子矩阵斜线部分相同 也就是左边剩下一列，顶部剩下两行没有限制 再讨论 考虑这种情况 有 $5$ 种填法 0000, 0111 和 1111 好像这四种都一样.. 这会使斜线区域在两步后扩大至前两种大情况中 0001 这会维持现状 也就是枚举一下在哪一个斜行选择什么方案，然后计算一下贡献就好了，可以通过预处理后缀 这5种情况并不是总是都存在，再判一下就好了 总时间复杂度 $\\mathcal O(n+m)$ 可以发现每一次的贡献都形如 $c*2^a3^b$，并且3,4两种情况都是连续的 $\\mathcal O(1)$ 段等比数列，可以快速幂 总复杂度 $\\mathcal O(\\log n+\\log m)$ 代码复杂度 $\\mathcal O(n+m)$ 代码中矩形是从 $(1,1)$ 到 $(n,m)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longconst int N = 1000015, P = 1000000007;int n, m, ans, a[N], f[N];int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if(n&gt;m) swap(n, m); if(n==1){ ans=1; for(int i=1; i&lt;=m; ++i) ans=ans*2%P; return printf(&quot;%d&quot;, ans), 0; } if(n==2){ ans=4; for(int i=1; i&lt;m; ++i) ans=ans*3ll%P; return printf(&quot;%d&quot;, ans), 0; } // init f[n+m+1]=1; for(int i=n+m; i&gt;=4; --i) f[i]=(ll)f[i+1]*(a[i]=2+(i&lt;=n+1)+(i&lt;=m+1))%P; // 1 &amp; 2 ans=4*(f[4]+(ll)(a[5]+1)*f[6])%P; // 3 for(int i=5; i&lt;=n+1; ++i){ int x=2+(i&lt;=m+1); ans=(ans+2ll*(1+x)*(a[i+1]+1)*f[i+2])%P; } ans=(ans+2ll*(a[n+2]+1)*f[n+3])%P; // 4 for(int i=5; i&lt;=m+1; ++i){ int x=2+(i&lt;=n+1); ans=(ans+2ll*(1+x)*(a[i+1]+1)*f[i+2])%P; } ans=(ans+2ll*(a[m+2]+1)*f[m+3])%P; printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/luogu-p5023/"},{"title":"「Luogu P3674」小清新人渣的本愿","text":"Luogu P3674 题意你有一个长为$n$的数列$a$，$q$个询问，有三类，每次指定一个区间$[l,r]$和一个数$x$。 询问区间中是否存在两个数相加为$x$ 询问区间中是否存在两个数相减为$x$ 询问区间中是否存在两个数相乘为$x$ 两个数可以在同一位置 $n,q\\le10^5,0\\le a_i\\le10^5$ 分析直接莫队 维护正反两个值的$bitset$。 $n,q$和值域同阶，乘法$\\mathcal O(\\sqrt n)$枚举较小的数即可 总复杂度$\\mathcal O(n(\\sqrt n+\\frac{n}{64}))$ 跑得异常快 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;bitset&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 100005;int n, m, cnt[N], a[N], bl[N];bool ans[N];bitset&lt;N&gt; f, g;struct query{ int opt, l, r, x, id; inline bool operator &lt;(const query &amp;rhs)const{ return bl[l]==bl[rhs.l]?(r&lt;rhs.r)^(bl[l]&amp;1):bl[l]&lt;bl[rhs.l]; }}q[N];int main() { read(n), read(m); for(int i=1; i&lt;=n; ++i) read(a[i]); for(int i=1; i&lt;=m; ++i) read(q[i].opt), read(q[i].l), read(q[i].r), read(q[i].x), q[i].id=i; int len=sqrt(m); for(int i=1; i&lt;=n; ++i) bl[i]=(i-1)/len+1; sort(q+1, q+m+1); int l=1, r=0; for(int i=1; i&lt;=m; ++i){ while(l&gt;q[i].l) --l, f[a[l]]=g[100000-a[l]]=(++cnt[a[l]]&gt;0); while(r&lt;q[i].r) ++r, f[a[r]]=g[100000-a[r]]=(++cnt[a[r]]&gt;0); while(l&lt;q[i].l) f[a[l]]=g[100000-a[l]]=(--cnt[a[l]]&gt;0), ++l; while(r&gt;q[i].r) f[a[r]]=g[100000-a[r]]=(--cnt[a[r]]&gt;0), --r; if(q[i].opt==1) ans[q[i].id]=(f&amp;(f&gt;&gt;q[i].x)).any(); else if(q[i].opt==2) ans[q[i].id]=(f&amp;(g&gt;&gt;(100000-q[i].x))).any(); else for(int j=1; j*j&lt;=q[i].x; ++j) if(q[i].x%j==0 &amp;&amp; f[j] &amp;&amp; f[q[i].x/j]){ ans[q[i].id]=1; break;} } for(int i=1; i&lt;=m; ++i, print('\\n')) if(ans[i]) print('h'), print('a'), print('n'), print('a'); else print('b'), print('i'); return flush(), 0;}","link":"/luogu-p3674/"},{"title":"Min_25筛","text":"前言大家都会啊，还是一次考试题的部分分，听 ftq 讲了 咕了几天就来学了 好像比杜教筛少很多思维难度吧 update: 好难啊，重新理解了好多次，还改了文章结构 简介如果一个积性函数 $f(i)$ 在 $i$ 是质数时是一个关于 $i$ 的低次多项式，并且在质数的幂处的能快速求，那么大概可以用Min_25筛来求 $$\\sum_{i=1}^n f(i)$$ 对于 $f(1)$ 特判 时间复杂度 $\\mathcal O(\\frac{n^\\frac{3}{4}}{\\log n})$，空间复杂度$\\mathcal O(\\sqrt{n})$ 并且同时我们可以求出每个 $\\lfloor \\frac{n}{x} \\rfloor$ 的 $\\sum\\limits_{i=2}^{\\lfloor \\frac{n}{x} \\rfloor}[\\text{$i$ 是质数}]f(i)$ 前置技能：埃拉托斯特尼筛法埃拉托斯特尼筛法的第 $i$ 轮找出第 $i$ 个质数，并把所有 $i$ 的倍数筛去 对所有 $\\le \\sqrt{n}$ 的质数执行完之后就可以结束 事实上被 $i$ 第一次筛去的 $i$ 的倍数 $x$ 必然满足 $x \\ge i^2$ 算法流程第一部分 处理质数我们先来处理每个 $\\lfloor \\frac{n}{x} \\rfloor$ 的 $$\\sum_{i=2}^{\\lfloor \\frac{n}{x} \\rfloor}[\\text{$i$ 是质数}]f(i)$$ 对于质数 $p$，$f(p)$ 可以被表示为若干 $p^k$ 的和，所以我们只考虑 $f(p)=p^k$ 的情况 令 $$g(a,b)=\\sum_{i=2}^a [\\text{$i$ 是质数 或 $pmin_i&gt;prime_b$}] * i^k$$ 其中 $pmin_i$ 表示 $i$ 的最小质因子，$prime_b$ 表示第 $b$ 个质数 直观地说，就是对 $2..a$ 做埃拉托斯特尼筛法 $b$ 轮后剩下的所有数的 $k$ 次幂和，包括 $prime_1,..,prime_b$ 这些处理过的质数 需要求的就是 $$\\sum_{i=2}^n [\\text{$i$ 是质数}]f(i)=g(n,\\infty)$$ 我们从小到大枚举质数，从 $g(* ,b-1)$ 推出 $g(* ,b)$ $$g(a,0)=\\sum_{i=2}^a i^k$$ $$g(a,b)=\\begin{cases}g(a,b-1), &amp; a&lt;prime_b^2\\g(a,b-1)-prime_b^k\\left(g(\\lfloor \\frac{a}{prime_b} \\rfloor,b-1)-g(prime_{b-1},b-1)\\right), &amp; a\\ge prime_b^2\\end{cases}$$ 若 $a&lt;prime_b^2$，所有 $a$ 以内的合数都被筛掉了，不会再产生影响 若 $a\\ge prime_b^2$，此时我们考虑一轮埃拉托斯特尼筛法会筛掉的数 每一个 $\\le \\lfloor \\frac{a}{prime_b} \\rfloor$ 的且不含有 $&lt;prime_b$ 的质因子的数的 $prime_b$ 倍，都会被筛掉 但是 $g(\\lfloor \\frac{a}{prime_b} \\rfloor,b-1)$ 包含了 $&lt;prime_b$ 的质数，把这些影响消去即可 事实上做完 $b-1$ 轮的时候 $\\le prime_{b-1}$ 的只剩下质数了，于是可以直接取 $g(prime_{b-1},b-1)$ 可以发现 $a$ 的取值都形如 $\\lfloor \\frac{n}{x} \\rfloor$，其中 $prime_{b-1}&lt;\\sqrt{n}$，所以没有影响 我们记录 $\\mathcal O(\\sqrt{n})$ 个值，递推即可，复杂度 $\\mathcal O(\\frac{n^\\frac{3}{4}}{\\log n})$ 第二部分 计算答案令 $$S(a,b)=\\sum_{i=2}^a [\\text{$i$ 是质数 或 $pmin_i\\ge prime_b$}]f(i)$$ 显然所求 $$\\sum_{i=1}^n f(i)=S(n,1)+f(1)$$ 和上面类似地，但是需要枚举指数 $$S(a,b)=\\begin{cases}S(a,b+1), &amp; a&lt;prime_b^2 \\\\S(a,b+1) + \\\\sum\\limits_{prime_b^{i+1} \\le a} \\left(f(prime_b^i)* \\left(S(\\lfloor \\frac{a}{prime_b^i} \\rfloor, b+1) - g(prime_b, \\infty)\\right) + f(prime_b^{i+1}) \\right), &amp; a\\ge prime_b^2\\end{cases}$$ 相当于每次把最小质因数为 $prime_b$ 的合数加进来 复杂度也是 $\\mathcal O(\\frac{n^{\\frac{3}{4}}}{\\log n})$ 第二部分的另一种实现不记忆化，暴力递归求一个值 重新定义，令 $$S(a,b)=\\sum_{i=2}^a [pmin_i\\ge prime_b]f(i)$$ 区别就是这里不包含额外的质数 计算 $S(a,b)$ 中质数的贡献 即$\\sum_{i=2}^a [\\text{$i\\ge prime_b$ 且 $i$ 是质数}]f(i)$ 这可以通过处理的 $g$ 快速得到，就是$g(a,\\infty)-g(prime_{b-1},\\infty)$ 实际上这里的 $g(prime_{b-1},\\infty)$ 由于 $prime_{b-1}$ 是很小的，下面有些代码中在筛质数的时候预处理了这部分值，本质是一样的 计算合数的贡献 我们枚举最小的质因子 $prime_i$ 和次数 $t$ 有贡献 $$\\sum_{i=b}^{\\infty} \\sum_{t\\ge 1, prime_i^{t+1}\\le a}\\left( S(\\lfloor \\frac{a}{prime_i^t} \\rfloor,i+1) * f(prime_i^t) + f(prime_i^{t+1}) \\right)$$ 其中后一部分是计算该质数幂的贡献，前一部分是其它的合数 $S( * ,i+1)$ 保证了没有 $\\le prime_i$ 的质因子，$prime_i^{t+1}\\le a$ 保证了不会越界 所以两部分加起来就好了 $$S(a,b)=\\begin{cases}0, &amp; a&lt;prime_b\\\\g(a,\\infty)-g(prime_{b-1},\\infty)+ \\\\sum\\limits_{i=b}^{\\infty} \\sum\\limits_{t\\ge 1, prime_i^{t+1}\\le a}\\left( S(\\lfloor \\frac{a}{prime_i^t} \\rfloor,i+1) * f(prime_i^t) + f(prime_i^{t+1}) \\right), &amp;a\\ge prime_b\\end{cases}$$ 这部分不加记忆化也跑得飞快，好像也被证明是 $\\mathcal O(\\frac{n^{\\frac{3}{4}}}{\\log n})$ 的 但是这种方法在有些求多个值的时候不适用 实现不是很会优化常数 我们可以预处理所有的 $\\lfloor \\frac{n}{x} \\rfloor$ 的值，并从小到大地记为 $a_1,..,a_m$ 可以发现 对于 $1\\le i \\le \\sqrt{n}$ 有 $a_i=i$ 对于其他的 $i$ 有 $\\lfloor \\frac{n}{a_i} \\rfloor=m-i+1$ 这样我们可以实现 $\\mathcal O(1)$ 从数字到编号的转换 下面有一些代码是相反的顺序，并且使用了两个数组来实现转换 在处理 $g$ 的时候直接用转换之后的值计算，滚动第二维，空间复杂度 $O(\\sqrt{n})$ 一种写法是线性筛 $\\le \\sqrt{n}$ 的质数 但是如果我们需要筛 $f(i)=1$ 在质数处的和时，可以在第一部分中顺便处理，具体可以参考例题一的代码 例题例题一 区间素数个数LOJ #6235. 区间素数个数 题意求 $1,..,n$ 中的质数数量 $n\\le 10^{11}$ 实现并不需要上述的第二部分求 $S$，令 $f(i)=1$，求出 $g(n,\\infty)$ 就是答案 代码中使用了两个数组 $id1[x]$ 和 $id2[x]$ 分别存 $\\le \\sqrt{n}$ 和 $&gt; \\sqrt{n}$ 的数字对应的编号 注意这里和上面描述的不同，$a_1,..,a_n$ 是从大到小记录对应的数字 代码123456789101112131415161718192021#include&lt;cstdio&gt;#include&lt;math.h&gt;#define ll long longconst int N = 316300;ll n, g[N&lt;&lt;1], a[N&lt;&lt;1];int id, cnt, sn, prime[N];inline int Id(ll x){ return x&lt;=sn?x:id-n/x+1;}int main() { scanf(&quot;%lld&quot;, &amp;n), sn=sqrt(n); for(ll i=1; i&lt;=n; i=a[id]+1) a[++id]=n/(n/i), g[id]=a[id]-1; for(int i=2; i&lt;=sn; ++i) if(g[i]!=g[i-1]){ // 这里 i 必然是质数，因为 g[] 是前缀质数个数 // 当 &lt;i 的质数的倍数都被筛去，让 g[] 发生改变的位置只能是下一个质数 prime[++cnt]=i; ll sq=(ll)i*i; for(int j=id; a[j]&gt;=sq; --j) g[j]-=g[Id(a[j]/i)]-(cnt-1); } return printf(&quot;%lld\\n&quot;, g[id]), 0;} 例题二 SumLuogu P4213 【模板】杜教筛（Sum） 题意给定正整数 $n&lt;2^{31}$，求 $$\\sum_{i=1}^n \\varphi(i) \\\\sum_{i=1}^n \\mu(i)$$ 实现令 $g(i)$ 表示 $i$ 以内质数的和，$h(i)$ 表示 $i$ 以内质数的数量 那么求 $\\varphi(i)$ 的前缀和就用 $g(i)-h(i)$，$\\mu(i)$ 的前缀和用 $-h(i)$ 做就好了 直接不记忆化递归实现 求 $\\mu$ 的时候有些系数为 $0$ 的可以不搜下去，应该会快不少 目前跑的最快 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;math.h&gt;using namespace std;#define ll long longconst int N = 46345;ll g[N&lt;&lt;1];int T, id, sum[N], h[N&lt;&lt;1];unsigned cnt, sn, n, id1[N], id2[N], prime[N], a[N&lt;&lt;1];bool p[N];inline unsigned Id(unsigned x){ return x&lt;=sn?x:id-n/x+1;}ll SolvePhi(unsigned a, int b){ if(a&lt;prime[b]) return 0; ll ans=g[Id(a)]-(sum[b-1]-(b-1)); for(unsigned i=b; i&lt;=cnt &amp;&amp; prime[i]*prime[i]&lt;=a; ++i){ // 这里是强行展开了一层，可能会快一点，因为条件必然满足，事实上可以和下面的写在一起 ans+=(SolvePhi(a/prime[i], i+1)+prime[i])*(prime[i]-1); for(unsigned x=prime[i]*prime[i], f=x-prime[i]; (ll)x*prime[i]&lt;=a; x=x*prime[i], f*=prime[i]) ans+=(SolvePhi(a/x, i+1)+prime[i])*f; } return ans;}int SolveMu(unsigned a, int b){ if(a&lt;prime[b]) return 0; int ans=h[Id(a)]+(b-1); for(unsigned i=b; i&lt;=cnt &amp;&amp; prime[i]*prime[i]&lt;=a; ++i) ans-=SolveMu(a/prime[i], i+1); return ans;}int main() { scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%u&quot;, &amp;n), sn=sqrt(n); if(!n){ puts(&quot;0 0&quot;); continue;} cnt=id=0; for(unsigned i=1; i&lt;=n; i=a[id]+1) a[++id]=n/(n/i), g[id]=(ll)a[id]*(a[id]+1)/2-1, h[id]=a[id]-1; for(unsigned i=2; i&lt;=sn; ++i) if(h[i]!=h[i-1]){ prime[++cnt]=i, sum[cnt]=sum[cnt-1]+i; unsigned sq=i*i; for(int j=id; a[j]&gt;=sq; --j){ unsigned t=Id(a[j]/i); g[j]-=i*(g[t]-sum[cnt-1]); h[j]-=h[t]-(cnt-1); } } for(int i=1; i&lt;=id; ++i) g[i]-=h[i], h[i]*=-1; // 上面的计算都是不考虑 1 的函数值的，要加上去 printf(&quot;%lld %d\\n&quot;, SolvePhi(n, 1)+1, SolveMu(n, 1)+1); } return 0;} 例题三 简单的函数LOJ #6053. 简单的函数 题意 $f(1)=1$ 对于质数 $p$，$f(p^c)=p \\oplus c$，其中 $\\oplus$ 表示按位异或运算 对于互质的 $a,b$，$f(ab)=f(a)f(b)$ 求 $$\\sum_{i=1}^n f(i) \\mod (10^9+7)$$ $n\\le 10^{10}$ 实现一步步代进去就好了 对于质数 $p$ 的函数值， $$f(p)=\\begin{cases}p+1, &amp; p=2 \\p-1, &amp; p\\ne 2\\end{cases}$$ 除了 $2$ 的情况，这是和 $\\varphi(p)$ 一样的 质数的幂直接在枚举的时候计算 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;math.h&gt;using namespace std;#define ll long longconst int N = 100005, P = 1000000007;ll n, g[N&lt;&lt;1], h[N&lt;&lt;1], a[N&lt;&lt;1];int sn, id, cnt, prime[N];inline int Id(ll x){ return x&lt;=sn?x:id-n/x+1;}inline int S(ll a, int b){ if(a&lt;prime[b]) return 0; ll ans=g[Id(a)]-g[prime[b-1]]+P; for(int i=b, lim=sqrt(a); i&lt;=cnt &amp;&amp; prime[i]&lt;=lim; ++i){ ans+=(ll)S(a/prime[i], i+1)*(prime[i]^1)+(prime[i]^2); for(ll x=(ll)prime[i]*prime[i], j=2; x*prime[i]&lt;=a; x*=prime[i], ++j) ans+=(ll)S(a/x, i+1)*(prime[i]^j)+(prime[i]^(j+1)); } return ans%P;}int main() { scanf(&quot;%lld&quot;, &amp;n), sn=sqrt(n); for(ll i=1; i&lt;=n; i=a[id]+1){ a[++id]=n/(n/i); ll tmp=a[id]%P; g[id]=tmp*(tmp+1)/2%P-1, h[id]=a[id]-1; } for(int i=2; i&lt;=sn; ++i) if(h[i]!=h[i-1]){ prime[++cnt]=i; ll sq=(ll)i*i; for(int j=id; a[j]&gt;=sq; --j){ int t=Id(a[j]/i); (g[j]-=i*(g[t]-g[i-1]))%=P; // 这里 g[i-1] 和 g[prime[cnt-1]] 没有区别 h[j]-=h[t]-(cnt-1); } } for(int i=1; i&lt;=id; ++i) (g[i]+=(i&gt;1)*2+P-h[i])%=P; return printf(&quot;%d\\n&quot;, (S(n, 1)+1)%P), 0;} 例题四 Counting DivisorsSPOJ DIVCNT2 - Counting Divisors (square) SPOJ DIVCNT3 - Counting Divisors (cube) SPOJ DIVCNTK - Counting Divisors (general) 题意令 $\\sigma_0(n)$ 表示 $n$ 的约数个数 求 $$\\sum_{i=1}^n \\sigma_0(i^k)$$ 对 $2^{64}$ 取模 前两题即 $k=2,3$ 的情况，数据范围略有不同 $n\\le 10^{11}$ 实现差不多了 这里只贴DIVCNTK的代码 另外两题代码参考 「SPOJ DIVCNT2」Counting Divisors (square) 「SPOJ DIVCNT3」Counting Divisors (cube) 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;math.h&gt;using namespace std;#define ll long long#define ull unsigned llconst int N = 100005;int T, sn, id, cnt, prime[N];ll n, k, a[N&lt;&lt;1];ull g[N&lt;&lt;1];inline int Id(ll x){ return x&lt;=sn?x:id-(n/x)+1;}ull S(ll a, int b){ if(a&lt;prime[b]) return 0; ull ans=g[Id(a)]-(b-1)*(k+1); for(int i=b, lim=sqrt(a); i&lt;=cnt &amp;&amp; prime[i]&lt;=lim; ++i){ ans+=S(a/prime[i], i+1)*(k+1)+(k*2+1); for(ll x=(ll)prime[i]*prime[i], j=(k*2+1); x*prime[i]&lt;=a; x*=prime[i], j+=k) ans+=S(a/x, i+1)*j+j+k; } return ans;}int main() { scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%llu%llu&quot;, &amp;n, &amp;k), sn=sqrt(n); cnt=id=0; for(ll i=1; i&lt;=n; i=a[id]+1) a[++id]=n/(n/i), g[id]=(ull)(a[id]-1)*(k+1); for(int i=2; i&lt;=sn; ++i) if(g[i]!=g[i-1]){ prime[++cnt]=i; ll lim=(ll)i*i; for(int j=id; a[j]&gt;=lim; --j) g[j]-=g[Id(a[j]/i)]-(ull)(cnt-1)*(k+1); } printf(&quot;%llu\\n&quot;, S(n, 1)+1); } return 0;} 例题五 SPOJ APS2 Amazing Prime Sequence (hard)参考这里 例题六 51nod 1847 奇怪的数学题参考这里 例题七 51nod 1965 奇怪的式子参考这里","link":"/min-25/"},{"title":"NOI2019 游记","text":"写了六题暴力。 都考完了来记一下吧 = = 7.13感觉到最后一周才开始节制摸鱼，药丸。打了场 LNR，B 题多一个 $\\log$ 卡了卡就过了感觉还可以。 昨天回了家却被大雨和夜色束缚，有些失落，等到今天才有机会出去。虽然走了很多路被淋得很湿，但我倒是不怕的，只是辛苦了她。 7.14很早的高铁，很晚才到，到了就被热死了。 和 zx 跑到了接站的大巴上，另外有些人被丢下了，不过自己打车比大巴快 = = 寝室没有网，冬令营的时候住女寝 F 五楼还没这个问题的，中国移动真垃圾。 晚上突然雷雨，别人刚去报告厅，明天就要笔试了好慌，今天背了说不定还会忘。 7.15上午是开幕式，还有直播。 听说每个省要喊口号，ftq 说喊“浙江浙江，没人得奖；膜拜大佬，你们真强”，但是最后很多省也没喊于是鸽了。 下午是练习赛，前半个小时是笔试，紧张，不过都蒙对了。 晚上是国家队见面会。 明天就一试了，复习了下二次剩余什么的，好慌。 7.16 - Day 1开场看第一题感觉直接暴力 $2\\times 10^8$ 挺稳，自己卡了卡也只要 0.3s 左右。 第三题一脸可做的样子但是水平太低，看上去好像可以模拟费用流的样子但是就算知道也不一定会做吧。 把每个元素按照 $a-b$ 排序之后就有简单的 $O(n^3)$ 的暴力了，之后一直在这个基础上想也没有新的进展。 听说数据有梯度但是懒得写滚动（不知道为什么），只是把数组略微开大了点于是就没有额外的分数了。 第二题分析出最大值分治之后很开心（？）但是一直没想到拿满暴力的写法，直到比较迟了去搜了一下区间数量才改出来，顺便写了个插值就跑了。 下午复评的时候感觉整个人都死了，还好没挂不然又要像冬令营的时候想跳下去。 100+60+40 三题暴力好像勉强卡进队线，被摁在地上摩擦。 7.17社会活动，热死了，广东省博物馆的广东省历史都不开放也是服了，基本上把能走的地方走完了。 晚上有见面会，明天就二试了，新学了 PAM 和 Pollard’s rho 什么的，啥都不会，感觉好慌。 7.18 - Day 2开场看第一题感觉直接 k-d tree 就没了，自己也不会卡，造了组随机数据 0.1s，后来加了个不平衡重构，出来之后听说重构复杂度可能是错的，但是最后的确跑了 0.1s 多一点，也不想管了 = = 第二题感觉好难先扔了后来就写了 40 分跑路了。 第三题是看上去很有趣的交互，想特殊性质 A 的时候就想到了后来出题人说的无环图的优美做法，但是一开始没想到 D 怎么做，于是有 54 分。 后来感觉 D 就是加个随机的校验值来判叶子就好了，于是就有 68 分。 Scape 提前告诉了我分数，于是复评的时候就不慌了。 100+40+68 三题暴力，也被摁在地上摩擦。 真实六题暴力。 7.19活力嘉年华鸽了，一个人颓废也这么累。","link":"/noi2019/"},{"title":"NOI2020 退役记","text":"这大概是最后一次重要比赛了。 7.16坐高铁去长沙。 7.17开幕式和笔试，笔试不负众望阿了一克。 7.18 - Day 1一个小时做了第一题，想着过会儿回来对拍（危）。 看到第二题以为是 ABC152F 加强版，居然出到了 $5\\times 10^5$，不过并不是。对着容斥改了个 dp，拿脚优化了一下就过了，但是已经过去 3h 了。 第三题写了三个暴力，区间逆序对的大样例原来不是满的，我以为过了就不去卡常了，于是从 52 挂成了 48，第一次在 NOI 挂分。 最后 10min 开始验证第一题的正确性，手造了一个无解的输入，它挂了。我慌了。 后来发现了一个地方清空长度出了问题，改了似乎过了，边权全相同的情况也过拍了，但是还是很慌。还好最后过了。 晚上听说没比队线高几分，似乎也和去年五五开。 7.19 - Day 2今年没有活动了。 一个小时做了第一题。 看到第二题读错题了（那么简单必然是读错了），写了个假的挂了大样例。第三题是弦图，我不会。 我想 Day 1 分那么高，Day 2 可能 145 也差不多了。 后来突然想到第二题链的分治做法似乎可以扩展，原来居然没意识到，所以要构造的大概只是一个毛毛虫状物。花了十几分钟把原来的假代码改了改就过了。 第三题还是不会做，最后写了 25 分，都忘了还有无解的分。 出来碰到 pjy，他说他大众分 225，我说我也是大众分，又垫一底。 zx 说第二题过了一坨，我想我确实又垫一底，不过最后好像没垫到。pjy 所谓的乱搞过了一个部分分，245 标准分了。 查完分和 pjy 一起被 lj 抓了说还在这里干嘛赶紧回去写英文自我介绍，于是溜回寝室陷入自闭，自闭中吃了顿晚餐。犹豫了很久写了几句幼儿园水平的话。后来掐指一算莫得前六机会，就开始狂欢了，整了个糖豆人但是信号实在太差了。 7.20看前六答辩，有些自我介绍不堪入耳（大概是没准备吧）。感觉得到 zrf 已经非常努力了，但是第四并不是 zzy，太可惜了。 闭幕式巨长，终于等到颁奖，上去被王宏说我没挂狗牌。看完捧杯之后就溜去恰午餐了，恰完回寝室理东西，下午的高铁在晚上到家了。 后记虽然还没有完全退役，但我的心已经不在了。也没什么理由对它那么排斥，也许只是有些累，高三这一年不知道会发生什么，我仍然期待着。","link":"/noi2020/"},{"title":"NOIP2018游记","text":"高中的第一场重要比赛 慌得一匹 update 11.24: 之前没把博客文件移到新电脑上..更新不了 好像确实开栈了，没有挂分，550 同学们好多都考炸了，真糟糕 update 11.12 &amp; 11.13: 如果开栈好像没挂分.. D2T3不知道怎么就爆栈了，$10^5$ 层递归，里面用了包含 $4$ 个long long的struct matrix的构造函数，占了 $32$ bytes 麻烦wuy看了好久..一层实际占的 $80$ bytes分析不出来 D2T2如果直接去打暴力可以不止50分的，也是自己水平低啊 被初二初三小哥们踩爆了 Day0Open Day当然是颓颓颓了 和yf打荒野行动，听到了魔性的笑声 和贺指导打荒野行动，水平太低了，贺指导带不动我，没吃到鸡。 没有体验，打到怀疑智商了 也补了不少算法，还是有很多欠缺 紧张，不过有你在 Day1感觉还可以 睡眠不够，有点困 迷迷糊糊开始考了 题目很原的样子 先写了T1，但是T2,3都没有一眼秒 反复看了几遍，最后顺序开题了 好像63min就写完了 到结束也没打开扫雷或小恐龙 暴力都写不出来，要怎么对拍。划划水就结束了，挺难熬的。 让贺指导溜掉了 出来之后别人说是三道原题，一个个都AK了 mqy说 周指导不愧是AK王，出来以后精神焕发。 如果我fst赛季就要报销了 回到学校你已经不在了 下午和晚上继续颓，觉得Day2题会难，有压力但是根本不想学习 打打cs还是可以的 睡得没那么早 Day2出去买早饭被保安叔叔拦住了 最终还是出不去，就去食堂随便吃了点，糟糕 很想睡觉但是睡不着，划了划水就去考试了 第一题没看清楚，以为点有优先级，可以重复，然后只隐隐约约会树的$\\mathcal O(n^2 \\log n)$做法，凉 然后看2,3也不会做 后来还是刚T1，1h才过样例 还是不会2 冷静看了下3，发现是动态dp板子题，刚刚学过，赶紧写 $\\mathcal O((n+m)\\log n)$的 100000 跑了1.6s，不想去卡常了 在还有1h不到的时候开始拍了，好像没挂的样子 然后刚2，最后当然不会做，还有19min发现写挂的东西大概有50分，就不想着写subtask了 如果不fst还可以 回来看到你发的好多消息，你怎么今天才告诉我 到机房划水 听说AK王周指导有一点点小失误，差点AK了 明天就要读文化课了，今天先写了几道物理题，结果公式都忘了，凉 总结不知道会fst多少分，要是退役役了怎么办啊 复习什么的都没有用，还是看rp，或者像AK王那样实力AK 多打打隔膜有益身心健康","link":"/noip2018/"},{"title":"「Nowcoder Contest 295 H」Playing games","text":"H. Playing games 题意你有 $n$ 堆石子，数量分别是 $a_1,..,a_n$ 问最多能选出几堆使得玩 Nim游戏 满足后手必胜 $n,a_i\\le 5*10^5$ 做法首先题意可以转化为选出尽量多的数使得异或和为 $0$ 这等价于选出尽量少的数的异或和等于 $a_1,..,a_n$ 的异或和 令 $s$ 表示 $a_1,..,a_n$ 的异或和 可以发现至多选出 $\\lceil \\log_2 max{a_i}\\rceil$ 个数可以满足要求 这非常小 于是我们枚举一个答案 $ans$ 用一个数列记录每个值出现的次数，异或卷积 $ans$ 次幂的第 $s$ 位如果不为空，那么 $ans$ 是可行的 用FWT加速这个过程，总复杂度 $\\mathcal O(n\\log^2n)$ 考虑增加一个元素 $0$ 使得答案具有可二分性 复杂度 $\\mathcal O(n\\log n\\log\\log n)$ 事实上我们并不需要每次IFWT 令集合幂级数 $f$ 表示集合幂级数 $\\hat f$ 的沃尔什逆变换（Inverse Walsh Transform） 有 $$f_S=\\frac{1}{2^n}\\sum_{T\\subseteq 2^U}\\hat f_T(-1)^{|S\\cap T|}$$ 这可以在 $\\mathcal O(n)$ 的时间内求出IFWT后一位的值 这样只需要在一开始做一次FWT 总复杂度 $\\mathcal O(n\\log n)$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int N = 1&lt;&lt;19, P = 998244353;int n, sum, cnt[N], f[N], g[N];inline void FWT(int *f){ for(int i=1; i&lt;N; i&lt;&lt;=1) for(int j=0; j&lt;N; j+=i&lt;&lt;1) for(int k=j; k&lt;i+j; ++k){ int x=f[k], y=f[k+i]; f[k]=(x+y)%P, f[k+i]=(x-y)%P; }}int main() { read(n); for(int i=1, x; i&lt;=n; ++i) read(x), f[x]=1, sum^=x; f[0]=1; FWT(f); for(int i=1; i&lt;N; ++i) cnt[i]=cnt[i^(i&amp;-i)]+1; for(int i=0; i&lt;N; ++i) g[i]=1; for(int i=0; i&lt;=19; ++i){ ll ans=0; for(int j=0; j&lt;N; ++j) ans+=(cnt[j&amp;sum]&amp;1?-g[j]:g[j]); if(ans%P) return printf(&quot;%d&quot;, n-i), 0; for(int j=0; j&lt;N; ++j) g[j]=(ll)g[j]*f[j]%P; } return 0;}","link":"/nowcoder-295h/"},{"title":"min-max容斥","text":"描述Maximum-minimums identity 对于一个集合 $S$ 有 $$\\begin{align}\\max(S) &amp;= \\sum_{T \\subseteq S} (-1)^{|T|+1} \\min(T) \\\\min(S) &amp;= \\sum_{T \\subseteq S} (-1)^{|T|+1} \\max(T)\\end{align}$$ 其中 $\\max(S)$ 表示集合 $S$ 中的最大元素，$\\min(S)$ 表示 $S$ 中的最小元素 证明略 在期望下也成立 $$\\begin{align}E(\\max(S)) &amp;= \\sum_{T \\subseteq S} (-1)^{|T|+1} E(\\min(T)) \\E(\\min(S)) &amp;= \\sum_{T \\subseteq S} (-1)^{|T|+1} E(\\max(T))\\end{align}$$ 不会证 例题随机游走LOJ #2542. 「PKUWC2018」随机游走 题意给定一棵 $n$ 个点的树和起点 $x$，每次会等概率地走到相邻的点。 有 $Q$ 次询问，每次给定一个点集 $S$，求经过 $S$ 中每个点至少一次的期望步数。 $x$ 视为一开始就被经过一次。 对 $998244353$ 取模 $n\\le 18, Q\\le 5000$ 做法记 $t_i$ 表示第一次经过点 $i$ 的时间（不是期望） 假设询问的集合是 ${a_1,a_2,\\dotsc,a_k}$ 令 $S={t_{a_1},t_{a_2},\\dotsc,t_{a_k}}$ 答案即为 $E(\\max(S))$ 根据上面的等式，问题转化为求 $$\\sum_{T \\subseteq S} (-1)^{|T|+1} E(\\min(T))$$ 假如求出了每个 $E(\\min(T))$，直接枚举复杂度是 $\\mathcal O(3^n)$，高维前缀和 $\\mathcal O(n\\times 2^n)$ 考虑如何求一个 $E(\\min(T))$，这等于走到 $T$ 中任意一个点即停止的期望步数 令 $f_u$ 表示从 $u$ 出发的期望步数，因此 $E(\\min(T))=f_x$ 以 $x$ 为根，记 $u$ 的度数为 $d_u$，$u$ 的父亲为 $fa_u$ 对于 $u\\in T$ 有 $f_u=0$ 对于一般的节点 $u$，有 $$f_u=\\frac{f_{fa_u}+\\sum_{v \\text{是} u \\text{的儿子}} f_v}{d_u}+1$$ 显然任意一个 $u\\in T$ 的子树都不需要考虑 直接高斯消元是 $\\mathcal O(n^3)$ 的 对于树上的问题有更好的做法 设 $f_u=a_u f_{fa_u}+b_u$ 显然对于 $u\\in T$ 有 $a_u=b_u=0$ 假设我们已经求出 $u$ 每个儿子 $v$ 的 $a_v, b_v$ 代入有 $$d_u f_u=f_{fa_u}+ \\left(\\sum_{v \\text{是} u \\text{的儿子}} a_v f_u \\right)+ \\left(\\sum_{v \\text{是} u \\text{的儿子}} b_v \\right) +d_u$$ 整理得到 $$f_u=\\frac{f_{fa_u} + \\left( \\sum_{v \\text{是} u \\text{的儿子}} b_v \\right) + d_u}{d_u-\\sum_{v \\text{是} u \\text{的儿子}} a_v}$$ 因此 $$a_u = \\frac{1}{d_u-\\sum_{v \\text{是} u \\text{的儿子}} a_v} ,b_u = \\frac{d_u+ \\sum_{v \\text{是} u \\text{的儿子}} b_v}{d_u-\\sum_{v \\text{是} u \\text{的儿子}} a_v}$$ 根节点 $x$ 没有父亲，即 $f_x=b_x$ 单次时间 $\\mathcal O(n \\times \\log 998244353)$ 总复杂度 $\\mathcal O(n \\times \\log 998244353 \\times 2^n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;using namespace std;#define ll long longconst int N = 20, P = 998244353, M = 1&lt;&lt;18;int n, q, r, num, d[N], a[N], b[N], h[N], e[N&lt;&lt;1], pre[N&lt;&lt;1];ll f[M];bool ban[N];inline void add(int x, int y){ e[++num]=y, pre[num]=h[x], h[x]=num;}inline int Pow(ll x, int y=P-2){ int ans=1; for(; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}void dfs(int u, int fa=0){ if(ban[u]) return (void)(a[u]=b[u]=0); ll sa=0, sb=0; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa) dfs(e[i], u), sa+=a[e[i]], sb+=b[e[i]]; a[u]=Pow((d[u]-sa)%P+P), b[u]=(sb+d[u])%P*a[u]%P;}int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;q, &amp;r); for(int i=1, x, y; i&lt;n; ++i) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), add(x, y), add(y, x), ++d[x], ++d[y]; for(int i=0; i&lt;1&lt;&lt;n; ++i){ bool cnt=0; for(int j=0; j&lt;n; ++j) cnt^=ban[j+1]=i&gt;&gt;j&amp;1; dfs(r), f[i]=(cnt?b[r]:P-b[r]); } for(int i=1; i&lt;1&lt;&lt;n; i&lt;&lt;=1) for(int j=0; j&lt;1&lt;&lt;n; j+=i&lt;&lt;1) for(int k=j; k&lt;j+i; ++k) f[k+i]+=f[k]; while(q--){ int k, s=0, x; scanf(&quot;%d&quot;, &amp;k); while(k--) scanf(&quot;%d&quot;, &amp;x), s|=1&lt;&lt;(x-1); printf(&quot;%d\\n&quot;, (int)(f[s]%P)); } return 0;} 按位或LOJ #2127. 「HAOI2015」按位或 题意你有一个数字 $0$，每秒你会以 $p_i$ 的概率选择 $i$，$i\\in[0,2^n-1]$，和自己的数进行按位或，问期望多少秒后数字变成 $2^n-1$ $n\\le20,\\sum p_i=1$ 做法不用 min-max容斥的做法在 这里. 网上很多我就不写了","link":"/maximum-minimums-identity-notes/"},{"title":"「牛客挑战赛31 E | Nowcoder 880E」密涅瓦的谜题","text":"好久没更了 = = 现在看到什么题都感觉一脸不可做，水平太低了 题意给出仅包含小写字母的长度为 $n$ 的字符串 $s$ 每次取出 $s$ 的一个子串 $t_i$（可以为空），执行 $m$ 次，顺次拼接成一个大字符串 $t=t_1 t_2\\dots t_m$，求可以得到多少种本质不同的 $t$ $q$ 次询问，每次给出一个 $m$ $n,q\\le 10^5, m\\le 10^{10}$ 做法考虑 $t$ 的一种唯一分解的方式（不会算重），每次取 $t$ 最长的是 $s$ 子串的前缀，作为这次选取的子串。由于更短的前缀也必然是一个子串，这种做法显然存在解且唯一的 一组 $t_1 t_2 \\dots t_m$ 合法当且仅当 $\\forall 1\\le i&lt;m$ 有 $t_i$ 加上 $t_{i+1}$ 的第一个字符后不是 $s$ 的子串 令 $f_{i,j}$ 表示考虑了最后 $i$ 次选取的子串，当前的第一个字符是 $j$ 的方案数，只要保证新选取的子串加上 $j$ 后不是 $s$ 的子串即可转移 特殊的，$j$ 可以为空字符，即第 $m-i+1$ 次选取的是空串 $$f_{i,j}=\\sum_k A_{k,j} \\times f_{i-1,k}$$ 其中 $A$ 是系数矩阵，可以在 SAM 上 dp 得到 令 $\\sigma$ 表示字符集大小，复杂度 $\\mathcal O(n \\sigma)$ 答案为 $$\\begin{bmatrix}0 &amp; \\cdots &amp; 0 &amp; 1\\end{bmatrix}A^m\\begin{bmatrix}1 &amp; \\cdots &amp; 1 &amp; 1\\end{bmatrix}^{\\rm T}$$ 考虑对 $m$ 分块 答案转化为 $$\\begin{bmatrix}0 &amp; \\cdots &amp; 0 &amp; 1\\end{bmatrix}A^{\\left\\lfloor \\frac{m}{S} \\right\\rfloor \\times S}\\timesA^{m \\bmod S}\\begin{bmatrix}1 &amp; \\cdots &amp; 1 &amp; 1\\end{bmatrix}^{\\rm T}$$ 左侧只有 $\\mathcal O(\\frac{m}{S})$ 种取值，右侧只有 $\\mathcal O(S)$ 种取值。 在 $S=\\sqrt m$ 时取得总复杂度最小值 $\\mathcal O(\\sqrt m \\sigma^2 + (n+q) \\sigma)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 100005, C = 26, K = C+1, P = 1000000007;ll m;int n, q, last, cnt, b[N], a[N&lt;&lt;1], fa[N&lt;&lt;1], len[N&lt;&lt;1], l[N][K], r[N][K], ch[N&lt;&lt;1][C], f[N&lt;&lt;1][K];char s[N];struct matrix{ int a[K][K]; inline matrix operator *(const matrix &amp;r)const{ matrix ans; memset(ans.a, 0, sizeof a); for(int i=0; i&lt;K; ++i) for(int k=0; k&lt;K; ++k) for(int j=0; j&lt;K; ++j) ans.a[i][j]=(ans.a[i][j]+(ll)a[i][k]*r.a[k][j])%P; return ans; }} A, B;void extend(int c){ int p=last, np=++cnt; last=cnt, len[np]=len[p]+1; while(p &amp;&amp; !ch[p][c]) ch[p][c]=np, p=fa[p]; if(!p) fa[np]=1; else{ int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else{ int nq=++cnt; len[nq]=len[p]+1, memcpy(ch[nq], ch[q], C&lt;&lt;2); fa[nq]=fa[q], fa[q]=fa[np]=nq; while(ch[p][c]==q) ch[p][c]=nq, p=fa[p]; } }}inline matrix Pow(matrix x, int y){ matrix ans; memset(ans.a, 0, sizeof ans); for(int i=0; i&lt;K; ++i) ans.a[i][i]=1; for(; y; y&gt;&gt;=1, x=x*x) if(y&amp;1) ans=ans*x; return ans;}int main() { last=cnt=1; while(islower(s[++n]=read())) extend(s[n]-'a'); --n; for(int i=1; i&lt;=cnt; ++i) ++b[len[i]]; for(int i=1; i&lt;=n; ++i) b[i]+=b[i-1]; for(int i=1; i&lt;=cnt; ++i) a[b[len[i]]--]=i; for(int i=cnt; i; --i){ int u=a[i]; f[u][C]=1; for(int x=0; x&lt;C; ++x) if(ch[u][x]) for(int j=0; j&lt;=C; ++j) (f[u][j]+=f[ch[u][x]][j])%=P; else ++f[u][x]; } A.a[C][C]=1; for(int i=0; i&lt;C; ++i) if(ch[1][i]) for(int j=0; j&lt;=C; ++j) A.a[j][i]=f[ch[1][i]][j]; B=Pow(A, 100000); l[0][C]=1; for(int i=0; i&lt;=C; ++i) r[0][i]=1; for(int i=1; i&lt;=100000; ++i) for(int j=0; j&lt;K; ++j) for(int k=0; k&lt;K; ++k) l[i][j]=(l[i][j]+(ll)l[i-1][k]*B.a[k][j])%P, r[i][j]=(r[i][j]+(ll)r[i-1][k]*A.a[j][k])%P; read(q); while(q--){ read(m); int x=m/100000, y=m%100000, ans=0; for(int i=0; i&lt;K; ++i) ans=(ans+(ll)l[x][i]*r[y][i])%P; print(ans), print('\\n'); } return flush(), 0;}","link":"/nowcoder-880e/"},{"title":"关于同时求序列的 $0$ 次幂和到 $k$ 次幂和的一些想法","text":"问题应该是个挺简单的问题 对于 $k=0,1,\\dotsc,m$ 求 $$f_k=\\sum_{i=1}^n a_i^k$$ 算法 1考虑答案的生成函数 $$f(x)=\\sum_{i=0}^\\infty f_k x^k$$ 一个数 $a$ 的贡献是 $$\\sum_{i=0}^\\infty a^i x^i\\frac{1}{1-ax}$$ 因此 $f(x)=\\sum_{i=1}^n \\frac{1}{1-a_ix}$ 可以发现 $$\\sum_{i=1}^n \\frac{1}{1-a_ix}\\frac{\\sum_{i=1}^n \\prod_{j\\ne i} (1-a_jx)}{\\prod_{i=1}^n (1-a_i x)}$$ 其中分子的部分可以用分治 NTT 计算，即记录每段的分子分母这两个部分，可以用三次乘法合并 常数比较大 算法 2继续优化上面的算法 令 $$\\begin{align}g(x)&amp;=\\prod_{i=1}^n (1-a_i x) \\h(x)&amp;=\\sum_{i=1}^n \\prod_{j\\ne i} (1-a_jx) \\f(x)&amp;=\\frac{h(x)}{g(x)}\\end{align}$$ 可以发现 $g(x)$ 的 $i$ 次项系数 $|g_i|$ 即从 $a_1,a_2,\\dotsc,a_n$ 中选出 $i$ 个乘积的总和 $|h_i|$ 即枚举删去一个元素 $a_j$ 后选出 $i$ 个乘积的和 一种选出 $i$ 个的方案在 $|g_i|$ 中被恰好计算一次，而在 $|h_i|$ 中被计算 $(n-i)$ 次（只要枚举删掉的那个数不是这 $i$ 个中的都可以） 于是我们有 $h_i=(n-i)g_i$ 只需要分治求出 $g(x)$ 就可以计算 $h(x)$，而这个分治每次只需要一次乘法 考虑形式化这个求 $h(x)$ 的过程 可以发现 $h(x)=g(x)\\times n-(g(x))’x$ 因此 $$\\begin{align}f(x)&amp;=\\frac{h(x)}{g(x)} \\&amp;=\\frac{g(x)\\times n-(g(x))’x}{g(x)} \\&amp;=n-x\\frac{(g(x))’}{g(x)}\\end{align}$$ 这和之后的算法有一定的联系 算法 3沿用上面的符号 由 $\\ln(1-ax)=-\\sum\\limits_{i=1}^\\infty \\frac{a^i}{i}x^i$ $$\\begin{align}\\ln(g(x))&amp;=\\sum_{i=1}^n \\ln(\\frac{1}{1-a_ix}) \\&amp;=\\sum_{i=1}^n \\sum\\limits_{j=1}^\\infty \\frac{a_i^j}{j}x^j \\&amp;=\\sum_{i=1}^\\infty \\sum_{j=1}^n \\frac{a_j^i}{i} x^i\\end{align}$$ 分治求出 $g(x)$ 后求 $\\ln(g(x))$，去掉 $\\frac{1}{i}$ 的系数即可 这其实和算法 2 本质相同 $$\\begin{align}\\ln(g(x))&amp;=\\int \\frac{g’(x)}{g(x)}\\end{align}$$ 对于这个式子求导相当于去掉了 $\\frac{1}{i}$ 的系数，位移回来后补上常数项，和算法 2 完全相同 算法 4这里 有，但是我没看懂，反正式子是一样的","link":"/power-sum/"},{"title":"「SPOJ APS2」Amazing Prime Sequence (hard)","text":"SPOJ APS2 题意令 $f(i)$ 表示 $i$ 的最小质因子 求 $$\\sum_{i=2}^n f(i)$$ $n\\le 1.234567891011*10^{12}$ 做法 对于质数 $p$，有 $f(p)=p$ 对于合数 $x$，有 $f(x)\\le \\sqrt{x}$ 于是单独处理质数部分，然后枚举一个 $\\le \\sqrt{n}$ 的质数，计算贡献 用Min_25筛，求质数的和只需要第一部分即可 复杂度 $\\mathcal O(\\frac{n^{\\frac{3}{4}}}{\\log n})$ 考虑求合数的贡献 一种做法令 $S(a,b)$ 表示 $[2,a]$ 中最小质因子 $\\ge prime_b$ 的数的个数，其中 $prime_b$ 表示第 $b$ 个质数 那么合数的答案就是 $$\\sum_{prime_i\\le \\sqrt{n}} S(\\lfloor \\frac{n}{prime_i} \\rfloor, i) * prime_i$$ 使用Min_25筛暴力求 $S$，可以通过此题 复杂度我不知道 另一种做法令 $S(a,b)$ 表示 $[2,a]$ 中是质数或最小质因子 $\\ge prime_b$ 的数的个数 这可以滚动第二维求，合数的答案是 $$\\sum_{prime_i\\le \\sqrt{n}} \\left( S(\\lfloor \\frac{n}{prime_i} \\rfloor, i) - \\left( i-1 \\right) \\right) * prime_i$$ 要注意去掉质数的数量 在做的过程中计算即可 复杂度 $\\mathcal O(\\frac{n^{\\frac{3}{4}}}{\\log n})$ 跑得没前一种方法快 又学会了另一种做法..事实上这里不需要计算第二部分，由于只和最小质因子相关，第一部分里筛掉的数可以直接计算对答案的贡献 这样就肯定比前两种快了 具体可以看代码 代码在SPOJ上总用时分别为 $31.13s,49.90s,19.83s$ 第一种做法12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long long#define ull unsigned llconst int N = 1111115;int T, id, sn, cnt, prime[N];ll n;ull g[N&lt;&lt;1], a[N&lt;&lt;1], h[N&lt;&lt;1];bool p[N];inline int Id(ll x){ return x&lt;=sn?x:id-n/x+1;}ull S(ll a, int b){ if(a&lt;prime[b]) return 0; ll ans=h[Id(a)]-(b-1); for(int i=b; i&lt;=cnt &amp;&amp; (ll)prime[i]*prime[i]&lt;=a; ++i){ ans+=S(a/prime[i], i+1)+1; for(ll x=(ll)prime[i]*prime[i]; x*prime[i]&lt;=a; x*=prime[i]) ans+=S(a/x, i+1)+1; } return ans;}int main() { scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%lld&quot;, &amp;n), sn=sqrt(n); cnt=id=0; for(ll i=1; i&lt;=n; i=a[id]+1) a[++id]=n/(n/i), g[id]=(a[id]&amp;1?(a[id]+1)/2*a[id]:(ull)a[id]/2*(a[id]+1))-1, h[id]=a[id]-1; for(int i=2; i&lt;=sn; ++i) if(h[i]!=h[i-1]){ prime[++cnt]=i; ull lim=(ull)i*i; for(int j=id, t; a[j]&gt;=lim; --j) g[j]-=i*(g[t=Id(a[j]/i)]-g[i-1]), h[j]-=h[t]-h[i-1]; } ull ans=g[id]; for(int i=1; i&lt;=cnt; ++i) ans+=S(n/prime[i], i)*prime[i]; printf(&quot;%llu\\n&quot;, ans); } return 0;} 第二种做法12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long long#define ull unsigned llconst int N = 1111115;int T, id, sn, cnt, prime[N];ll n, a[N&lt;&lt;1];ull g[N&lt;&lt;1], h[N&lt;&lt;1], S[N&lt;&lt;1];bool p[N];inline int Id(ll x){ return x&lt;=sn?x:id-n/x+1;}int main() { scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%lld&quot;, &amp;n), sn=sqrt(n); cnt=id=0; for(ll i=1; i&lt;=n; i=a[id]+1) a[++id]=n/(n/i), g[id]=(a[id]&amp;1?(a[id]+1)/2*a[id]:(ull)a[id]/2*(a[id]+1))-1, h[id]=a[id]-1; for(int i=2; i&lt;=sn; ++i) if(h[i]!=h[i-1]){ prime[++cnt]=i; ll lim=(ll)i*i; for(int j=id, t; a[j]&gt;=lim; --j) g[j]-=i*(g[t=Id(a[j]/i)]-g[i-1]), h[j]-=h[t]-h[i-1]; } ull ans=g[id]; for(int i=1; i&lt;=id; ++i) S[i]=h[i]; for(int i=cnt; i; --i){ for(int j=id; (ll)prime[i]*prime[i]&lt;=a[j]; --j) for(ll x=prime[i]; x*prime[i]&lt;=a[j]; x*=prime[i]) S[j]+=S[Id(a[j]/x)]-i+1; ans+=(S[Id(n/prime[i])]-i+1)*prime[i]; } printf(&quot;%llu\\n&quot;, ans); } return 0;} 第三种代码123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long long#define ull unsigned llconst int N = 1111115;int T, id, sn, cnt, prime[N];ll n, a[N&lt;&lt;1];ull g[N&lt;&lt;1], h[N&lt;&lt;1];bool p[N];inline int Id(ll x){ return x&lt;=sn?x:id-n/x+1;}int main() { scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%lld&quot;, &amp;n), sn=sqrt(n); cnt=id=0; for(ll i=1; i&lt;=n; i=a[id]+1) a[++id]=n/(n/i), g[id]=(a[id]&amp;1?(a[id]+1)/2*a[id]:(ull)a[id]/2*(a[id]+1))-1, h[id]=a[id]-1; ull ans=0; for(int i=2; i&lt;=sn; ++i) if(h[i]!=h[i-1]){ prime[++cnt]=i; ll lim=(ll)i*i; for(int j=id, t; a[j]&gt;=lim; --j){ g[j]-=i*(g[t=Id(a[j]/i)]-g[i-1]), h[j]-=h[t]-h[i-1]; if(j==id) ans+=(h[t]-h[i-1])*i; } } printf(&quot;%llu\\n&quot;, ans+g[id]); } return 0;}","link":"/spoj-aps2/"},{"title":"「SPOJ DIVCNT2」Counting Divisors (square)","text":"题意令 $\\sigma_0(n)$ 表示 $n$ 的约数个数 求 $$\\sum_{i=1}^n \\sigma_0(i^2)$$ $n\\le 10^{12}$ 做法Min_25筛板子题 丢链接跑 复杂度 $O(\\frac{n^{\\frac{3}{4}}}{\\log n})$ 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;math.h&gt;using namespace std;#define ll long longconst int N = 1000005;int T, sn, id, cnt, prime[N];ll n, g[N&lt;&lt;1], a[N&lt;&lt;1];inline int Id(ll x){ return x&lt;=sn?x:id-(n/x)+1;}ll S(ll a, int b){ if(a&lt;prime[b]) return 0; ll ans=g[Id(a)]-(b-1)*3; for(int i=b, lim=sqrt(a); i&lt;=cnt &amp;&amp; prime[i]&lt;=lim; ++i){ ans+=S(a/prime[i], i+1)*3+5; for(ll x=(ll)prime[i]*prime[i], j=5; x*prime[i]&lt;=a; x*=prime[i], j+=2) ans+=S(a/x, i+1)*j+j+2; } return ans;}int main() { scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%lld&quot;, &amp;n), sn=sqrt(n); cnt=id=0; for(ll i=1; i&lt;=n; i=a[id]+1) a[++id]=n/(n/i), g[id]=(a[id]-1)*3; for(int i=2; i&lt;=sn; ++i) if(g[i]!=g[i-1]){ prime[++cnt]=i; ll lim=(ll)i*i; for(int j=id; a[j]&gt;=lim; --j) g[j]-=g[Id(a[j]/i)]-(cnt-1)*3; } printf(&quot;%lld\\n&quot;, S(n, 1)+1); } return 0;}","link":"/spoj-divcnt2/"},{"title":"「SPOJ DIVCNT3」Counting Divisors (cube)","text":"题意令 $\\sigma_0(n)$ 表示 $n$ 的约数个数 求 $$\\sum_{i=1}^n \\sigma_0(i^3)$$ $n\\le 10^{11}$ 做法Min_25筛板子题 丢链接跑 复杂度 $O(\\frac{n^{\\frac{3}{4}}}{\\log n})$ 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;math.h&gt;using namespace std;#define ll long longconst int N = 316250;int T, sn, id, cnt, prime[N];ll n, g[N&lt;&lt;1], a[N&lt;&lt;1];inline int Id(ll x){ return x&lt;=sn?x:id-(n/x)+1;}ll S(ll a, int b){ if(a&lt;prime[b]) return 0; ll ans=g[Id(a)]-(b-1)*4; for(int i=b, lim=sqrt(a); i&lt;=cnt &amp;&amp; prime[i]&lt;=lim; ++i){ ans+=S(a/prime[i], i+1)*4+7; for(ll x=(ll)prime[i]*prime[i], j=7; x*prime[i]&lt;=a; x*=prime[i], j+=3) ans+=S(a/x, i+1)*j+j+3; } return ans;}int main() { scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%lld&quot;, &amp;n), sn=sqrt(n); cnt=id=0; for(ll i=1; i&lt;=n; i=a[id]+1) a[++id]=n/(n/i), g[id]=(a[id]-1)*4; for(int i=2; i&lt;=sn; ++i) if(g[i]!=g[i-1]){ prime[++cnt]=i; ll lim=(ll)i*i; for(int j=id; a[j]&gt;=lim; --j) g[j]-=g[Id(a[j]/i)]-(cnt-1)*4; } printf(&quot;%lld\\n&quot;, S(n, 1)+1); } return 0;}","link":"/spoj-divcnt3/"},{"title":"「SPOJ QTREE」Query on a tree","text":"SPOJ QTREE 题意你有一棵$n$个点的树，边有权，有两种操作 CHANGE x y，表示修改第$x$条边的边权为$y$ QUERY x y，表示询问点$x$到$y$路径上的边权最大值 感想娱乐？ 树剖套线段树$\\mathcal O(n\\log^2n)$ 好久没写这种dfn序线段树了，写了才发现代码有点长.. 不会静态LCT的小常数$\\mathcal O(n\\log n)$做法 被多组数据坑了一发.. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) { if (c == '-') iosig = true; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x + (x &lt;&lt; 2)) &lt;&lt; 1) + (c ^ '0'); if (iosig) x = -x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh = obuf;inline void print(char c) { if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf; *ooh++ = c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x == 0) print('0'); else { if (x &lt; 0) print('-'), x = -x; for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48; while (cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 100005;int n, num, T, cnt, wfa[N], idfn[N], dfn[N], id[N], fa[N], top[N], siz[N], dep[N], h[N], pre[N&lt;&lt;1], e[N&lt;&lt;1], w[N&lt;&lt;1], mx[N&lt;&lt;2];inline void add(int x, int y, int z){ e[++num]=y, w[num]=z, pre[num]=h[x], h[x]=num;}void dfs1(int u){ siz[u]=1; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa[u]) id[i&gt;&gt;1]=e[i], fa[e[i]]=u, wfa[e[i]]=w[i], dep[e[i]]=dep[u]+1, dfs1(e[i]), siz[u]+=siz[e[i]];}void dfs2(int u){ dfn[u]=++cnt; int son=0; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa[u] &amp;&amp; siz[e[i]]&gt;siz[son]) son=e[i]; if(son) top[son]=top[u], dfs2(son); for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa[u] &amp;&amp; e[i]!=son) top[e[i]]=e[i], dfs2(e[i]);}void build(int l, int r, int t){ if(l==r) return (void)(mx[t]=wfa[idfn[l]]); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; build(l, mid, k), build(mid+1, r, k|1); mx[t]=max(mx[k], mx[k|1]);}void modify(int l, int r, int t, int x, int y){ if(l==r) return (void)(mx[t]=y); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; if(x&lt;=mid) modify(l, mid, k, x, y); else modify(mid+1, r, k|1, x, y); mx[t]=max(mx[k], mx[k|1]);}int query(int l, int r, int t, int L, int R){ if(L&gt;R) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return mx[t]; int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; return max(L&lt;=mid?query(l, mid, k, L, R):0, R&gt;mid?query(mid+1, r, k|1, L, R):0);}int main() { read(T); while(T--){ num=1, cnt=0, memset(h, 0, sizeof h); read(n); for(int i=1; i&lt;n; ++i){ static int x, y, z; read(x), read(y), read(z); add(x, y, z), add(y, x, z); } dfs1(1), top[1]=1, dfs2(1); for(int i=1; i&lt;=n; ++i) idfn[dfn[i]]=i; build(1, n, 1); while(1){ char opt; int x, y; while(isspace(opt=read())); if(opt=='D') break; else read(x), read(y); if(opt=='Q'){ int ans=0; while(top[x]!=top[y]) if(dep[top[x]]&lt;dep[top[y]]) ans=max(ans, query(1, n, 1, dfn[top[y]], dfn[y])), y=fa[top[y]]; else ans=max(ans, query(1, n, 1, dfn[top[x]], dfn[x])), x=fa[top[x]]; print(max(ans, query(1, n, 1, min(dfn[x], dfn[y])+1, max(dfn[x], dfn[y])))), print('\\n'); } else if(opt=='C') modify(1, n, 1, dfn[id[x]], y); } } return flush(), 0;}","link":"/spoj-qtree/"},{"title":"THUPC2019 &#x2F; CTS2019 &#x2F; APIO2019 游记","text":"旅游 5.12早上 1:49 就醒了，发现左臂被压死了，慌了一会儿后发现并没有死，就继续睡了 4 点多又醒了，就没睡着，后来 zx 开始鏼题了，就更睡不着了，躺到快 6 点就起了 地铁买票耽搁了二十多分钟，导致后面就很赶 从圆明园站出来距离 9 点比赛开始大概还有近半个小时 从一个门走进清华大学之后要走好久好久 = = 到比赛场地是 8:59，但是比赛鸽了，所以领了下各种东西等比赛开始 推迟了半个小时 好多队都提前看题 = = 开场我先写了个 M，然后 fyl 和 cwy 干了个 D，挂了 1 发，原来是多测以文件结束为标志 = = 然后我写了个 B，挂了 2 发 = = cwy 和 fyl 干了 C，第一发排序有个地方 X 和 Y 打成了 x 和 y，第二发发现没预处理复杂度是错的 = = 然后在 fyl 指导下写了 J 这个时候是 rank 2，rank 1 是 zx 的队，只有两个 5 题队，虽然罚时爆炸但是十分膨胀 zx 过了 L，还没过 J，但是直到他们过了 I,J 我们队还是保持 5 题 = = I 题 cwy 读入看错了爆了 2 发，调了很久，还是在我们反复卡 L 的常数的时候调出来的，还有 L 这种题可能不应该让 fyl 写 = = 讲一下卡 L 的历程，先把 set 改成数组状物，然后改基排，基排姿势其实很不对 = = 所以还是过不了，最后加了读优再把基排姿势改对了才过 在 3h 的时候成为了 7 题，之前 5 题的时候 cwy 说能有 7 题不错了 然后 nb 的 fyl 会了 K，搞出来一个矩阵套 FWT 的东西，搞了其实也不是很久就 1A 了 orz 等评测 100 多个点等了挺久的 = = 然后就要写 H 鸭棋 了，一直写写写写完调了一会儿样例交上去就 1A 了 = = 干不出 F，最后一起搞 G 也失败了 鸽了后续的活动，后来知道还有 rank 7，还有奖金拿 体验还是非常棒的 不打算复习了 5.13CTS Day1 自闭了 看心情更 来更了 暴力都不会，30+36+50 滚粗了 听说提答直接写暴力就 60+，我这种手玩前 4 个点然后后面乱写的选手就菜得真实 = = 5.14CTS Day2 自闭了，主要是因为旁边极高素质的小哥，不想回忆了 = = 还是暴力都不会，30+60+0 滚粗了 还好还会写凸包，还好 B 题假算法没挂 = = 调不出来本地拍一段时间是能挂的但是数据比较水 但是两场都没 fst 对吧 感觉要打铁了 5.15答辩鸽掉了，参观鸽掉了，晚上去看颁奖 得知 zzy 被挤掉了 还有我这样就刚好卡线 Au 了 = = 5.16没事干的一天，把 APIO 练习赛的六道题都贺了一遍 5.17培训鸽了 5.18早上泡了酒店的咖啡好像还有点效果 前几天颓太凶身体吃不消了 前几天一直觉得 APIO 体验会还可以 可能是因为赛制 先看了 bridges 感觉不太可做就先扔了（好像左边小哥一直在刚） 然后看 device 看错题了以为第一个计数器是每 B 秒增加 1 然后写了个差分线段并爆了几发才发现看错题了 = = 看清楚之后感觉这个东西的循环肯定是一个简单环然后手解了个关系就过了，还没到半小时 = = 然后看 lamps 一开始也不太会，然后去往矩形修改及统计单点历史总和想，写了个 cdq 就过了，还没到 80 min，第一发忘了去掉 cdq 里面的 assert() 树状数组的每个位置就 T 飞了 = = 然后开始想两点考完你会不会已经去上课了所以如果能干掉这个 bridges 想必是极好的 这个数据范围感觉很根号 = = 中间也绝望过好几次，树的不带根号做法都搞不出来，可能重心是放在树的部分了，如果写出来就有 273pts 了想必也还可以 后来就在凑对什么按照什么顺序分块 = = 后来就凑出来对询问按时间分块好像可以做，然后写了个再调了一会正确性就没问题了 但是跑不过没有修改和最后一个 subtask 于是本地造了一组没有修改的数据，直接确定地调块大小，由于爆 OJ 比较爽就一直爆，OJ 应该比本地慢一些，本地 1.6s- （确信）在上面挂了 调到 1000 的时候过了，但是挂了一个树的点，由于是每个 subtask 取最高分，已经有 273pts 了感觉稳了 = = 然后发现最后一个 subtask 挂了一个更早的点，于是毛估估调了根号询问数的 2.5 倍就过了全部点 = = 有点激动，问了下打雀的工作人员 lca 说可以提前离场，然后就理了东西跑路了，大概没到 3.5h 还和有些同学对视了几眼 = = 所以不用担心两点太晚了喔 坐在外面还被王宏瞪了 = = 但是很怕看错分数然后已经不能补救了 = = 5.19培训鸽了 由于一些同分，正式选手去参评的人数多了几个 = = 还以为没并列的都是 AK 了.. 晚上去外面玩差点回不来了 到酒店是 0:40 之后 = = 5.20滚回学校了","link":"/thupc-cts-apio-2019/"},{"title":"Topcoder SRM 752 Div2 fst记","text":"垃圾 TC 毁我青春 第一次打 Topcoder 最后几分钟装完环境 之前打了个某「浙大计算机考研机试模拟赛 树专题」，一题二叉树没说保证数据随机，$10^5$ 范围 $\\mathcal O(n^2)$ 暴力超快，一题线性的放了 $n=30$，还有高精度大便题，被恶心到了， 250pts 搞搞就过了，编译上搞了好久= = 500pts 搞搞就过了= = 1000pts 搞搞就 fst 了，评测的 class 开在堆里，垃圾值没清空，调了一天= = 在寝室等了好久的 fst，真是爽= =","link":"/topcoder-srm-752/"},{"title":"Ubuntu 18.04 下养生","text":"本文定期不更新 故事要 WC 了，不用 Linux 会爆零的 先装了 Ubuntu 18.04 LTS ，然后被下面这个 DNS 的问题搞得心力交瘁，好久之后就放弃了 卸了装 16.04 LTS ，没有这个问题 再升 18.04 ，还是有这个问题，但是解决了 网络连接不稳定我使用的是有线连接，但是几秒挂一次 发现不能 ping baidu.com，但是可以直接 ping ip 于是在 /etc/resolv.conf 内加入一行 nameserver 8.8.8.8 就好了 使用 sudo vim /etc/resolv.conf 编辑，但是这样重启或者重启网络服务之后就又被覆盖了，文件中也有注释 执行 sudo vim /etc/resolvconf/resolv.conf.d/tail 新建一个文件 写入 nameserver 8.8.8.8 就好了 参考这里 update留着一个奇怪的 nameserver 会有问题. 才想到，所以可以编辑 /etc/network/interfaces 加上一行 dns-nameservers 8.8.8.8，好像就真的好了 参考这里 无法打开Wi-Fi好像是联想一部分电脑的常见问题 方法仅供参考，原理我也不知道 运行 rfkill list all 我本机显示 1234567891011120: ideapad_wlan: Wireless LAN Soft blocked: no Hard blocked: yes1: ideapad_bluetooth: Bluetooth Soft blocked: yes Hard blocked: yes3: phy0: Wireless LAN Soft blocked: no Hard blocked: no4: hci0: Bluetooth Soft blocked: yes Hard blocked: no 其中这个 0： Wireless LAN 的 Hard blocked: yes 肯定有问题. 运行 sudo modprobe -r ideapad_laptop 去掉，就可以使用 3: Wireless LAN 了 但是重启之后也会挂 执行 sudo touch /etc/modprobe.d/ideapad.conf 执行 sudo vim /etc/modprobe.d/ideapad.conf 添加 blacklist ideapad_laptop 好了 参考这里 更改主题sudo apt install gnome-tweak-tool 安装 gnome-tweak Arc 这个主题还可以 可以通过 sudo apt install arc-theme 安装，之后在 gnome-tweak 里面更换 图片以后可能会贴 更改 Shell需要安装这个插件 User Themes - GNOME Shell Extensions 我的 Chromium 不能安装插件，只能切到 Firefox 去 安装完就可以在 tweak 里更改了 更改图标可以用 papirus-icon-theme 123sudo add-apt-repository ppa:papirus/papirussudo apt-get updatesudo apt-get install papirus-icon-theme 就可以切换了 设置透明终端Ctrl+Alt+T 打开终端，右键打开 Preferences，在 Colors 内选择透明就好了 设置桌面背景和锁屏背景把图片放到 Pictures 文件夹里然后去 Settings &gt; Background 里面改 搜狗输入法 去官网下个安装包 安装完之后在系统的 Settings &gt; Region &amp; Language &gt; Manage installed languages 里面更改 Keyboard input method system 为 fcitx 在右上角的输入法处点开 Configure Current Input Method，里面的第一项需要是 Keyboard 或者 Keyboard - XXX，然后在下面添加搜狗拼音，如果没有的话点击加号，去掉 Only Show Current Language 的勾，会有 Sogou Pinyin AtomUbuntu 下还是用 Atom 去 atom.io 或者 GitHub 里面下载 安装完就好了 注意 Ubuntu Software 中也有 Atom 但是不能使用搜狗输入法，可以卸了重装 网易云音乐一从官网下一个 .deb 包，目前是 v1.1.0 的， 直接安装就好了 但是发现并打不开 二sudo netease-cloud-music 发现可以打开，但是有一个终端很不爽 三Step 1直接运行 sudo visudo 来编辑 /etc/sudoers 文件 加一句 YOURNAME ALL = NOPASSWD: /usr/bin/netease-cloud-music，其中 YOURNAME 是用户名 Step 2运行 sudo vim /usr/share/applications/netease-cloud-music.desktop 来修改快捷方式 修改里面的 Exec=netease-cloud-music %U 为 Exec=sudo netease-cloud-music %U 参考这里 四无法在任务栏显示图标，并且 最小化到系统托盘 之后就找不到了. 我也没办法，那就不要 最小化到系统托盘，关闭时直接关闭，平时就挂在任务栏里 Shadowsocks学术研究需要 客户端打开 GitHub Shadowsocks-Qt5，这是可以正常访问的 下一个 .AppImage 的文件，在属性中改为可执行 打开后自行导入 浏览器代理Firefox 调不好，但是装个 Chromium 可以调好 运行 chromium --proxy-server=&quot;socks5://127.0.0.1:1080&quot;，也可以改端口之类的 全局 PAC依次执行 apt-get install python-pip sudo pip install genpac pip install --upgrade genpac genpac --pac-proxy &quot;SOCKS5 127.0.0.1:1080&quot; --gfwlist-proxy=&quot;SOCKS5 127.0.0.1:1080&quot; --gfwlist-url=https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt --output=&quot;autoproxy.pac&quot; 然后在 Settings &gt; Network &gt; Network Proxy 里选择 Method 为 Automatic，设置 Configuration URL 为 autoproxy.pac 文件的路径 格式如 file:///home/{user}/autoproxy.pac 参考这里 杂项 解压 .tar.xz 文件 tar xf xxx.tar.xz 显示隐藏文件 ls -a 或者 Ctrl + H","link":"/ubuntu-18-04/"},{"title":"从移动硬盘启动 Ubuntu 18.04 和一些设置","text":"又是一年 WC 前，想重装一个 Ubuntu，但是又不想装双系统（启动慢而且不爽），恰好多了个移动硬盘，就想装上面，这样甚至可以插别的电脑上启动。 集训队作业还没动 让我们开始吧！ 安装过程大概是因为没有挂载 /boot，导致 Ubuntu 不能脱离本机引导。后来的解决方法是，用 DiskGenuis 转换为 GUID 分区类型，新建 EFI 分区，再使用下面的 Boot Repair 进行修复，虽然提示失败了，但是达到了预期效果。 以下为原过程 制作一个 USB 启动盘，事先用 DiskGenius 在移动硬盘上分好区，避免 4k 不对齐的问题，个人的配置如下（几个分区从整个盘的起始位置开始），仅供参考。 Mount Point File system Size Type / Ext4 25GB Primary swap swap area 8GB Logical /home Ext4 67GB Logical 安装引导程序的位置我选择了移动硬盘。 安装完后插着硬盘就可以愉快地用 Grub 启动了。 接下来我们要 Ubuntu 能独立启动， 12sudo add-apt-repository ppa:yannubuntu/boot-repair &amp;&amp; sudo apt-get updatesudo apt install -y boot-repair &amp;&amp; boot-repair 使用推荐修复，然后它 GG 了。 Basic SettingsAny step below is possibly not necessary. Install Vimsudo apt install vim Temporarily change DNS nameserversudo vim /etc/resolv.conf Change nameserver 127.0.0.53 to nameserver 8.8.8.8. However, the file will be overwritten after reboot. Install Google PinyinSearch fcitx in Ubuntu Software and install 3 applications with fcitx logo. Then sudo apt install fcitx-googlepinyin. Reboot and we can use Google Pinyin. 关闭 sudo 的密码sudo visudo，修改 %sudo ALL=(ALL:ALL) ALL 为 %sudo ALL=(ALL:ALL) NOPASSWD:ALL. systemctl restart systemd-resolved.service 解决 DNS 的问题上述更改 /etc/resolv.conf 的方法是暂时的，重启会失效。 据说更改 /etc/systemd/resolved.conf 就可以解决问题。但是我这里并没有效果。/etc/resolv.conf 是符号链接文件，我们把它删了，自己再新建一个。直接新建一个文件会被 NetworkManager 重新覆盖，因此我们建一个符号链接就好了（我真是极致聪明）。 12mv /etc/resolv.conf /etc/resolv.conf.trueln -s /etc/resolv.conf.true /etc/resolv.conf 这样其中的内容就不会被更改了。 AdvancedShadowsocks下载 Shadowsocks-Qt5，自动连接不是很人性化，开机启动可以在 Startup Applications Preferences 里设置，直接在菜单里搜索即可。接下来配置系统代理： 1234sudo apt-get install python-pipsudo pip install genpacpip install --upgrade genpacgenpac --pac-proxy &quot;SOCKS5 127.0.0.1:1080&quot; --gfwlist-proxy=&quot;SOCKS5 127.0.0.1:1080&quot; --gfwlist-url=https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt --output=&quot;autoproxy.pac&quot; 其中 1080 自行调节。然后在 Settings &gt; Network &gt; Network Proxy 里选择 Method 为 Automatic，设置 Configuration URL 为 autoproxy.pac 文件的路径，格式如 file:///home/{user}/autoproxy.pac。 重启 Firefox 即可。 Firefox 默认缩放地址栏输入 about:config，把 layout.css.devPixelsPerPx 改为 1.25。 一些 Windows 下我习惯了的快捷键Settings &gt; Devices &gt; Keyboard Open Home Folder: nautilus (Super+E) Screen Shot: gnome-screenshot -a -c (Ctrl+Alt+A) 自定义在当前文件夹打开终端的快捷键参考这里 TweaksGNOME Tweakssudo apt install gnome-tweak-tool，里面有一些基本的设置，包括壁纸、缩放比例、最小化等按钮的位置、时间显示方式等。 主题我使用 arc-theme。 sudo apt install arc-theme，可以在 Tweaks 里切换。 Firefox 有对应的主题 Arc Dark Theme 等。 图标我使用 papirus-icon-theme。 sudo apt-get install papirus-icon-theme，可以在 Tweaks 里切换。 Shell先 sudo apt install chrome-gnome-shell 开启 Shell 的功能。 User Theme，安装后可以更改 Shell 的主题。 Open Weather，在 Shell 加个天气。 Alternate Tab，快捷键切换窗口的时候不会将同类窗口合并在一组。 Clipboard Indicator，提供一个剪切板历史记录。 Dynamic Top Bar，在没有全屏窗口时 Shell 透明化 Pixel Saver，在 Shell 显示窗口的顶栏。 Unblank screen saver，锁屏后保持屏幕开启（另一种方法是长按 Super+L）。 登录界面的背景修改 /usr/share/gnome-shell/ubuntu.css 文件中的内容，推荐先备份。 把 123#lockDialogGroup { background: #2c001e url(resource:///org/gnome/shell/theme/noise-texture.png); background-repeat: repeat; } 修改为 12345#lockDialogGroup { background: #2c001e url(file:///home/cekavis/Pictures/Wallpapers/02.png); background-repeat: no-repeat; background-size: cover; background-position: center; } 文件的路径是 /home/cekavis/Pictures/Wallpapers/02.png，自行配置。 重启后生效。","link":"/ubuntu-on-external-hard-drive/"},{"title":"「UOJ 299」「CTSC2017」游戏","text":"UOJ #299 题意小 R 和小 B 玩了 $n$ 局游戏，第一局小 R 获胜的概率是 $p_1$，对于第 $i(1&lt;i\\le n)$ 局，若第 $i-1$ 局小 R 获胜，则小 R 获胜的概率为 $p_i$，否则为 $q_i$ 现在已经知道了若干局的胜负情况，求小 R 获胜次数的期望，在 $m$ 次增加或删除已知条件后都输出答案 $n,m\\le 2\\times 10^5$ 后面的游戏结果会影响前面的概率 = = 做法钦定第 $0$ 局小 R 获胜，第 $n+1$ 局小 B 获胜 设第 $i$ 局的结果为 $x_i$：若 $x_i=1$ 则表示小 R 获胜，若 $x_i=0$ 则表示小 B 获胜 考虑在确定了一些位置的情况下求第 $k$ 个位置的概率 这只和 $k$ 两侧最近的确定的位置有关 形式化地，找到最大的 $l(l&lt;k)$ 和最小的 $r(r\\ge k)$，即 $P(x_k=1|x_l,x_r)$ 而 $$\\begin{aligned}P(x_k=1|x_l,x_r) = &amp; \\frac{P(x_k=1,x_l,x_r)}{P(x_l,x_r)} \\= &amp; \\frac{P(x_k=1,x_r|x_l)\\times P(x_l)}{P(x_r|x_l)\\times P(x_l)} \\= &amp; \\frac{P(x_k=1,x_r|x_l)}{P(x_r|x_l)}\\end{aligned}$$ 分母即确定了 $l$ 处的值 $x_l$ 后，$r$ 处的值为当前 $x_r$ 的概率，可以简单求得 分子部分即在上述条件中钦定 $x_k=1$ 后的概率 现在只有 $x_l$ 的条件，于是可以递推 注意在有中间钦定的情况下，小 R 和小 B 获胜的概率之和不一定为 $1$ 记 $i$ 处小 R 获胜概率为 $f_i$，小 B 为 $g_i$ 用矩阵转移即 $$(f_{i-1},g_{i-1})\\begin{bmatrix}p_i &amp; 1-p_i \\q_i &amp; 1-q_i\\end{bmatrix}(f_i, g_i)$$ 若在 $k$ 处，由于钦定了 $x_k=1$ 矩阵变成 $$\\begin{bmatrix}p_i &amp; 0 \\q_i &amp; 0\\end{bmatrix}$$ 现在对于相邻两个的确定位置 $l,r$，计算 $(l,r]$ 这一段的答案，可以分治地维护一个区间的矩阵的积和钦定其中某个位置为 $1$ 的所有方案 每次修改会改变三个区间 复杂度 $\\mathcal O(n+m\\log n)$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 200005;int n, m;bool f[N];double ans, p[N], q[N];set&lt;int&gt; g;struct xxx{ struct matrix{ double a[2][2]; inline matrix operator +(const matrix &amp;rhs)const{ matrix ans; for(int i=0; i&lt;2; ++i) for(int j=0; j&lt;2; ++j) ans.a[i][j]=a[i][j]+rhs.a[i][j]; return ans; } inline matrix operator *(const matrix &amp;rhs)const{ matrix ans; ans.a[0][0]=a[0][0]*rhs.a[0][0]+a[0][1]*rhs.a[1][0]; ans.a[0][1]=a[0][0]*rhs.a[0][1]+a[0][1]*rhs.a[1][1]; ans.a[1][0]=a[1][0]*rhs.a[0][0]+a[1][1]*rhs.a[1][0]; ans.a[1][1]=a[1][0]*rhs.a[0][1]+a[1][1]*rhs.a[1][1]; return ans; } } a, b; inline xxx operator *(const xxx &amp;rhs)const{ xxx ans; return ans.a=a*rhs.a, ans.b=a*rhs.b+b*rhs.a, ans; }} s[N&lt;&lt;2];void build(int l, int r, int t){ if(l==r){ s[t].a.a[0][0]=p[l], s[t].a.a[0][1]=1-p[l]; s[t].a.a[1][0]=q[l], s[t].a.a[1][1]=1-q[l]; s[t].b.a[0][0]=p[l], s[t].b.a[1][0]=q[l]; return; } int mid=(l+r)&gt;&gt;1, k=t&lt;&lt;1; build(l, mid, k), build(mid+1, r, k|1), s[t]=s[k]*s[k|1];}xxx query(int l, int r, int t, int L, int R){ if(L&lt;=l &amp;&amp; r&lt;=R) return s[t]; int mid=(l+r)&gt;&gt;1, k=t&lt;&lt;1; if(R&lt;=mid) return query(l, mid, k, L, R); if(L&gt;mid) return query(mid+1, r, k|1, L, R); return query(l, mid, k, L, R)*query(mid+1, r, k|1, L, R);}double solve(int l, int r){ xxx a=query(1, n+1, 1, l+1, r); return a.b.a[f[l]^1][f[r]^1]/a.a.a[f[l]^1][f[r]^1];}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); while(isspace(getchar())); scanf(&quot;%lf&quot;, p+1); for(int i=2; i&lt;=n; ++i) scanf(&quot;%lf%lf&quot;, p+i, q+i); build(1, n+1, 1), f[0]=1, g.insert(0), g.insert(n+1), ans=solve(0, n+1); while(m--){ int x, y, l, r; while(isspace(getchar())); if((getchar(), getchar())=='d'){ scanf(&quot;%d%d&quot;, &amp;x, &amp;y), f[x]=y; auto it=g.upper_bound(x); r=*it, l=*--it, g.insert(x); ans+=solve(l, x)+solve(x, r)-solve(l, r); } else{ scanf(&quot;%d&quot;, &amp;x); auto it=g.find(x); g.erase(it++), r=*it, l=*--it; ans+=solve(l, r)-solve(l, x)-solve(x, r); } printf(&quot;%.6lf\\n&quot;, ans); } return 0;}","link":"/uoj-299/"},{"title":"「UOJ 269」「清华集训2016」如何优雅地求和","text":"UOJ #269 题意给定 $m$ 次函数 $f$ 和 $n,a$，求 $$\\sum_{k = 0}^{n}f(k)\\binom{n}{k}a^k(1 - a) ^{n - k}$$ 模 $998244353$ 函数给出 $0,1,\\dotsc,m$ 处的点值 $1\\le n\\le 10^9,1\\le m\\le 2\\times 10^4$ 做法把 $f$ 表示成下降幂的系数形式，令 $f(x)=\\sum\\limits_{i=0}^m f_i x^{\\underline i}$ 考虑一个下降幂 $x^{\\underline t}$ 的答案 $$\\begin{align}&amp; \\sum_{k = 0}^{n} k^{\\underline t} \\binom{n}{k} a^k(1 - a) ^{n - k} \\= &amp; \\sum_{k=t}^n k^{\\underline t} \\binom{n-t}{k-t} \\frac{n^{\\underline t}}{k^{\\underline t}} a^k(1 - a) ^{n - k} \\= &amp; n^{\\underline t} \\sum_{k=t}^n \\binom{n-t}{k-t} a^k (1-a)^{n-k} \\= &amp; n^{\\underline t} \\sum_{k=0}^{n-t} \\binom{n-t}{k} a^{k+t} (1-a)^{n-k-t} \\= &amp; n^{\\underline t} a^t \\sum_{k=0}^{n-t} \\binom{n-t}{k} a^k (1-a)^{n-k-t} \\= &amp; n^{\\underline t} a^t\\end{align}$$ 于是我们只要知道每个系数 $f_i$ 就可以轻易地计算答案 考虑一个下降幂 $x^{\\underline t}$ 对 $i$ 处点值的影响 $i^{\\underline t}=\\frac{i!}{(i-t)!}$，写成生成函数的形式 $$\\begin{align}&amp; \\sum_{n=0}^\\infty \\frac{f(n)}{n!}x^n \\= &amp; \\sum_{i=0}^m f_i \\sum_{n=i}^\\infty \\frac{x^n}{(n-i)!} \\= &amp; \\sum_{i=0}^m f_i x^i \\sum_{n=0}^\\infty \\frac{x^n}{n!} \\= &amp; \\left( \\sum_{i=0}^m f_i x^i \\right) e^x\\end{align}$$ 于是只需要求出 $\\sum\\limits_{n=0}^m \\frac{f(n)}{n!} x^n$ 和 $e^{-x}$ 的卷积就好了 复杂度 $\\mathcal O(m\\log m)$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ull unsigned long longconst unsigned N = 1&lt;&lt;16, P = 998244353;struct Z{ unsigned x; Z(const unsigned _x=0):x(_x){} inline Z operator +(const Z &amp;rhs)const{ return x+rhs.x&lt;P?x+rhs.x:x+rhs.x-P;} inline Z operator -(const Z &amp;rhs)const{ return x&lt;rhs.x?x-rhs.x+P:x-rhs.x;} inline Z operator -()const{ return x?P-x:0;} inline Z operator *(const Z &amp;rhs)const{ return static_cast&lt;ull&gt;(x)*rhs.x%P;} inline Z operator +=(const Z &amp;rhs){ return x=x+rhs.x&lt;P?x+rhs.x:x+rhs.x-P, *this;} inline Z operator -=(const Z &amp;rhs){ return x=x&lt;rhs.x?x-rhs.x+P:x-rhs.x, *this;} inline Z operator *=(const Z &amp;rhs){ return x=static_cast&lt;ull&gt;(x)*rhs.x%P, *this;}};int n, m, x;vector&lt;Z&gt; a, b;Z ans, w[N];inline Z Pow(Z x, int y=P-2){ Z ans=1; for(; y; y&gt;&gt;=1, x=x*x) if(y&amp;1) ans=ans*x; return ans;}inline void Init(int N){ for(int i=1; i&lt;N; i&lt;&lt;=1){ w[i]=1; Z t=Pow(3, (P-1)/i/2); for(int j=1; j&lt;i; ++j) w[i+j]=w[i+j-1]*t; }}inline int Get(int x){ int n=1; while(n&lt;=x) n&lt;&lt;=1; return n;}inline void DFT(vector&lt;Z&gt; &amp;f, int n){ static ull F[N]; if((int)f.size()!=n) f.resize(n); for(int i=0, j=0; i&lt;n; ++i){ F[i]=f[j].x; for(int k=n&gt;&gt;1; (j^=k)&lt;k; k&gt;&gt;=1); } for(int i=1; i&lt;n; i&lt;&lt;=1) for(int j=0; j&lt;n; j+=i&lt;&lt;1){ Z *W=w+i; ull *F0=F+j, *F1=F+j+i; for(int k=j; k&lt;j+i; ++k, ++W, ++F0, ++F1){ ull t=(*F1)*(W-&gt;x)%P; (*F1)=*F0+P-t, (*F0)+=t; } } for(int i=0; i&lt;n; ++i) f[i]=F[i]%P;}inline void IDFT(vector&lt;Z&gt; &amp;f, int n){ f.resize(n), reverse(f.begin()+1, f.end()); DFT(f, n); Z I=Pow(n); for(int i=0; i&lt;n; ++i) f[i]=f[i]*I;}inline vector&lt;Z&gt; operator *(const vector&lt;Z&gt; &amp;f, const vector&lt;Z&gt; &amp;g){ if(f.size()*g.size()&lt;=1000){ vector&lt;Z&gt; ans; ans.resize(f.size()+g.size()-1); for(unsigned i=0; i&lt;f.size(); ++i) for(unsigned j=0; j&lt;g.size(); ++j) ans[i+j]+=f[i]*g[j]; return ans; } static vector&lt;Z&gt; F, G; F=f, G=g; int p=Get(f.size()+g.size()-2); DFT(F, p), DFT(G, p); for(int i=0; i&lt;p; ++i) F[i]*=G[i]; IDFT(F, p); return F.resize(f.size()+g.size()-1), F;}int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;x), a.resize(m+1), b.resize(m+1); for(int i=0; i&lt;=m; ++i) scanf(&quot;%d&quot;, &amp;a[i].x); b[m]=1; for(int i=2; i&lt;=m; ++i) b[m]*=i; b[m]=Pow(b[m]); for(int i=m; i; --i) b[i-1]=b[i]*i, a[i]*=b[i], b[i]*=(i&amp;1?P-1:1); Init(Get(m*2)), a=a*b; for(int i=0, k=1; i&lt;=m; k=(ull)k*(n-i++)%P*x%P) ans=ans+a[i]*k; return printf(&quot;%d&quot;, ans), 0;}","link":"/uoj-269/"},{"title":"「UOJ 345」「清华集训2017」榕树之心","text":"UOJ #345. 【清华集训2017】榕树之心 题目背景 深秋。冷风吹散了最后一丝夏日的暑气，也吹落了榕树脚下灌木丛的叶子。相识数年的 Evan 和 Lyra 再次回到了小时候见面的茂盛榕树之下。小溪依旧，石桥依旧，榕树虽是历经荣枯更迭，依旧亭亭如盖，只是 Evan 和 Lyra 再也不是七八年前不经世事的少年了。 …… “已经快是严冬了，榕树的叶子还没落呢……” “榕树是常绿树，是看不到明显的落叶季节的……” “唉……想不到已经七年了呢。榕树还是当年的榕树，你却不是当年的你了……” “其实又有什么是一成不变的呢，榕树常绿，翠绿树冠的宏观永恒，是由无数细小树叶的荣枯更迭组成的。在时间的流逝中一切都在不断变化着呢……” “但你看这榕树，日日如此，季季如此，年年如此，仿佛亘古不变般，盘根错节，郁郁葱葱。我在想，或许成为一棵树更好吧，任时间从枝叶间流过，我只守这一片绿荫就好。” “榕树固然长久，但在这无限的时光里，终归是要湮灭于尘土的。与其像榕树一般，植根于一方泥土中感受年复一年的四季更替。倒不如在有限的时间里看过尽可能多的世界吧。再说了，榕树虽生长缓慢，却依旧会在每年春天抽出一根新的枝条去向外探索的呢……” “真的吗，榕树在她漫长的一生里，就是这样往外一步步探索的吗？” “毕竟就算树冠看起来一成不变，榕树也会随着时间周期变化，春天到了自然就是生长的时候了，她也应当做出对应的表现吧……” “相比于对季节更替做出本能的生长，我倒宁愿相信，榕树有一颗活跃的的，探索的心。” “其实榕树是有心的，榕树刚刚种下的时候，心就在根的地方发芽了。以后每年春天榕树长出新枝条的时候，心就会向着新枝条的方向移动一点，这样就能更靠近外面的世界了。你看这头顶上的枝条，纵横交错，其实心已经在这枝杈间，移动了数十载了呢……” “哇，也就是说，这密密麻麻的树杈中的某个地方，藏着这棵榕树的心吗？” “没错，可是要知道它在哪，就得另花一番功夫了……” “呀，这时候想想，一株树还是不如一个人好……比如你，要是这样贴上去的话，就能听到跳动的声音呢……” …… 写这篇题解就是为了上面这一段话。 听说 OIer 都是文学家。 题意有一棵 $n$ 个点的树，初始时只有 $1$ 号点，心也在 $1$ 号点。 每次树会长出一个与当前某个已经存在节点相邻的点，心会沿着心到新点的简单路径移动一步。 现在已知树的最终形态，求所有生长顺序下哪些点可能成为心最终所在的位置。 $T$ 组数据。 $T\\le 20, n\\le 10^5$。 做法首先由于步数确定，把树黑白染色后会有一种颜色必然不能被走到。 考虑一个子问题，只需要求 $1$ 号点是否能成为心最终的位置。 令 $f_i$ 表示以 $i$ 为根的子树，初始只有 $i$ 号点，心也在 $i$ 号点，按任意顺序加完所有点后心离 $i$ 的最近距离。 答案即为 $[f_1=0]$。 计算 $f_u$ 时，找到一个 $f_v$ 最大的儿子 $v$，长完这个子树之后心到 $u$ 的距离最小是 $f_v+1$。之后如果心能够回到 $u$，通过调整选取顺序，最终必然可以停留在 $u$ 或 $u$ 的某个儿子上；如果不能，得到的也一定是最浅的方案。 考虑原来的问题，有点类似换根，再自上而下做一遍 dp 即可。 有一些细节是选取当前点的时候，当前点到 $1$ 的所有点必须已经被选。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int N = 100005;int num, n, W, T, h[N], f[N], siz[N], e[N&lt;&lt;1], pre[N&lt;&lt;1];bool ans[N];inline void add(int x, int y){ e[++num]=y, pre[num]=h[x], h[x]=num;}void dfs1(int u, int fa=0){ int mx=0; siz[u]=1; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa){ dfs1(e[i], u), siz[u]+=siz[e[i]]; if(f[e[i]]&gt;=f[mx]) mx=e[i]; } int sum=0; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa &amp;&amp; e[i]!=mx) sum+=siz[e[i]]; if(mx) f[u]=f[mx]+1-sum, f[u]=max(f[u], f[u]&amp;1); else f[u]=0;}void dfs2(int u, int fa=0, int dep=0){ int mx=fa, mx2=0, sum; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa){ if(f[e[i]]&gt;f[mx]) mx2=mx, mx=e[i]; else if(f[e[i]]&gt;=f[mx2]) mx2=e[i]; } if(mx==fa) sum=siz[u]; else sum=n-siz[mx]-1-dep; ans[u]=(((dep^n)&amp;1) &amp;&amp; sum&gt;=f[mx]+1); int fmx=f[mx], fmx2=f[mx2]; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa){ if(e[i]!=mx) f[u]=fmx+1-(sum-siz[e[i]]); else f[u]=fmx2+1-(mx2==fa?siz[u]-siz[mx]:n-siz[mx]-siz[mx2]-1-dep); f[u]=max(f[u], f[u]&amp;1), dfs2(e[i], u, dep+1); }}inline void solve(){ num=0, memset(h, 0, sizeof h); read(n); for(int i=1, x, y; i&lt;n; ++i) read(x), read(y), add(x, y), add(y, x); dfs1(1), dfs2(1); for(int i=1; i&lt;=(W==3?1:n); ++i) putchar('0'+ans[i]); putchar('\\n');}int main() { read(W), read(T); while(T--) solve(); return 0;}","link":"/uoj-345/"},{"title":"「UOJ 164」「清华集训2015」V","text":"UOJ #164 题意给出一个长度为$n$的数列$a$，需要维护以下操作 对于$i\\in[l,r]$，$a_i=a_i+x$ 对于$i\\in[l,r]$，$a_i=max(a_i-x,0)$ 对于$i\\in[l,r]$，$a_i=x$ 询问$a_y$ 询问$a_y$的历史最大值 $n,m\\le 5*10^5,0\\le a_i,x\\le10^9$ 分析定义标记$(x,y)$表示先$+x$再对$y$取$max$ 前三种操作可以转化为 $(x,0)$ $(-x,0)$ $(-inf,x)$ 标记是可以合并的。把时间较晚的$(c,d)$合并到$(a,b)$上，得到标记$(a+c,max(b+c,d))$ 每个节点维护标记$(add,mx)$，和上次$pushdown$该节点之后到现在，标记两部分的历史最大值$(madd,mmx)$ 带历史最大值标记的下传具体参考代码 每次查询下传到底就好了 注意$add$标记$-inf$时不要爆了 时间复杂度 $\\mathcal O(m\\log n)$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) { if (c == '-') iosig = true; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x + (x &lt;&lt; 2)) &lt;&lt; 1) + (c ^ '0'); if (iosig) x = -x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh = obuf;inline void print(char c) { if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf; *ooh++ = c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x == 0) print('0'); else { if (x &lt; 0) print('-'), x = -x; for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48; while (cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 500005;const ll inf = 1e16;int n, m, a[N];ll add[N&lt;&lt;2], madd[N&lt;&lt;2], mx[N&lt;&lt;2], mmx[N&lt;&lt;2];inline void chkmx(ll &amp;x, ll y){ x&lt;y?x=y:0;}inline void pushdown(int t){ int k=t&lt;&lt;1; chkmx(madd[k], add[k]+madd[t]); chkmx(mmx[k], max(mmx[t], mx[k]+madd[t])); chkmx(add[k]+=add[t], -inf); mx[k]=max(mx[t], mx[k]+add[t]); chkmx(madd[k|1], add[k|1]+madd[t]); chkmx(mmx[k|1], max(mmx[t], mx[k|1]+madd[t])); chkmx(add[k|1]+=add[t], -inf); mx[k|1]=max(mx[t], mx[k|1]+add[t]); add[t]=madd[t]=mx[t]=mmx[t]=0;}void build(int l, int r, int t){ if(l==r) return (void)(add[t]=madd[t]=a[l]); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; build(l, mid, k), build(mid+1, r, k|1);}void change(int l, int r, int t, int L, int R, ll x, ll y){ if(L&lt;=l &amp;&amp; r&lt;=R) return chkmx(madd[t], add[t]+=x), chkmx(mmx[t], mx[t]=max(mx[t]+x, y)); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; pushdown(t); if(L&lt;=mid) change(l, mid, k, L, R, x, y); if(R&gt;mid) change(mid+1, r, k|1, L, R, x, y);}ll query(int l, int r, int t, int pos, bool opt){ if(l==r) return opt?max(madd[t], mmx[t]):max(add[t], mx[t]); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; pushdown(t); return pos&lt;=mid?query(l, mid, k, pos, opt):query(mid+1, r, k|1, pos, opt);}int main() { read(n), read(m); for(int i=1; i&lt;=n; ++i) read(a[i]); build(1, n, 1); while(m--){ static int opt, l, r, x; read(opt), read(l); if(opt&lt;=3){ read(r), read(x); if(opt==1) change(1, n, 1, l, r, x, 0); else if(opt==2) change(1, n, 1, l, r, -x, 0); else change(1, n, 1, l, r, -inf, x); } else print(query(1, n, 1, l, opt-4)), print('\\n'); } return flush(), 0;}","link":"/uoj-64/"},{"title":"情人节随想","text":"对异地的她和他来说，相聚即是节，没有相聚的情人节往往是徒增感伤。 本想写一些文字记录这一段生活，不过赶不上在情人节这天完成，就暂时搁置了这个想法。所以这一篇文章也没有多少激动人心的内容。 剧透警告！ 本想在除夕早上看的 La La Land，阴差阳错地拖到了今天。这部电影在大陆上映的时间恰好是四年前的情人节。 Mia &amp; Sebastian’s Theme 和 City of Stars 真的好美！ 不过这部电影的情人节档是个骗局，男主和女主并没有在一起。 “I’m always gonna love you.” “I’m always gonna love you, too.” 当爱与理想分道扬镳，也许不一定要放弃后者。旧梦仍在，相视一笑，这便不是悲剧。 理想是什么，我总是说不出一个答案，我知道正在接近它。也许不需要说得出来的答案，我的特质和所经历的一切已经决定了理想，如此想，初来时的恐惧便可以消散了。 2021年2月14日 情人节","link":"/valentine-s-day/"},{"title":"WC2019游记","text":"没得去 PKUWC 来 WC 划划水。 要好好学习了。 Day 0出校之前没请假耽误了同学十分钟，深感抱歉。 走去海创园坐机场大巴路上听说延误了，还挺开心的。 本来 11:30 的飞机，反复咕，最后变成 15:10，真的惨。 早饭就吃了一片面包，隔膜打累了才发现饿。机场里消费太高，最后还是找了个金拱门实惠一点。 后来有人在 “杭州特产” 里买到了扑克，就和他们打双扣了，紧张刺激。 cwy 用对3放我仅剩的一张2被对面跑了 这飞机上还自带隔膜，就是操作太不方便了。睡觉还睡不着，也不是靠窗看不到什么，就背了点单词。 下飞机已经很晚了，有小哥哥来接机。 没赶上开幕式，到学校已经七点多了，在二楼找了个位置，耳朵就瞎了，奇奇怪怪的 Just the Way You Are，也不知道这节目前面经历了什么，没敢怎么看小姐姐。 然后听了 CCF 冬令营规模再创新高，再看了拉丁舞就溜去觅食了。 正式去觅食已经八点多了，走到万达跟着某人绕了好久去了一家奇奇怪怪的店吃晚饭，还不如金拱门。 主食是 DQ。 回来基本上卡好了查寝的时间 10:25，还真要熄灯啊，怎么好好冬眠。 走了两万多步累死了。 住的是女生寝室，人生第一次住女生寝室。 这寝室的布局也算神仙，不过条件也还可以了，倒水要下五楼去别的楼。 立个 flag 回杭州前不打隔膜，膜一下 cwy。 想到再补，已经第二天了，累死了先睡觉了。 Day 1早上醒来已经 7:30 了，早饭就咕了。 到报告厅听松松松讲造评测机，听倒是能听懂，后来和 myc 开别的题了。 午饭抢不到就咕了，先回了寝室。后来再去还是有不少人，将就着吃了一下。 没去拿酸奶亏死。 中午去逛了学校，量了下周长有 2km，面积好大哦，好富有。 下午讲量子计算好像都咕了，就我去。 开始还好，后面就掉线了。 晚上想溜到万达去，然后正门被保安拦住了，超凶，感觉再也出不去了，后来去侧门试了一下直接出去了，笑死。 结果吃了金拱门，三份随心配有点骚。 回来就试机了，一个 NTT 调了好久，是不是没救了。 回寝室后有点灰色，但是没打隔膜。 还是很晚才睡。 Day 2早上醒来已经 7:30 了。 直接去报告厅，Scape 已经开始讲具体数学了。 感觉还是挺有用的，但是基本概念都不知道，又过得太快，后面就掉线了。 休息之后是字符串，开局掉线。 后来就早早地去吃饭了，一堆人也冲出来了。 下午是 IOI 2018 Day1 和 ACM 趣题选讲，就这个在线了一会。 晚饭又溜去了万达，这次直接从侧门光明正大走出去了，两个人吃了四人餐。 回来是营员交流，LCA 已经开始讲了，就掉线了，后面几组也没上过线。 回寝室还是很灰色，11:35 的 CF 准备看下题的也咕了。 Day 3今天起得挺早。 又掉线了。 搞了搞之前开的题，模数打成 $988244353$ 要死了，求出来 $12^{-1} \\times 12$ 是一个奇怪的大数，还以为快速幂写错了，调了好久。 早早地出来抢了午饭。 下午是 IOI 2018 Day2 和一些其他的题，以为会和之前的一样清新的，然后就自闭了。 晚上的上机练习咕了，但是有提答和交互好慌啊。 Day 4上午是不简单的数论算法，一会上线一会掉线的。 下午讲多项式，生成函数和图的计数。 前面学过还好，后面就自闭了。 晚上的营员交流很欢乐，不过好像没什么用呢。 第三组的 myc 讲得死气沉沉，开局就掉线了。 第二天就要考试了，晚上还发生了一些事，但是一定要早点睡觉的，就先不管了，虽然也不是很早了。 Day 5终于考试了，状态极差，开场就很想睡觉。 没带笔没带手表。 A 一看 28 分就先扔了。 B 慢慢读，发现有 20 分。 看 C 自闭了，从来不怎么会交互。 然后就写了 A 的 28+4+4，写的时候 ./a &gt; tree4.in 于是丢了样例，乱了阵脚，大概已经过了 1h 了。 然后去搞 B 以为 subtask 2 很对，就没管了，subtask 4 看出了 NPC 之类的画风，就弃了，以为有 60 的，最后挂成 52。 中途把 oldcomputer3.in 覆盖掉了，吓死，特别绝望，举手好久没工作人员看到，结果记起来前面 A 样例丢了的时候备了份，顿时心情愉悦。 2h 的时候向工作人员提出重新获取样例，工作人员说 你等一会儿。 这就咕到了 3h 左右，再次提出才得到样例，一测过了。 2h 之后就很灰色了，来回想三道题，一点都不会，A 想过 Prufer 序列但是都忘完了就弃了。 最后一个多小时想的东西就考试无关了，已经清楚凉了。 最后二十分钟突然醒过来敲了 A 的 12 分指数暴力，好久没写了，不过还是挺好写的，平时考试都不写的后果。 C 题爆零也是水平太低了。 出来之后发现其他人都稳啊。 自闭了，没吃午饭。 隔膜已卸。 就这样了，还活着。 Day 6没咕，到了广东科学中心玩。 感觉里面都是给 8 岁以下的人玩的，不过挺好玩的就是了。 颁奖鸽了。","link":"/wc2019/"},{"title":"ZJOI2019 Day1 游记","text":"这么快就到了啊 Day -3听说昨天被奶了 = = 这怎么轮得到我的 Day -2跟贺指导打荒野行动，两次落地成盒之后就吃到鸡了，讲真的贺指导不太行。 睡得还算早。 Day -1听课体验 至少比以前好吧 虽然还是有掉线。 雀魂是真的好玩= = 填海机房的键盘好垃圾，B 按下去都有问题，跑起来倒挺快。 晚上下自走棋被打爆了，怀疑智商，要退役了。 睡得稍微有点迟，也没一直颓。 Day 0上午数据结构选讲，有些还挺小清新的= = 中午和 fls 一起吃饭 rp++ 下午讲课海星，好好准备省选了，不想退役啊。 晚上也挺早睡了，有点紧张，有喜欢的人陪着真好。 Day 1考试了 退役了，不更了 update 4.8 还是简单记一下吧.. 早上 5 点十几醒了，上了厕所然后 cwy 也醒了 = = 继续睡 坐车到填海校门口已经 7:56 了，走到考场已经是 8:00，但是好像刚开门。 8:10 发密码，密码还错了一次。 开题发现有麻将，有纯正九莲宝灯，还有吉利，心态崩了。 会 20 pts 直接搞搞就好了，先扔了。 看 B，也会 20 pts，随便看了眼 C 回来继续乱想，想不出什么多项式的复杂度。 然后开 C，会 10 pts，去年也就 60 pts，今年这样 20+20+10 也差不多了吧。 看到极强的性质 $l=r=n$ 就再也没去想 50 后面的部分分了= = 发现可以记个二元组搞搞，就先写了个应该是 $O(n^5)$ 的暴力，可以轻易优化得到 30 pts = = 还想继续优化但是没什么用，很多也压不到 $O(n^2)$。 然后发现只要根节点权值改变就行了，本质不同的二元组只有三种，这样就线性了。但是一开始以为是两种，写完调完已经 2h 了。 去年才 60 pts，今年 2h 就拿到 50 已经很棒了吧，精神大振 回来开 B 想到计算一个位置对答案的贡献，然后 xjb 凑状态。 后来分析了一下有标记的条件，有三种情况，转移也比较清楚，直接拿矩阵维护复杂度 $O(n\\log n)$，数据范围才 1e5 稳得一逼啊。 看了一下大概还有 2.5h，感觉最后 1h 补暴力也够了，就开始写 好像也挺好写的，就是要跑 6s = = 听说评测机很慢啊，然后就绝望了。 就一直卡常卡常卡常，卡到最后也没把答案矩阵改成向量 卡到 2.9s 了放弃了，想扔了搞搞 A，突然又看到一点可以卡的地方 = = 离结束 1h 的时候卡到了 2.4s 就不管了。 有点飘 A 就直接写 20 了，好像还有点难写的 = = 延迟了 10min，不过最后 20min 都无所事事。 怕放错位置，把代码复制了好多个地方。 出来之后有些人说没写 B 的 $O(n\\log n)$，好像有的还是 $O(n\\log ^2n)$，不过跑得差不多快 = = 感觉卡常已经很明确了，只有一个询问的 30 pts 感觉卡定了，另外 30 出题人放一半修改一半询问的话说不定还有戏 = = 很慌，一题都没拍，A 甚至没有样例可以测。 C 要是 f 了怎么办啊，再算上 B 卡掉 60，那.. 但是感觉，感觉也没理由写挂啊，但是真的，真的一点都不清晰，那 5h 又干了什么呢。 后来两个同学接连发现 A 的 20 pts fst 了，可能我要等成绩出来才能发现吧。 4.1 出成绩了一直没来更= = 评测机好像不是很慢，2.4s 的卡过去了，别的也没 fst 有些人还是被卡了啊 = = 他们都好强啊 Day 2 见了","link":"/zjoi2019-day1/"},{"title":"ZJOI2019 Day2 游记","text":"不知道会怎么样呢 update: 凉了 update: 进队了…欧是真的欧 Day -3 （4.22）雀魂好难啊。 Day -2 （4.23）早上到机房颓颓颓，被打到自闭。 中午坐车去余姚中学，去年也是在这里呢。 住的余姚宾馆，好大喔。 到了之后继续颓颓颓，后来把手机上隔膜都删了，比赛前还是不打了 = = 走到江对面去吃了顿金拱门，店很大倒没几个人。 还写了道题，晚上洗了澡穿着浴袍串门真是爽，十一点多才睡。 Day -1 （4.24）酒店的早餐还不错，早上走去余姚中学，过江的时候还以为没人行道，然后发现桥下面有台阶可以走上去，但是走上去了还是非机动车道 = = 到了之后已经没什么休闲养生座位了，最后坐了板凳。 上午是 zzy 讲课，感觉也还好？后来提前跑出去看妇联4了。 在万达吃了金拱门。 其实也没太大感觉，看看还是挺好看的，还看到最后 1s 什么彩蛋都没看到，出去被收眼镜的嘲讽了。 回来下午是 zzq 讲课，好像也还是可以听的。 听完跑去和鸽了一下午的人吃 KFC 了，吃完去试机。 桌子好高，凳子好矮，贺指导想必会适应一点吧。 机子速度也不是很快，$3$ 次长度 $2^{21}$ 的 NTT 跑了 1.8s，记得基本上同样代码在一试的机子上跑了 1s。 回来之后看到 yf 的讲稿好丑啊，然后改 LaTeX Beamer 改了一个晚上 = = 十点多才睡。 Day 0 （4.25）上午就是 yf 和 myc 讲课。 题目也还行吧，但是掉线了。 中午溜出去吃了 KFC = = 下午讲课鸽了 = = 鸽了也没干什么，写了一道题，然后就一直在划水了 = = 好焦虑。 六点多去泡澡。 问了好多人应该怎么办 = = 后来随便看了一下写的博客，八点就睡觉了。 果然睡不着呢，还突然想起来还不会 Linux 下面的一些编译选项和对拍什么的 = = 赶紧背。 九点多她放学了来安慰我……最后睡着了。 Day 1（4.26）六点半起的，好像之前就醒了，也睡不着了。 比较早到学校了，至少不像一试那样 = = 谢谢某位小哥哥送的星巴克 ⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄ 进考场还是有点慌的，zzy 就坐旁边 = = 开场先看了一下三道题好像都有 $40$ 暴力，感觉稳了。 由于一些原因决定开 B，先写了 $O(n^2)$ 的暴力，然后再去写了 A 的 $O(2^{3n})$ 的高斯消元。 大概 1h 不到就开始刚 B 了，走上不归路。 感觉这种点对的问题可以分治搞搞，点分想不太清楚，就写边分了。 钦定一条边之后考虑跨越这条边的路径和点对，左侧一个点在右侧对应的是一个包含根的联通块，左侧的一个点对应的联通块可以从儿子里合并上来，并且新加入若干以该点为端点的路径。 在右边维护的就是一个虚树状物。 直接拿线段树启发式合并，$O(n\\log^3n)$，$n=10^5$，时限 3s，稳了。 写了 1h，然后调调调，过了小样例之后就挂了个对拍，大概在 2.5h 的时候发现边分是假的 (╯‵□′)╯︵┻━┻ 出去上厕所冷静一下，想大不了再堆三题暴力 = = 碰到了 lyc，他好像以为我稳了。 回去冷静分析了一下挂掉的情况，是一条路径的 LCA 和下面的某个点的贡献没有计算到，因为边分重构的部分有问题（之前模拟赛题也这样 GG 过，这次写前虽然想过但是也没想到 = =）。 于是想到暴力把一条路径拆成三条，LCA 和两个端点再连一条，这样好像就对了。 最后调出来了，觉得自己 win 了，这种东西应该比 D1T2 难一点吧（当然最终是 lose 了）。 $5000$ 的随机数据拍了好久没挂，$10^5$ 的只要 3.1s，由于觉得本机挺慢就很自信。 后来发现一条链段错误了，好像是爆栈喔，觉得很凉 = = 开了栈跑了 90s+，冷静分析了一下之后发现没加之前想到的一个东西导致复杂度和路径长度总和有关，但是随机数据随便过 = = 加了之后链只要 1s，随机只要 1.9s。 然后爆栈的问题一顿瞎搞之后发现是 -ftrapv -fsanitize=address 的锅。 再次觉得 win 了。 大概已经 3.5h 之后了。 先把 C 的 $O(n^2)$ 暴力写了，后来再写了 A 的 $p_i=1$ 的 10pts。 陷入无所事事状态，反复幻想自己 win 了。 吃了点东西。 最后考完了。 zzy 主动问我怎么样 ⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄ 出来好像大家都过了 B 啊，这怎么树链剖分啊 = = 觉得也还好。 后来，听说是一个 $\\log$ 的，而且 $\\log^3$ 过不了 = = 好凉啊。 希望别的题别 fst 了啊.. 等退役了。 update 4.29 没 fst = = $\\log^3$ 草过去了，然后就..B队队长了?..","link":"/zjoi2019-day2/"},{"title":"ZJOI2020 游记","text":"最后一次参加 ZJOI 了，最后一个星期说要不颓，也没学进去什么。 Day 0 （6.19）看小朋友玩酒馆战棋和混乱大枪战，想着难得能以勤奋之人自居，就对他们说你们再打隔膜就要退役了。 傍晚收到了远方的来信，另外厚厚一叠明信片来不及读完便匆匆去复习算法，不过最后也只是简单推了一下多项式板子，另外一些看上去不太会在 OI 里考的就更没意愿去看了。 2020 的冬令营还没有举办，省选被挤到相邻两天，没有讲课，没有宾馆，多了梅雨下的冷清。 Day 1 （6.20）昨晚睡下后轮番被寝室外面洗澡唱歌吹风机的声音惊吓，又需要七点前起床，早饭没来得及吃被拉去测温，打的车也迟到，车上戴着口罩。到学车之后又在雨中狼狈地站了许久，进到考场外才有机会吃早饭，不过接下来时间还算充裕。 开考后的初始印象是，A 是一个可能不难的字符串，B 是一个不敢看的题（不过因为传统艺能的缘故，肯定还是要开的），C 是一个可能不难的贪心/DP。 于是我在 A 和 C 之间来回做，C 写了一个假算法过不了大样例，隐隐感受到了出现问题的地方，但是自己构不出数据。大约在一小时后就决定去看 B。 B 分析了一下发现大概是个签到题，没想清楚细节修了一段时间，卡完常数，总共过去不到三个小时。然后写完 A 的 40 再继续做 C，最后写了 C $O(Tn^5)$ 的 30 分，由于懒和一些原因没有去写 A 的额外 20 分。 晚上听说 BM 有用，但是不想复习了，鸽到了第二天。 Day 2 （6.21）司机从睡梦中醒来，给我们叫了另一辆车，结果甚至比前一天更早到学车。 一直到 Day 3 早上我都以为没有 fst，于是 Day 2 莫名自信。BM 没有学会，只大概想起来它是怎么操作的。 有人说三题分别叫 game, straight, password，而且 game 的样例文件最大，所以有可能是签到题（像 Day 1 一样）。开考之后倒不记得这些了，只知道要开 B 题。 A 题有四页题面，有另外两题加起来那么长，按照经验，去推 B 题。B 看上去就是个 min-max 容斥，推推推就会三方了，看着这卷积的样子冲上去写了个 FFT，结果最后也不会更好的复杂度。三方优化到两方一直留到最后一小时再补。 在 70 分左右的阴影里度过了大半程考试，由于 A 并没有什么思路，又担心这是签到题，先把必要的 10 分的树的部分写了。看上去 C 更可做，便在 BC 间反复跳跃，可惜到最后也只会 C 卡常的 10 分。（在重测后被卡掉了） 想着不管怎样不能犯昨天的懒，去找 A 的部分分，找到一档 10 分的 $S$ 中至少一点在环上的性质，感受了一下可以直接拆成树做，虽然不好写，但是半个小时冲还是要冲的，于是以尽量不影响原先树的部分的方式加了对环套树的处理，这样至少不会让原来的分丢掉。 考完之后在交流中得知了只有一个环的情况也被包含在我的算法之中，意外地获得了 5 分。 所幸的是标准分并不高，只要 70 分不挂就不会特别惨。 晚上听说进队了，但是没想到 Day 1 的 C 会挂光光。 后记三次参加 ZJOI，分别挂了 -20, 0, 30(-5) 分。 我只是写暴力进过队罢了，不及一些人对 OI 的热情，也没有他们的能力。 下面的路，又该怎么走呢？","link":"/zjoi2020/"},{"title":"基于变换合并的树上动态DP的链分治算法和全局平衡二叉树","text":"引入在有些dp中，转移可以用一种具有结合律的变换描述，并且可以快速合并 因此我们使用数据结构维护，来支持修改并快速得到全局或某个子结构的dp值 直接看例题吧 例题例题一 【模板】动态dpLuogu P4719 【模板】动态dp 题意给定一棵 $n$ 个点的树，第 $i$ 个点有点权 $a_i$。 有 $m$ 次操作，每次操作给定 $x,y$，表示修改点 $x$ 的权值为 $y$。 你需要在每次操作之后求出这棵树的最大权独立集的权值大小。 $n,m\\le10^5$ 分析一个弱化对于没有修改的情况，我们有一种简单的 $\\mathcal O(n)$ 树形dp 钦定一个根节点 令 $f_{u,0/1}$ 表示以 $u$ 为根的子树， $u$ 号点不选/选时的最大权独立集的权值大小 $$\\begin{align}f_{u,0}&amp;=\\sum_{u\\to v}max(f_{v,0},f_{v,1})\\f_{u,1}&amp;=a_u+\\sum_{u\\to v}f_{v,0}\\end{align}$$ 另一个弱化对于树是一条链的情况，上述dp可以大大简化 树链剖分考虑树剖，令 $son_u$ 表示 $u$ 的重儿子 dp转化为 $$\\begin{align}f_{u,0}&amp;=max(f_{son_u,0},f_{son_u,1})+\\sum_{u\\to v,v\\ne son_u}max(f_{v,0},f_{v,1})\\f_{u,1}&amp;=a_u+f_{son_u,0}+\\sum_{u\\to v,v\\ne son_u}f_{v,0}\\end{align}$$ 记 $$\\begin{align}g_{u,0}&amp;=\\sum_{u\\to v,v\\ne son_u}max(f_{v,0},f_{v,1})\\g_{u,1}&amp;=a_u+\\sum_{u\\to v,v\\ne son_u}f_{v,0}\\end{align}$$ 从而 $$\\begin{align}f_{u,0}&amp;=max(f_{son_u,0},f_{son_u,1})+g_{u,0}\\f_{u,1}&amp;=f_{son_u,0}+g_{u,1}\\end{align}$$ 矩阵我们用重新定义的线性变换来描述这个转移 把乘法变成加法 把加法变成取max $$\\begin{bmatrix}g_{u,0} &amp; g_{u,0} \\g_{u,1} &amp; -\\infty\\end{bmatrix}\\begin{pmatrix}f_{son_u,0} \\f_{son_u,1}\\end{pmatrix}\\begin{pmatrix}f_{u,0} \\f_{u,1}\\end{pmatrix}$$ 可以自己验证一下 并且可以证明这个这样的矩阵乘法是具有结合律的 需要求一个点的dp值的时候，只需要将这个点走重儿子走到底的矩阵乘起来就好了 考虑到一个点跳到根只会经过 $\\mathcal O(\\log n)$ 条轻边，我们用线段树维护矩阵的积，修改的时候反复执行如下操作 修改当前点的矩阵 跳到重链的顶端，计算dp值，更新父亲的 $g$，并跳到父亲处 单次修改复杂度是 $\\mathcal O(\\log^2n)$，查询 $\\mathcal O(\\log n)$ 单位矩阵是 $$\\begin{bmatrix}0 &amp; -\\infty \\-\\infty &amp; 0\\end{bmatrix}$$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 100005;int n, m, num, cnt, dfn[N], idfn[N], a[N], fa[N], h[N], siz[N], top[N], last[N], e[N&lt;&lt;1], pre[N&lt;&lt;1], f[N][2], g[N][2];struct matrix{ int a[2][2]; inline matrix(){ memset(a, 0, sizeof a);} inline matrix(int x, int y){ a[0][0]=a[0][1]=x, a[1][0]=y, a[1][1]=-1e9;} inline matrix operator *(const matrix &amp;rhs)const{ matrix ans; for(int i=0; i&lt;2; ++i) for(int j=0; j&lt;2; ++j) ans.a[i][j]=max(a[i][0]+rhs.a[0][j], a[i][1]+rhs.a[1][j]); return ans; }}s[N&lt;&lt;2];inline void add(int x, int y){ e[++num]=y, pre[num]=h[x], h[x]=num;}void dfs1(int u){ siz[u]=1, f[u][1]=a[u]; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa[u]){ fa[e[i]]=u, dfs1(e[i]), siz[u]+=siz[e[i]]; f[u][0]+=max(f[e[i]][0], f[e[i]][1]), f[u][1]+=f[e[i]][0]; }}void dfs2(int u){ idfn[dfn[u]=++cnt]=u; int son=0; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa[u] &amp;&amp; siz[e[i]]&gt;siz[son]) son=e[i]; if(son) top[son]=top[u], dfs2(son), last[u]=last[son]; else last[u]=cnt; g[u][1]+=a[u]; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa[u] &amp;&amp; e[i]!=son){ top[e[i]]=e[i], dfs2(e[i]); g[u][0]+=max(f[e[i]][0], f[e[i]][1]), g[u][1]+=f[e[i]][0]; }}void build(int l, int r, int t){ if(l==r) return (void)(s[t]=matrix(g[idfn[l]][0], g[idfn[l]][1])); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; build(l, mid, k), build(mid+1, r, k|1); s[t]=s[k]*s[k|1];}void modify(int l, int r, int t, int x){ if(l==r) return (void)(s[t]=matrix(g[idfn[l]][0], g[idfn[l]][1])); int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; if(x&lt;=mid) modify(l, mid, k, x); else modify(mid+1, r, k|1, x); s[t]=s[k]*s[k|1];}matrix query(int l, int r, int t, int L, int R){ if(L&lt;=l &amp;&amp; r&lt;=R) return s[t]; int mid=l+r&gt;&gt;1, k=t&lt;&lt;1; if(R&lt;=mid) return query(l, mid, k, L, R); if(L&gt;mid) return query(mid+1, r, k|1, L, R); return query(l, mid, k, L, R)*query(mid+1, r, k|1, L, R);}int main() { read(n), read(m); for(int i=1; i&lt;=n; ++i) read(a[i]); for(int i=1; i&lt;n; ++i){ static int x, y; read(x), read(y), add(x, y), add(y, x); } dfs1(1), top[1]=1, dfs2(1); build(1, n, 1); while(m--){ static int x, y; read(x), read(y); g[x][1]+=y-a[x], a[x]=y; while(x){ modify(1, n, 1, dfn[x]); x=top[x]; matrix tmp=query(1, n, 1, dfn[x], last[x]); g[fa[x]][0]-=max(f[x][0], f[x][1]), g[fa[x]][1]-=f[x][0]; f[x][0]=tmp.a[0][0], f[x][1]=tmp.a[1][0]; g[fa[x]][0]+=max(f[x][0], f[x][1]), g[fa[x]][1]+=f[x][0]; x=fa[x]; } print(max(f[1][0], f[1][1])), print('\\n'); } return flush(), 0;} 例题二 动态dp【加强版】Luogu P4751 动态dp【加强版】 题意同上 强制在线 $n,m\\le10^6$ 分析数据范围要求了更优秀的复杂度，有人会想到 $\\mathcal O((n+q)\\log n)$ 的LCT，但是LCT实际表现并不理想.. 考虑到这里不需要一些link, cut和换根操作，我们可以构造一种类似Link-Cut Trees的静态结构 全局平衡二叉树概述像LCT一样，把每条重链用一棵辅助二叉树维护，辅助树之间用虚边连接，重链之间也构成了一棵有根树 每个节点需要维护自己所在的重链的辅助树的子树矩阵积 事实上前面的线段树也是一种类似的结构，只是每棵都保持了绝对的平衡，导致复杂度 $\\mathcal O(\\log^2n)$ 而我们需要找到一种给辅助树定制合适形态的方法，做到全局平衡 构造 定义点 $u$ 的权重 $w_u=size_u-size_{son_u}$，即所有轻儿子的size和+1 构造一条重链的辅助树的时候，令带权重心为根，左右递归构造即可 复杂度可以证明这样总的一棵全局平衡二叉树的深度是 $\\mathcal O(\\log n)$ 的 具体可以参考文末的资料1 这样我们只需要在这棵树上向上跳并更新，在跳虚边的时候注意类似的特判（更新父亲的 $g$） 代码由于是第一次写，这里构造全局平衡二叉树的写法和下面的例题三略有不同 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 1000005;int n, m, num, root, lastans, top[N], son[N], s[N], b[N], a[N], w[N], siz[N], fa[N], h[N], e[N&lt;&lt;1], pre[N&lt;&lt;1], ch[N][2], f[N][2], g[N][2];struct matrix{ int a[2][2]; inline matrix(){ memset(a, 0, sizeof a);} inline matrix(int x, int y){ a[0][0]=a[0][1]=x, a[1][0]=y, a[1][1]=-1e9;} inline matrix operator *(const matrix &amp;rhs)const{ matrix ans; for(int i=0; i&lt;2; ++i) for(int j=0; j&lt;2; ++j) ans.a[i][j]=max(a[i][0]+rhs.a[0][j], a[i][1]+rhs.a[1][j]); return ans; }}F[N], G[N];inline void add(int x, int y){ e[++num]=y, pre[num]=h[x], h[x]=num;}void update(int x){ F[x]=F[ch[x][0]]*G[x]*F[ch[x][1]];}int build(int l, int r){ if(l&gt;r) return 0; int x=(s[l-1]+s[r]+1)/2, L=l, R=r, t=r; while(L&lt;=R){ int mid=L+R&gt;&gt;1; if(s[mid]&gt;=x) t=mid, R=mid-1; else L=mid+1; } int u=b[t]; fa[ch[u][0]=build(l, t-1)]=u, fa[ch[u][1]=build(t+1, r)]=u; return update(u), u;}void dfs1(int u){ siz[u]=1, f[u][1]=a[u]; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa[u]){ fa[e[i]]=u, dfs1(e[i]), siz[u]+=siz[e[i]]; if(siz[e[i]]&gt;siz[son[u]]) son[u]=e[i]; f[u][0]+=max(f[e[i]][0], f[e[i]][1]), f[u][1]+=f[e[i]][0]; } w[u]=siz[u]-siz[son[u]];}void dfs2(int u){ if(son[u]) top[son[u]]=top[u], dfs2(son[u]); g[u][1]+=a[u]; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa[u] &amp;&amp; e[i]!=son[u]){ top[e[i]]=e[i], dfs2(e[i]); g[u][0]+=max(f[e[i]][0], f[e[i]][1]), g[u][1]+=f[e[i]][0]; } G[u]=matrix(g[u][0], g[u][1]); if(top[u]==u){ int cnt=0; for(int j=u; j; j=son[j]) b[++cnt]=j, s[cnt]=s[cnt-1]+w[j]; int tmp=fa[u]; fa[root=build(1, cnt)]=tmp; }}int main() { read(n), read(m); for(int i=1; i&lt;=n; ++i) read(a[i]); for(int i=1; i&lt;n; ++i){ static int x, y; read(x), read(y), add(x, y), add(y, x); } F[0].a[0][1]=F[0].a[1][0]=-1e9; dfs1(1), top[1]=1, dfs2(1); while(m--){ static int x, y, v; read(x), read(y); x^=lastans; g[x][1]+=y-a[x], a[x]=y; G[x]=matrix(g[x][0], g[x][1]); while(x){ v=fa[x]; if(ch[v][0]!=x &amp;&amp; ch[v][1]!=x) g[v][0]-=max(F[x].a[0][0], F[x].a[1][0]), g[v][1]-=F[x].a[0][0]; update(x); if(ch[v][0]!=x &amp;&amp; ch[v][1]!=x) g[v][0]+=max(F[x].a[0][0], F[x].a[1][0]), g[v][1]+=F[x].a[0][0], G[v]=matrix(g[v][0], g[v][1]); x=v; } print(lastans=max(F[root].a[0][0], F[root].a[1][0])), print('\\n'); } return flush(), 0;} 例题三 洪水BZOJ 4712 洪水 题意你有一棵 $n$ 个点的树，第 $i$ 个点的点权是 $a_i$ 有 $q$ 次操作 C x y表示修改第 $x$ 个点的点权为 $y$ Q x表示询问删除一些点使得 $x$ 的子树中的每个叶子与 $x$ 不连通的最小代价 其中删除一个点的代价是它的点权，总代价是每个删除的点的代价的和 $n,q\\le2*10^5$ 分析dp考虑静态的dp，令 $f_u$ 表示以 $u$ 为根的子树的答案，有 $$f_u=min(a_u,\\sum_{u\\to v}f_v)$$ 令 $son_u$ 表示 $u$ 的重儿子，则 $$f_u=min(a_u,f_{son_u}+\\sum_{u\\to v,v\\ne son_u}f_v)$$ 记$$g_u=\\sum_{u\\to v,v\\ne son_u}f_v$$ 特殊地令叶子节点 $g_i=\\infty$ 则 $$f_u=min(a_u,f_{son_u}+g_u)$$ 变换这可以看做一个变换 $trans_{a,b}(x)=min(a,x+b)$ ，用这种方式可以解决在重链上的转移 一个节点的答案就是这个点到所在重链的底端的变换反顺序作用在 $0$ 上 而两个这样的变换合并后仍然是同样的形式 $$\\begin{align}&amp;trans_{c,d}(trans_{a,b}(x))\\=&amp;trans_{c,d}(min(a,x+b))\\=&amp;min(c,min(a,x+b)+d)\\=&amp;min(c,min(a+d,x+b+d))\\=&amp;min(min(c,a+d),x+b+d)\\=&amp;trans_{min(c,a+d),b+d}(x)\\end{align}$$ 复杂度如果用例题一的方法直接线段树维护，可以做到修改 $\\mathcal O(\\log^2n)$，询问 $\\mathcal O(\\log n)$ 而使用全局平衡二叉树可以做到 $\\mathcal O(\\log n)$ 询问由于这里的询问不是全局，我们要把重链上深度不比 $x$ 小的所有点的变换合并起来，这在二叉树上走一下就好了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);}template&lt;class T&gt;inline void read(T &amp;x) { static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) { if (c == '-') iosig=true; if (c == -1) return; } for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;}const int OUT_LEN = 10000000;char obuf[OUT_LEN], *ooh=obuf;inline void print(char c) { if (ooh==obuf+OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh=obuf; *ooh++=c;}template&lt;class T&gt;inline void print(T x) { static int buf[30], cnt; if (x==0) print('0'); else { if (x&lt;0) print('-'), x=-x; for (cnt=0; x; x/=10) buf[++cnt]=x%10+48; while(cnt) print((char)buf[cnt--]); }}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }const int N = 200005;const ll inf = 1e15;int n, m, num, root, son[N], w[N], a[N], b[N], siz[N], h[N], fa[N], e[N&lt;&lt;1], pre[N&lt;&lt;1], ch[N][2];ll f[N];bool isr[N];struct tf{ ll a, b; inline tf(){} inline tf(ll x, ll y){ a=x, b=y;} inline tf operator *(const tf &amp;rhs)const{ return tf(min(a, b+rhs.a), b+rhs.b); }}F[N], G[N];inline void add(int x, int y){ e[++num]=y, pre[num]=h[x], h[x]=num;}inline void update(int u){ F[u]=F[ch[u][0]]*G[u]*F[ch[u][1]];}int divide(int l, int r){ if(l&gt;r) return 0; int sum=0, t, x=0; for(int i=l; i&lt;=r; ++i) sum+=w[b[i]]; for(t=l; t&lt;=r; ++t) if((x+=w[b[t]])*2&gt;=sum) break; int u=b[t]; fa[ch[u][0]=divide(l, t-1)]=u, fa[ch[u][1]=divide(t+1, r)]=u; return update(u), u;}inline int build(int u){ int cnt=0; for(; u; u=son[u]) b[++cnt]=u; int r=divide(1, cnt); return isr[r]=1, r;}void dfs(int u){ siz[u]=1; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa[u]){ fa[e[i]]=u, dfs(e[i]), siz[u]+=siz[e[i]], f[u]+=f[e[i]]; if(siz[e[i]]&gt;siz[son[u]]) son[u]=e[i]; } w[u]=siz[u]-siz[son[u]]; if(son[u]) G[u]=tf(a[u], f[u]-f[son[u]]), f[u]=min(f[u], (ll)a[u]); else G[u]=tf(a[u], inf), f[u]=a[u]; for(int i=h[u]; i; i=pre[i]) if(e[i]!=fa[u] &amp;&amp; e[i]!=son[u]) fa[build(e[i])]=u;}int main() { read(n); for(int i=1; i&lt;=n; ++i) read(a[i]); for(int i=1; i&lt;n; ++i){ static int x, y; read(x), read(y), add(x, y), add(y, x); } F[0]=tf(inf, 0); dfs(1), fa[root=build(1)]=0; read(m); while(m--){ static char opt; static int x, y; while(isspace(opt=read())); read(x); if(opt=='Q'){ tf ans=G[x]*F[ch[x][1]]; while(!isr[x]){ if(ch[fa[x]][0]==x) ans=ans*G[fa[x]]*F[ch[fa[x]][1]]; x=fa[x]; } print(ans.a), print('\\n'); } else{ read(y); G[x].a+=y; while(x){ if(isr[x]) G[fa[x]].b-=F[x].a; update(x); if(isr[x]) G[fa[x]].b+=F[x].a; x=fa[x]; } } } return flush(), 0;} 例题四 切树游戏题解 总结动态dp还是很神奇的 全局平衡二叉树，zx2003说拿这个卡掉多一个 $\\log$ 的不好，那就不好吧.. 不过代码大概确实比树剖线段树短 参考资料 杨哲《SPOJ375 QTREE 解法的一些研究》 陈俊锟《〈神奇的子图〉命题报告及其拓展》 基于变换合并的树上动态 DP 的链分治算法 &amp; SDOI2017 切树游戏（cut）解题报告","link":"/%E5%9F%BA%E4%BA%8E%E5%8F%98%E6%8D%A2%E5%90%88%E5%B9%B6%E7%9A%84%E6%A0%91%E4%B8%8A%E5%8A%A8%E6%80%81DP%E7%9A%84%E9%93%BE%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E5%92%8C%E5%85%A8%E5%B1%80%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"学车日记","text":"基本康复后终于开始学车了！ 4.16（报名）我：如果我方言讲不清楚怎么办？ 我妈：那你就跟他讲普通话。 下午被师傅接去报名。因为前一天没随身带着身份证就推迟了一天。先去了医院做了四十块钱的检查，医院仍然是我诊断出急性肠胃炎和自发性气胸时的那副模样，不过这次不那么让人害怕。随后到了驾校，驾校是一块场地加上一间活动房。同时另外有两个人也是来报名的，其中一个在医院刚碰见过；另一个是个四十岁左右的光头先生，手机用的是类似EMUI“简易模式”的巨大字体。安装完注册完三个App，阿姨说你居然自己都弄好了。我尴尬地笑笑，直到看见光头先生用微信扫描二维码下载一个App的时候，跳转到了给微信开启“应用内安装其他应用”权限的界面后问这样好了吗，才体会到阿姨那句夸奖的分量。 4.17“机动车驾驶人互联网学习软件”里有总长两小时的八个视频必须看完，基本都是一些血腥的案例，马赛克时有时无，是否降低了画面的血腥程度我不知道，当事人隐私肯定被泄露光了。 今天鼻炎和发烧随着扁桃体炎一起来了，为什么病总是找上我？ 4.18半夜醒了两次，第一次醒自己估摸着应该是三点多，听见外面我爸的声音，觉得很奇怪，看了一下时间原来才十二点多。 把昨天没看完的视频看完了，坐在椅子看着淋漓的鲜血，不安全感随着发烧的酸痛穿透了我的全身。 4.19做题数236。 4.20第一次模拟考试61/72。90/100为通过。 第二次模拟考试69/80。 第三次模拟考试85/100。 4.21第四次模拟考试94/100。 4.22第五次模拟考试91/100。 做题数817。 4.23第六次模拟考试96/100。 做题数917。 4.24第七次模拟考试92/100。 做题数998。 4.25第八次模拟考试92/100。 第九次模拟考试93/100。 第十次模拟考试91/100。 做题数1292。 4.26 周一早上去参加科目一考试，同行还有一个学员，就叫他 A 吧。 A 是上周五考的科目一，教练把车开到大路上，停车让 A 开，我便赶紧系好安全带。后来教练还说考完回来要我开，非常害怕。A 开车在每个红灯停下后起步太慢都会被后车催，但是后车也不敢撞我们。到了考场直接去排队，教练和 A 就去附近场地练习。队伍很长，前面大概有五十个人，开考还有半小时，等候的时候又做了两次模拟考试。 第十一次模拟考试94/100。 第十二次模拟考试97/100。 做题数1422。 交了80块钱，总共刷了两次身份证，刷了三次人脸，开始考试。 我并不知道一道题做错是否有即时的提示，不过没关系，亲切的第二题就打消了我的疑虑。题目在我的印象里是C1证能否驾驶轻型载货汽车，但是肯定是我记错或是读错了，不然就不会错。我一下慌了起来，到目前为止50%的错误率，如果这是我的真实水平，预计后面还要错49题。我赶紧骗自己，我的水平不会那么低。重拾信心后我开始小心地对待每一道题。终于在接近20分钟后得到了99分的好成绩。考试软件卡了好几次，甚至有一次我不小心多点了一次“下一题”，所幸未选答案不会进行提交，可以返回再来。 出考场打印了成绩，非常开心，重新把手机开机，刚下楼看见教练和 A，就直接上了车。开到路上教练让 A 来开，开到大路上教练让我来开，我一路心惊胆战平安开到了该下车的地方，熄了两次火，不知道被多少车用喇叭嘲讽过。路况好的地方速度到过80km/h（没记错的话）。教练发了我科目三灯光规则，通知我明天练车。 4.27下午教练来接我，便让我开着去接 A，再到练习场地。今天练倒车入库，教练把油门封死了，撞墙概率大大降低。我和 A 轮流练了总共近三个小时，学会了大幅度打方向，已经基本可以在这个场地将这辆车停好。结束后 A 开车先送我回家，再送自己回家。 4.28开车到场地的路上，急转进小路的地方熄火了两次，一慌便忘了离合怎么踩，切不能慌，最不济可以停下打方向。 继续练了一下午的倒车入库，不用一会儿左脚就麻了。总觉得已经完全熟练了，再练却总能有新的经验。 4.29先开车送人到湄池打疫苗，再开回场地，这次没有熄火，路上行车也逐渐熟练。 先学习了左向的倒车入库，原先练习的只有右向，同时也大概知道了科目二的流程。在右向已经基本掌握的情况下，另一个方向就简单许多。练习几次后便开始学侧方位停车。侧方位停车比想象中容易，一个原因肯定是标线过于精确，生活中停车便要全凭经验判断和随机应变了。最难的一部分是从停车位出来后要准确进入到指定位置，以便开始下一次倒车，若没有调准，下一次倒车就会有意外了。 若说每次新学内容由我开始是因为恰好我负责来程的行车，仍有一些差别可以让我满足一下小小的虚荣心。昨天教练下车让我自己练习，A 仍坐在后排；今天因事暂时离开时，让我坐副驾驶在紧急情况下帮 A 踩刹车。也许实际上 A 并没有多少不堪，也许 A 更需要这些鼓励，而如果 A 学得完全比我好，我也会更高兴的。 4.30今天是去驾校练车的第一天，早上去接 A 时他还没睡醒，手机也没带到自己家，所以在等待了一会儿后我和教练先去了驾校。上午练车都是七点，下午都是一点半，七点出头的时间意味着在我们到达时还没有其他人，大门也关着，这不禁让我为自己的勤奋感到鼓舞。驾校场地是一块不大不小的科目二练习场地————也许不如正式考试的地方，用了一处额外的转弯才将整条路线串联起来————但是足以容纳许多车辆一起练习，为枯燥的练习时间增添了些许轻松的氛围。 倒车入库和侧方位停车与先前练习的并无多少区别，新环节的加入也更令我振奋。上坡起步与我猜想的似乎有许多出入，本以为需要手刹配合离合和油门进行一通迅速而精确的操作，并不会知道手刹是抬起便放下，而全部的戏份给了离合，压力也落在了左脚上。直角转弯需要在入弯前关闭转向灯，这一规定恰与科目一所要求明白的行车规则相反。曲线行驶在知道方法后就不是很难了，但是进一步的，直接凭感觉确定整车在路上的方位还有很远的路要走。 在连续练了几圈后，又一次回到起点等待前车出发时，一个中年男子走到我的车窗边。 “小师傅，我刚才看你开这个侧方位停车，全都是错的。” 虽然觉得这是一个夸夸其谈之人，听到这些不免让我有些紧张。 “我看了你三次，进来出去，都压线了。” “啊……” “你上去的时候停的离那个线太近了，一般要出去四五十公分，停都没停好后面怎么倒得好？” 似懂非懂，努力理解着我说了声谢谢，然后才逐渐明白压的是哪条线，是哪里出了问题。有人指出问题，我还是很开心的。后来 A 问教练那个男子是不是也是教练，教练说是学员，教练都在空调房里睡觉，或者打牌。 5.1今天是劳动节，教练带我和 A 去诸暨科目三实地练习，但是要先取回刷卡的机器，记录足够的学时才能报考。于是我们先去了在大唐的总部，到了后却得知机器在城区的报名点，拿到机器却因为我和 A 都没带身份证办不了学员卡（后来似乎办出来了）。而机器的接线又需要找到另外一个教练，在大唐的另外一个场地，他最后也并没有完全接好机器，大概是教练回店口之后弄好的。因为 A 第二天要上班，一个学员一天只能刷四小时的卡，于是我下午空了出来不必再去，将时间都让给了 A。 5.2今天是劳动节假期的第二天，两年前的今天第一次见到 fyj。那时候做了多少的幼稚事，与 fyj 关系好时仍可以现状自慰，而如今只剩后悔悲哀。 今天带上了另一个（新？）学员去诸暨练习，就叫她 B 吧。B 因为照片没有更换的原因人脸检测通不过，最终我在上午打了三小时的卡，距离要求的近四十小时还遥遥无期。快到中午时因为 A 说今天并没有上班，教练临时决定回去让 A 多记录一些学时，因此下午我又不必再去。 若没有学时要求，想必不过几天我就可以去参加考试了。 5.3休息。 5.4早上被叫去学车，醒来看到已经略晚，于是比原定时间晚了半小时，九点半去练车。到十一点半的两个小时里，一半时间停车休息，我坐着背了单词，读《安娜·卡列尼娜》。大部分时间教练外放小说，实在扰人宁静。若只有令我反感的爽文剧情倒也罢了（从我听到的部分来看，主角竟是强奸犯出狱，不知道是不是受冤（update: 确实是受冤）），但机器朗读的声音实在不堪入耳，就像在b站听到一些 up 的配音是明显的机器人，我总是难以忍受。虽然给 cwy 做的视频里也用的机器人，但是 Microsoft Xiaoxiao Online 比一般听到的好到不知道哪里去了，而且视频里的讲解词相比小说的语言是更适合平淡的语气的（想象机器人读“哈哈哈”）。 5.5出游，休息。 5.6到学校办事，休息。 5.7练了一上午。 5.8练了一上午 5.9去科目三考场练了一整天，标准的靠边停车有点点难。反复绕圈练靠边停车的时候，有一个开着奥迪（型号我不记得了，车也从来不是我关注的点）的中年人时走时停，好一会儿我们才明白他也在练习靠边停车，停一次下车看一圈，也有几分滑稽。但是既然是独自在练习，以普遍理性而论，他已经有驾照了；而有了驾照还想做到考试标准的靠边停车，着实令人费解。 久坐真是会屁股疼，教练是习惯了吗？ 5.10到学校打工，休息。 5.11继续在学校打工，休息。 5.12继续在学校打工，休息。 5.13上午学车，教练换了一本小说在读。 小说讲的是男主在一个练功的世界里拥有其他人所没有的游戏系统，凭借这个系统和出类拔萃的天赋在几乎每一次冲突中取得胜利。各种条件被量化到具体数字，比如金钱、声望、经验值，确实符合一个游戏的设定；而打斗的细节（暂且忽略其不合理性）是现有的游戏无法模拟出来的，于是制造了一种奇异的结合体。 我内心总是鄙夷这类文字，认为除了一个人被困荒岛且别无选择（或被人以性命相逼）时，去读它们都是不可取的。像上一段提到的，主观上我还觉得它对于主角用以取胜的招式的描写时常是有违常理的，且几乎所有的对手选择的态度都是轻视而导致主角总是以弱胜强，有时候利用囤积的经验值在战斗过程中升级以恢复体能的方式也实在不合我的胃口。读者在阅读时，完全不必担心主角会遭遇什么不测，只需要准备好接受一次次看似侥幸实则必然的突破和胜利就万事大吉了。好在这一本书没有上一本那么多色情描写，主角也没有那么多情人，我十分庆幸。 5.14上午学车，科目二快刷完 16h 了，练的时间越来越短，坐的时间越来越长。 5.15下午学车，开始刷科目三，36℃的气温，坐在车上出着汗，想着要是没有住院早就已经考完驾照了，顿时开始讨厌自己不争气的身体，恨铁不成钢。 5.16继续刷科目三，在办证中心门口停车休息，停两小时去圆盘绕一圈再回来，天微凉，但仍有些闷。 5.17天冷了，是我最喜欢的温度，车里有些偏热，只能把刚穿上的外套脱了。这几天里大概知道了真实情况下侧方位停车的一些方法。 5.18被征召到学校寻找丢失的素材和进行排练，暂缓了还剩一天的学车打卡。 5.19进行（原以为）最后一天的打卡，没有想到记录时间被减少了七小时左右，一时间觉得审查人员真是该死，冷静之后想到也不能怪这些执行命令的人。也许是之前玩手机被发现了，或者是科目三的平均速度过低的时候会被取消记录，因为科目二的记录并没有被取消，第二条理由似乎更合理一些。 仔细考虑一下三十八小时强制要求的合理性，假设改成十八小时，且不提学员积极性会提高，有效学习时间或许不降反升（如果这个假设成立，那后面的设想就都是多余的了），只考虑截至去年六月的四亿汽车驾驶人每人节省的学习时间二十小时，不包括额外的时间消耗如每日往返驾校，共计约 913242 年。这里不讨论教练的时间，因为这个政策改变可能影响教练的收入和失业或就业，不可能由我来预测。以车祸丧生者比预期寿命减少 50 年为例，以上时间相当于 18264 个人减少的寿命，这里包括了睡觉的时间，实际上那么多时间中很多是没有意义的。作为参考，2018年，中国汽车发生交通事故 166906 起，导致 46161 人死亡，169046 人受伤（注意这只是一年的数据，而以上计算的是所有汽车驾驶人在一生中被浪费的时间）。此外，学车浪费的多是青春的大好时光，我几天前就与一同学谈起高考后学车的问题，达成的一致是这个暑假学车的确格外令人烦恼。当然，我也同意意外死亡造成的损失绝不是浪费一小部分生命可以相比的。 综上所述，鉴于不知道这个改变对交通事故发生率的影响究竟有多少，我不能说三十八小时是形式主义的、脱离现实的，但也不能否认十八小时制存在一定的合理性。 5.27考科目二的前一天，到考场实地练习。下午就要去学校拍毕业照，以为科目二和科一科三是同一个地方，离高铁站不远，于是提前买了到杭州的高铁票。早上上路发现事情不太对，结果到达后发现离高铁站也不远，惊讶之余也松了一口气。 六点不到就已经上路，阴云未散的晴天，太阳斜照下来，山林田地便比天空亮上许多，是不多见的景象。虽然太阳晒到后不免发烫，晨风还是很清凉，拨去了我的困意。 场地有四条线路，两条在外围，比较长，是属于旧桑塔纳的，另两条则是新桑塔纳。大概是因为已经淘汰得差不多了，旧桑塔纳的线路练习的车相对少了很多，尽管有时仍然需要排队；而隔壁的车辆已经排到了入口，说整个圈都挤满了也不为过。 三四个人轮流练起来并不是很快，几轮下来，直角转弯还没有完全的把握，但时间告急，我便离开到外面路口打车赶高铁去了，其他几人到日落才结束。 5.28时隔一个月再次走上正式的考场，不免十分紧张。一起考试共有四人，C 是三号线，AB 和我都是四号线。三号线进度快，很快 C 就开考了，一次就满分通过了。在 C 进去大半个小时之后我和 AB 分别去起点等待，再分别开始了考试。等待过程中紧张的感觉已经消磨殆尽，上车时新出现的害怕，在车开动起来后也逐渐消散。在第一个项目侧方位停车前的一长段路上我不断调着反光镜的角度，大概是因为本来就装得有点歪，所以总是有不对劲的感觉，虽然并不会有很大的影响。一切顺利来到了直角转弯，因为考试车与平时练习的车有些区别，我一直没有很认真对待车窗下的标点，大部分时候只是凭借感觉判断时机，所幸有惊无险，没有压到实线，转过了弯。曲线行驶不是很完美，但足够正常通过了。最后的倒车入库是我最喜欢的环节，胜利的喜悦已经逐渐充满了我的内心。一切仍是那么平凡，除了在第二次倒车时有蚊子趴到了我的左腿上，半踩着离合不能松开，手却又够不到，一番挣扎后，我抬起管着刹车的右脚在蚊子的位置蹭了一下，再赶忙恢复原样。 考完后拿着满分的成绩单找到教练，得知 B 第一次在侧方停车的时候前后压了三次线，每次是 10 分，已经在准备第二次出发了。大厅的监看很有趣，有一个车内视角，一个场地视角，在进入对应项目时会切换到合适的摄像头，和一个用简单线条组成的遥感俯视图。我看着学员们做着一个个的动作，擦过一条又一条的边线。几分钟后去迎接 90 分的 B，再后来是补考 100 的 A。 下午教练并没有像我预想中那样放我们回家，在镇上一个餐馆解决午饭后又去了科三场地。科三实际上有 A 区和 B 区两个部分，每个区有若干条线，每天考的是其中一个区，每周内 A 区和 B 区交替。B 区较难，于是大部分人可以预见地选择了 A 区。以前时间的安排会提前公布，因为一些原因，可能是 31 日预约 A 区的人实在太多，新的公告说所有人待定，会在 30 日早上公布新的决定。这天下午我们还是继续练习 A 区，同以前一样，在晚饭前结束。 5.30今天是 AB 和另一个老头的科三最后一次练习，我也四点多起床跟着去熟悉环境。租了考试用的车，刚出发发现右后轮瘪了，便又回到停车场，充气后似乎没有再瘪下去的迹象。工作人员（也许是交警）给我的印象是十分的凶，再没有其他了。别人练车于我没有太大的帮助，跟着熟悉了几次灯光模拟，大概感觉没有问题了。我想这一个上午是不是多余了，因为两天后我自己也还要租车练习。 5.31三人都考出了。 6.1今天是儿童节。 早早去到了场地，考试车的计算机系统似乎是 Windows XP 的音效，一开始出了问题，在没有用系统的情况下先练了一圈，随后找到工作人员修理。修好之后原地开始，因为启动不在规定的地方，扣 100 分，不过我继续开完了一圈。第二圈通过了。第三圈在直线行驶处避让停着的大货车，方向不稳，扣 100 分。第四次很慌，在直线行驶处不敢动方向盘，方向不稳，扣 100 分。第五次没有开完，但至少完成了直线行驶。一个半小时的时间已经结束了。 也许是一个人练习效果会差一些，也许是我的错觉，但无论如何，我不敢说再多一些练习也是没有必要的了。 6.2在候考厅，有警官教育大家不要给考官塞钱，看上去也十分和蔼，不像之前看到的那些人。科三人工扣分项目贴在了墙上，起步前居然要环顾四周，否则扣 100 分，让我大吃一惊。等候一段时间后开考了。 考试车的感觉和昨天练习的大有不同，不敢调座位，于是左脚几乎要伸直才能将离合踩到底，所幸离合有效的一段在比较高的位置，还算容易控制。唯一一个没有红绿灯的路口有人管着路过的车辆，这样考试车都可以顺利通过而不至于被逼停在路口。考到一半开始下雨，我开了雨刮器。在完成掉头后，我发现车的怠速有些过于快了，等到变道处我几乎已经追上前车，慌乱之中我加油门选择超越，却已经来不及，越过了完成变道的范围。大脑一片空白，我问考官是否需要停车，他让我在右转后靠边。我下车坐到后排，考官将车开回起点进行补考。我问这辆车的怠速是不是太快，刚才的地方应该怎么做。他平静地说这也不快，刚才的地方要超车就要在刚完成掉头的地方加速，而如果晚了就应该停车等待。 尽管感动于考官的和善，我也无法除去心中的紧张，若是补考出现失误，那等待我的是一个多星期的额外的煎熬，而同学们即将在高考后解放出来，我更不愿在那时去面对可怕的驾考。好在补考时前方完全没有一辆考试车，我便一个人做着烂熟在心的动作，终于到了靠边停车。拉起手刹的一刻，我焦急等待着系统提示“考试合格，请回中心打印成绩单”。语音说道正在等待中心确认，我的心总归是放下了。考官已经走到车边打开了我的车门，下车我问他需不需要我关车门（不关可以扣 100 分），他却说不用了。坐回后座，这次是与前一次相反的心情，我看着窗外的风景，急于把消息告诉所有人，而又沉浸在这片刻的美好宁静。 最后成绩是 90 分，靠边停车靠得不够边。倘若再有任何一个小失误，我今天便要敲烂自己的头了。","link":"/%E5%AD%A6%E8%BD%A6diary/"},{"title":"类欧几里得算法","text":"问题求以下形式表达式的值。 $$ \\sum_{i=0}^n i^{k_1}\\left\\lfloor \\frac{a\\times i+b}{c} \\right\\rfloor ^{k_2} $$ 简单情况求 $$ f(a,b,c,n)=\\sum_{i=0}^n \\left\\lfloor \\frac{a\\times i+b}{c} \\right\\rfloor $$ 概述这其实相当于求一条直线下的整点数。 考虑到直线斜率非常大的时候，可以快速转化为斜率 $&lt;1$ 的情况，并且规模可以缩小到原先的至多 $\\frac{1}{2}$。 而直线斜率小的时候可以用对称不改变规模转化为大的情况。 这样总次数就是 $O(\\log c)$ 了。 做法一$a=0$ 时，直接算。 二若 $a\\ge c$ 或 $b\\ge c$： 首先有 $$\\begin{aligned}f(a,b,c,n) = &amp; \\sum_{i=0}^n \\left\\lfloor \\frac{a\\times i+b}{c} \\right\\rfloor \\= &amp; \\sum_{i=0}^n \\left( \\left\\lfloor \\frac{a}{c} \\right\\rfloor i + \\left\\lfloor \\frac{b}{c} \\right\\rfloor +\\left\\lfloor \\frac{(a\\bmod c)i+(b\\bmod c)}{c} \\right\\rfloor\\right) \\= &amp; \\frac{n(n+1)}{2} \\left\\lfloor \\frac{a}{c} \\right\\rfloor + (n+1) \\left\\lfloor \\frac{b}{c} \\right\\rfloor + f(a\\bmod c, b\\bmod c, c, n)\\end{aligned}$$ 前面的两项可以直接计算，接下来只考虑 $a&lt;c,b&lt;c$ 的情况。 三若 $a,b&lt;c$： 枚举一个 $j$ $$\\sum_{i=0}^n \\left\\lfloor \\frac{a\\times i+b}{c} \\right\\rfloor= \\sum_{i=0}^n \\sum_{j=0}^{\\left\\lfloor \\frac{a\\times i+b}{c} \\right\\rfloor-1} 1$$ 令 $m=\\left\\lfloor \\frac{a\\times n+b}{c} \\right\\rfloor$， 于是 $$\\begin{aligned} \\sum_{i=0}^n \\left\\lfloor \\frac{a\\times i+b}{c} \\right\\rfloor= &amp; \\sum_{i=0}^n \\sum_{j=0}^{\\left\\lfloor \\frac{a\\times i+b}{c} \\right\\rfloor-1} 1 \\= &amp; \\sum_{i=0}^n \\sum_{j=0}^{m-1} [j+1\\le \\left\\lfloor \\frac{a\\times i+b}{c} \\right\\rfloor] \\= &amp; \\sum_{i=0}^n \\sum_{j=0}^{m-1} [i\\ge\\left\\lceil \\frac{cj+c-b}{a} \\right\\rceil] \\= &amp; \\sum_{i=0}^n \\sum_{j=0}^{m-1} [i\\ge\\left\\lfloor \\frac{cj+c-b-1}{a} \\right\\rfloor+1] \\= &amp; \\sum_{j=0}^{m-1} \\sum_{i=0}^n [i\\ge\\left\\lfloor \\frac{cj+c-b-1}{a} \\right\\rfloor+1] \\= &amp; \\sum_{j=0}^{m-1} n-\\left\\lfloor \\frac{cj+c-b-1}{a} \\right\\rfloor \\= &amp; mn-f(c,c-b-1,a,m-1)\\end{aligned}$$ 其中第二行到第三行的变换自己推一推就好了，注意直接做会得到上取整。 主要套路是交换两个 $\\sum$。 复杂度观察第 $a,c$ 两个变量，$(a,c)\\to(a\\bmod c,c)\\to(c, a\\bmod c)$ 于是复杂度和欧几里得算法相同。 代码可以自然溢出，最终答案在范围内即可。 听说自然溢出要 unsigned，代码仅供参考。 1234567ll f(int a, int b, int c, int n){ ll ans=(ll)n*(n+1)/2*(a/c)+(ll)(n+1)*(b/c); a%=c, b%=c; if(!a) return ans; int m=((ll)n*a+b)/c; return ans+(ll)m*n-f(c, c-b-1, a, m-1);} 一般情况LOJ #138. 类欧几里得算法 $$ \\sum_{i=0}^n i^{k_1}\\left\\lfloor \\frac{a\\times i+b}{c} \\right\\rfloor ^{k_2} $$ 做法这里钦定 $0^0=1$。 特判首先，若 $a=0$ 或 $k_2=0$，问题转化为 $\\lambda\\sum\\limits_{i=0}^n i^{k_1}$ 的形式，其中 $\\lambda$ 是一个易求的常数。这可以直接插值。 另外需要注意 $n&lt;0$ 的情况。 但是鲁棒性较好的代码不需要某些特判。 一若 $a\\ge c$ 或 $b\\ge c$： 令 $$\\begin{aligned}f(a,b,c,n,k_1,k_2) &amp;= \\sum_{i=0}^n i^{k_1}\\left\\lfloor \\frac{a\\times i+b}{c} \\right\\rfloor ^{k_2} \\&amp;= \\sum_{i=0}^n i^{k_1}\\left( \\left\\lfloor \\frac{a}{c} \\right\\rfloor i + \\left\\lfloor \\frac{b}{c} \\right\\rfloor +\\left\\lfloor \\frac{(a\\bmod c)i+(b\\bmod c)}{c} \\right\\rfloor \\right) ^{k_2}\\end{aligned}$$ 前面的两项可以插值。 三项式暴力展开，形式是若干个 $\\lambda \\times f(a\\bmod c, b\\bmod c, c, n, k_1’, k_2’)$，且其中 $k_1’+k_2’\\le k_1+k_2$。 二若 $a,b&lt;c$： 我们可以把 $x^{k_2}$ 转化为 $\\sum\\limits_{j=0}^{x-1}\\left((j+1)^{k_2}-j^{k_2}\\right)$。 同样令 $m=\\left\\lfloor \\frac{a\\times n+b}{c} \\right\\rfloor$， $$\\begin{aligned}f(a,b,c,n,k_1,k_2)&amp;= \\sum_{i=0}^n i^{k_1}\\left\\lfloor \\frac{a\\times i+b}{c} \\right\\rfloor ^{k_2} \\&amp;= \\sum_{i=0}^n i^{k_1} \\sum_{j=0}^{\\left\\lfloor \\frac{a\\times i+b}{c} \\right\\rfloor-1} \\left((j+1)^{k_2}-j^{k_2}\\right) \\&amp;= \\sum_{i=0}^n i^{k_1}\\sum_{j=0}^{m-1} \\left((j+1)^{k_2}-j^{k_2}\\right) [j\\le \\left\\lfloor \\frac{a\\times i+b}{c} \\right\\rfloor-1] \\&amp;= \\sum_{i=0}^n i^{k_1}\\sum_{j=0}^{m-1} \\left((j+1)^{k_2}-j^{k_2}\\right) [i&gt;\\left\\lfloor \\frac{cj+c-b-1}{a} \\right\\rfloor] \\&amp;= \\sum_{j=0}^{m-1} \\left((j+1)^{k_2}-j^{k_2}\\right) \\sum_{i=0}^n i^{k_1}[i&gt;\\left\\lfloor \\frac{cj+c-b-1}{a} \\right\\rfloor] \\&amp;= \\sum_{j=0}^{m-1} \\left((j+1)^{k_2}-j^{k_2}\\right) \\left(\\sum_{i=0}^n i^{k_1} -\\sum_{i=0}^{\\left\\lfloor \\frac{cj+c-b-1}{a} \\right\\rfloor}i^{k_1}\\right)\\&amp;= \\left(\\sum_{j=0}^{m-1} \\left((j+1)^{k_2}-j^{k_2}\\right)\\right) \\times \\left( \\sum_{i=0}^n i^{k_1} \\right) - \\sum_{j=0}^{m-1} \\left((j+1)^{k_2}-j^{k_2}\\right) \\sum_{i=0}^{\\left\\lfloor \\frac{cj+c-b-1}{a} \\right\\rfloor}i^{k_1}\\end{aligned}$$ 前面部分可以插值，后面的 $\\left((j+1)^{k_2}-j^{k_2}\\right)$ 是一个关于 $j$ 的 $k_2-1$ 次多项式 $A(x)$，$\\sum\\limits_{i=0}^{\\left\\lfloor \\frac{cj+c-b-1}{a} \\right\\rfloor}i^{k_1}$ 是一个关于 $\\left\\lfloor \\frac{cj+c-b-1}{a} \\right\\rfloor$ 的 $\\left\\lfloor \\frac{cj+c-b-1}{a} \\right\\rfloor$ 的 $k_1+1$ 次多项式 $B(x)$。 转化为 $\\sum\\limits_{j=0}^{m-1} A(j) \\times B\\left(\\left\\lfloor \\frac{cj+c-b-1}{a} \\right\\rfloor\\right)$。 枚举两个多项式的项 $x^{k_1’}$ 和 $x^{k_2’}$，有贡献是 $$[x^{k_1’}]A(x) \\times [x^{k_2’}] B(x) \\times f(c, c-b-1, a, m-1, k_1’, k_2’)$$ 并且也有 $k_1’+k_2’\\le k_1+k_2$。 复杂度可以发现每层的 $n,a,b,c$ 都是相同的，记忆化 $k_1,k_2$ 两维。 注意到 $(a,c)\\to (a\\bmod c,c) \\to(c,a\\bmod c)$，层数是 $O(\\log c)$ 的。 每次计算是 $O\\left((k_1+k_2)^2\\right)$，所以总复杂度就是 $O\\left((k_1+k_2)^4\\log c\\right)$。 跑得很快就是了。 代码注意代码中 $A_{k_2}(x) = \\sum\\limits_{i=0}^x \\left((i+1)^{k_2}-i^{k_2}\\right)$，和上面定义的 $A(x)$ 不同。 $B_{k_1}(x) = \\sum\\limits_{i=0}^x i^{k_1}$。 update on 2019-1-7 19:24:20: 之前的代码记忆化层数开了60，在Luogu 上的模板题里被 Sooke 卡到了66层qaq。 还被卡常了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#include&lt;string.h&gt;using namespace std;#define ll long longconst int N = 12, P = 1000000007;int n, a, b, c, k1, k2, T, Y[N], C[N][N], F[75][N][N];struct Poly{ int a[N]; inline Poly(){ memset(a, 0, sizeof a);} inline Poly operator +(const Poly &amp;rhs)const{ Poly ans; for(int i=0; i&lt;N; ++i) ans.a[i]=(a[i]+rhs.a[i])%P; return ans; } inline Poly operator *(const Poly &amp;rhs)const{ Poly ans; for(int i=0; i&lt;N; ++i) for(int j=0; i+j&lt;N; ++j) ans.a[i+j]=(ans.a[i+j]+(ll)a[i]*rhs.a[j])%P; return ans; } inline int calc(int n, int k){ int ans=a[k+1]; for(int i=k; ~i; --i) ans=((ll)ans*n+a[i])%P; return ans; }} A[N], B[N];inline int Pow(ll x, int y=P-2){ int ans=1; for(x+=P; y; y&gt;&gt;=1, x=x*x%P) if(y&amp;1) ans=ans*x%P; return ans;}void solve(Poly &amp;A, int n){ for(int i=0; i&lt;=n; ++i){ Poly t; t.a[0]=Y[i]; for(int j=0; j&lt;=n; ++j) if(j!=i) t.a[0]=(ll)t.a[0]*Pow(i-j)%P; for(int j=0; j&lt;=n; ++j) if(j!=i){ Poly d; d.a[0]=P-j, d.a[1]=1; t=t*d; } A=A+t; }}int f(int n, int a, int b, int c, int k1, int k2, int dep=0){ if(~F[dep][k1][k2]) return F[dep][k1][k2]; int ans=0; if(!a) ans=(ll)B[k1].calc(n, k1)*Pow(b/c, k2)%P; else if(!k2) ans=B[k1].calc(n, k1); else if(a&gt;=c || b&gt;=c){ int x=a/c, y=b/c; a%=c, b%=c; for(int i=0, I=1; i&lt;=k2; ++i, I=(ll)I*x%P) for(int j=0, J=I; i+j&lt;=k2; ++j, J=(ll)J*y%P) ans=(ans+(ll)f(n, a, b, c, k1+i, k2-i-j, dep+1)*C[k2][i]%P*C[k2-i][j]%P*J)%P; } else{ int m=((ll)a*n+b)/c; ans=(ll)A[k2].calc(m-1, k2)*B[k1].calc(n, k1)%P; for(int j=0; j&lt;k2; ++j) for(int i=0; i&lt;=k1+1; ++i) ans=(ans-(ll)f(m-1, c, c-b-1, a, j, i, dep+1)*C[k2][j]%P*B[k1].a[i])%P; } return F[dep][k1][k2]=(ans+P)%P;}int main() { C[0][0]=1; for(int i=1; i&lt;=10; ++i) for(int j=0; j&lt;=i; ++j) C[i][j]=(C[i-1][j]+(j?C[i-1][j-1]:0))%P; for(int i=0; i&lt;=10; ++i){ Y[0]=1-!i; for(int j=1; j&lt;=i+1; ++j) Y[j]=((ll)P+Y[j-1]+Pow(j+1, i)-Pow(j, i))%P; solve(A[i], i+1); Y[0]=!i; for(int j=1; j&lt;=i+1; ++j) Y[j]=(Y[j-1]+Pow(j, i))%P; solve(B[i], i+1); } scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%d%d%d%d%d%d&quot;, &amp;n, &amp;a, &amp;b, &amp;c, &amp;k1, &amp;k2); memset(F, -1, sizeof F); printf(&quot;%d\\n&quot;, f(n, a, b, c, k1, k2)); } return 0;} 一种特殊情况UOJ #42. 【清华集训2014】Sum 求 $$\\sum_{d = 1}^{n}{(-1)^{\\left\\lfloor \\sqrt{d\\times r\\times d} \\right\\rfloor}}$$ 做法显然只要求 $\\sum_{d=1}^n (\\left\\lfloor d \\sqrt r \\right\\rfloor \\bmod 2) = \\sum_{d=1}^n \\left\\lfloor d \\sqrt r \\right\\rfloor -2 \\sum_{d=1}^n \\left\\lfloor \\frac{d \\sqrt r}{2} \\right\\rfloor$。 设 $$f(a,b,c,n) = \\sum_{i=1}^n \\left\\lfloor i \\times \\frac{a\\sqrt r + b}{c}\\right\\rfloor$$ 一若 $\\frac{a\\sqrt r +b}{c}\\ge 1$，有 $$\\begin{aligned}f(a,b,c,n) &amp; = \\sum_{i=1}^n \\left\\lfloor i \\times \\frac{a\\sqrt r + b}{c}\\right\\rfloor \\&amp; = \\sum_{i=1}^n \\left\\lfloor i \\left\\lfloor \\frac{a\\sqrt r + b}{c}\\right\\rfloor + i\\left(\\frac{a\\sqrt r + b}{c} - \\left\\lfloor \\frac{a\\sqrt r + b}{c} \\right\\rfloor\\right) \\right\\rfloor\\end{aligned}$$ 第一部分可以提出直接计算，于是我们只考虑 $\\frac{a\\sqrt r + b}{c}&lt;1$ 的情况。 二若 $\\frac{a\\sqrt r + b}{c}&lt;1$： 令 $m=\\left\\lfloor n\\times \\frac{a\\sqrt r + b}{c} \\right\\rfloor$， $$\\begin{aligned}f(a,b,c,n) &amp; = \\sum_{i=1}^n \\sum_{j=1}^m [j\\le \\left\\lfloor i\\times \\frac{a\\sqrt r + b}{c} \\right\\rfloor] \\&amp; = \\sum_{j=1}^m \\sum_{i=1}^n [i\\ge \\left\\lceil j\\times \\frac{ac\\sqrt r-bc}{a^2r-b^2} \\right\\rceil] \\&amp; = \\sum_{j=1}^m n-\\left\\lceil j\\times \\frac{ac\\sqrt r-bc}{a^2r-b^2} \\right\\rceil+1\\end{aligned}$$ 第二行可以通过移项和分母有理化得到。 注意这里上取整解决不了，可以发现上取整和下取整 $+1$ 只有在整数时不同，这里要是整数必然有 $r$ 是完全平方数 可以发现当 $\\frac{a^2r-b^2}{\\gcd(ac\\sqrt r-bc, a^2r-b^2)} \\mid j$ 时会出现整数，特判即可。 另一种解决方法是当 $\\sqrt r$ 是整数的时候可以很轻易地计算原式，在一开始判掉。 复杂度这里 $f(a,b,c,n)\\to f(ac,-bc,a^2r-b^2,m)$，令 $x=\\frac{a\\sqrt r+b}{c}&lt;1$，这可以看做 $(n,x)\\to (n’, \\frac{1}{x})$ 其中 $n’=\\lfloor n\\times x \\rfloor$ ，显然每次严格减小，但是没什么用。 令 $\\alpha=\\frac{\\sqrt{5}-1}{2}$ 当 $0&lt;x\\le \\alpha$，有 $n’=\\lfloor n\\times x \\rfloor \\le \\alpha n$ 当 $\\alpha&lt;x&lt;1$，有$1&lt;\\frac{1}{x}&lt;\\frac{1}{\\alpha}=\\alpha+1$，于是 $n’’=\\lfloor n’\\times (\\frac{1}{x}-1)\\rfloor&lt;\\alpha n’&lt;\\alpha n$ 于是递归至多两层后 $n$ 会变成至多 $\\alpha$ 倍，层数至多是 $2\\log_{\\frac{1}{\\alpha}} n+O(1)$。 总复杂度 $O(\\log^2 n)$。 但是这里数字会变得很大，每次约分一下就好了，我也不知道为什么能过，实测int可过。 代码不太懂自然溢出，反正能过。 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;int T, r, n;double sr;inline int gcd(int a, int b){ return b?gcd(b, a%b):a;}int f(int a, int b, int c, int n){ if(n==0) return 0; int g=gcd(gcd(a, b), c); a/=g, b/=g, c/=g; int t=(a*sr+b)/c; b-=t*c; int m=n*(a*sr+b)/c, ssr=sr, ans=0; if(ssr*ssr==r &amp;&amp; a*a*r-b*b) ans=m/((a*a*r-b*b)/gcd(a*c*ssr-b*c, a*a*r-b*b)); return n*(n+1)/2*t+m*n-f(a*c, -b*c, a*a*r-b*b, m)+ans;}int main() { scanf(&quot;%d&quot;, &amp;T); while(T--){ scanf(&quot;%d%d&quot;, &amp;n, &amp;r), sr=sqrt(r); printf(&quot;%d\\n&quot;, n-2*(f(1, 0, 1, n)-2*f(1, 0, 2, n))); } return 0;}","link":"/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"斯特林数","slug":"斯特林数","link":"/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"},{"name":"筛法","slug":"筛法","link":"/tags/%E7%AD%9B%E6%B3%95/"},{"name":"Min_25筛","slug":"Min-25筛","link":"/tags/Min-25%E7%AD%9B/"},{"name":"杜教筛","slug":"杜教筛","link":"/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"},{"name":"博弈","slug":"博弈","link":"/tags/%E5%8D%9A%E5%BC%88/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"01分数规划","slug":"01分数规划","link":"/tags/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"组合数学","slug":"组合数学","link":"/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"多项式","slug":"多项式","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"生成函数","slug":"生成函数","link":"/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"name":"伯努利数","slug":"伯努利数","link":"/tags/%E4%BC%AF%E5%8A%AA%E5%88%A9%E6%95%B0/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀自动机","slug":"后缀自动机","link":"/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"点分治","slug":"点分治","link":"/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"仙人掌","slug":"仙人掌","link":"/tags/%E4%BB%99%E4%BA%BA%E6%8E%8C/"},{"name":"圆方树","slug":"圆方树","link":"/tags/%E5%9C%86%E6%96%B9%E6%A0%91/"},{"name":"Tarjan","slug":"Tarjan","link":"/tags/Tarjan/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"树形dp","slug":"树形dp","link":"/tags/%E6%A0%91%E5%BD%A2dp/"},{"name":"倍增","slug":"倍增","link":"/tags/%E5%80%8D%E5%A2%9E/"},{"name":"分块","slug":"分块","link":"/tags/%E5%88%86%E5%9D%97/"},{"name":"莫队","slug":"莫队","link":"/tags/%E8%8E%AB%E9%98%9F/"},{"name":"拉格朗日反演","slug":"拉格朗日反演","link":"/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%8F%8D%E6%BC%94/"},{"name":"集合幂级数","slug":"集合幂级数","link":"/tags/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/"},{"name":"FWT","slug":"FWT","link":"/tags/FWT/"},{"name":"博弈论","slug":"博弈论","link":"/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"Nim","slug":"Nim","link":"/tags/Nim/"},{"name":"最小树形图","slug":"最小树形图","link":"/tags/%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE/"},{"name":"朱刘算法","slug":"朱刘算法","link":"/tags/%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95/"},{"name":"二次剩余","slug":"二次剩余","link":"/tags/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/"},{"name":"特征多项式","slug":"特征多项式","link":"/tags/%E7%89%B9%E5%BE%81%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"观察","slug":"观察","link":"/tags/%E8%A7%82%E5%AF%9F/"},{"name":"Segment tree beats","slug":"Segment-tree-beats","link":"/tags/Segment-tree-beats/"},{"name":"平衡树","slug":"平衡树","link":"/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"two pointers","slug":"two-pointers","link":"/tags/two-pointers/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"子集卷积","slug":"子集卷积","link":"/tags/%E5%AD%90%E9%9B%86%E5%8D%B7%E7%A7%AF/"},{"name":"FMT","slug":"FMT","link":"/tags/FMT/"},{"name":"压位","slug":"压位","link":"/tags/%E5%8E%8B%E4%BD%8D/"},{"name":"构造","slug":"构造","link":"/tags/%E6%9E%84%E9%80%A0/"},{"name":"差分","slug":"差分","link":"/tags/%E5%B7%AE%E5%88%86/"},{"name":"状压","slug":"状压","link":"/tags/%E7%8A%B6%E5%8E%8B/"},{"name":"矩阵","slug":"矩阵","link":"/tags/%E7%9F%A9%E9%98%B5/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"FFT","slug":"FFT","link":"/tags/FFT/"},{"name":"多点求值","slug":"多点求值","link":"/tags/%E5%A4%9A%E7%82%B9%E6%B1%82%E5%80%BC/"},{"name":"快速插值","slug":"快速插值","link":"/tags/%E5%BF%AB%E9%80%9F%E6%8F%92%E5%80%BC/"},{"name":"单位根反演","slug":"单位根反演","link":"/tags/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94/"},{"name":"期望","slug":"期望","link":"/tags/%E6%9C%9F%E6%9C%9B/"},{"name":"动态dp","slug":"动态dp","link":"/tags/%E5%8A%A8%E6%80%81dp/"},{"name":"set","slug":"set","link":"/tags/set/"},{"name":"k-d tree","slug":"k-d-tree","link":"/tags/k-d-tree/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"单调栈","slug":"单调栈","link":"/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"Prufer 序列","slug":"Prufer-序列","link":"/tags/Prufer-%E5%BA%8F%E5%88%97/"},{"name":"bitset","slug":"bitset","link":"/tags/bitset/"},{"name":"多项式ln","slug":"多项式ln","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8Fln/"},{"name":"暴力","slug":"暴力","link":"/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"min-max容斥","slug":"min-max容斥","link":"/tags/min-max%E5%AE%B9%E6%96%A5/"},{"name":"SAM","slug":"SAM","link":"/tags/SAM/"},{"name":"Topcoder","slug":"Topcoder","link":"/tags/Topcoder/"},{"name":"概率","slug":"概率","link":"/tags/%E6%A6%82%E7%8E%87/"},{"name":"全局平衡二叉树","slug":"全局平衡二叉树","link":"/tags/%E5%85%A8%E5%B1%80%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"类欧几里得算法","slug":"类欧几里得算法","link":"/tags/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"杂谈","slug":"杂谈","link":"/categories/%E6%9D%82%E8%B0%88/"},{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"OI 生活","slug":"OI-生活","link":"/categories/OI-%E7%94%9F%E6%B4%BB/"},{"name":"修电脑","slug":"修电脑","link":"/categories/%E4%BF%AE%E7%94%B5%E8%84%91/"},{"name":"Love","slug":"Love","link":"/categories/Love/"}],"pages":[{"title":"Gallery","text":"广西 桂林，2024.10.07","link":"/gallery/index.html"},{"title":"","text":"window.onload = function(){ if ($('#toc').length > 0){ $('#toc').addClass('is-sticky'); } else{ $('.column-left').addClass('is-sticky'); } }","link":"/js/custom.js"},{"title":"","text":"$('#btn_submit').click(function(){ var score = 0; score += $('input[name=problem1]:checked').val() == 4 ? 1 : 0; score += $('input[name=problem2]:checked').val() == 3 ? 1 : 0; score += $('input[name=problem3]:checked').val() == 3 ? 1 : 0; score += $('input[name=problem4]:checked').val() == 2 ? 1 : 0; score += $('input[name=problem5]:checked').val() == 1 ? 1 : 0; score += $('input[name=problem6]:checked').val() == 4 ? 1 : 0; score += $('input[name=problem8]:checked').val() == 3 ? 1 : 0; score += $('input[name=problem9]:checked').val() == 3 ? 1 : 0; var answer7 = 0; $('input[name=problem7]:checked').each(function(){ answer7 += 1; }); var answer0 = 0; $('input[name=problem0]:checked').each(function(){ answer0 += $(this).val()","link":"/lzy/challenge.js"},{"title":"生日快乐！","text":"fieldset { border-width: 2px; border-style: groove; border-color: rgb(192, 192, 192); margin-bottom: 1em; padding-block-start: 0.35em; padding-inline-start: 0.75em; padding-inline-end: 0.75em; padding-block-end: 0.625em; } legend { padding-inline-start: 0.3em; padding-inline-end: 0.3em; } 答对6题以上可以解锁下一步哦。 txc最喜欢的颜色是 黑色 白色 黑白交错 绿色 txc后来买的一对Joy-Con是什么颜色的 红蓝 紫橙 粉绿 黑白 txc歪过几次小保底 3 4 5 6 这个博客使用的Hexo主题叫 NexT Icarus Material landscape txc有几个老婆 1个 3个 7个 15个 txc去过 青海 天津 广西 贵州 《轻音少女》里txc喜欢 唯 澪 律 䌷 梓 txc正月初一徒步的时候买了一瓶脉动过期了几个月 1个月 2个月 3个月 4个月 txc正月初四打了两局麻将，结果排名都是 1 2 3 4 txc最喜欢 你 lzy 桌桌 姐姐 提交","link":"/lzy/index.html"}]}